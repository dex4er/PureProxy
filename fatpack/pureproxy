#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
    my %fatpacked;

    $fatpacked{"Apache/LogFormat/Compiler.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'APACHE_LOGFORMAT_COMPILER';
  package Apache::LogFormat::Compiler;
  
  use strict;
  use warnings;
  use 5.008001;
  use Carp;
  use POSIX::strftime::Compiler qw//;
  use constant {
      ENVS => 0,
      RES => 1,
      LENGTH => 2,
      REQTIME => 3,
      TIME => 4,
  };
  
  our $VERSION = '0.36';
  
  # copy from Plack::Middleware::AccessLog
  our %formats = (
      common => '%h %l %u %t "%r" %>s %b',
      combined => '%h %l %u %t "%r" %>s %b "%{Referer}i" "%{User-agent}i"',
  );
  
  sub _safe {
      my $string = shift;
      return unless defined $string;
      $string =~ s/([^[:print:]])/"\\x" . unpack("H*", $1)/eg;
      return $string;
  }
  
  sub _string {
      my $string = shift;
      return '-' if ! defined $string;
      return '-' if ! length $string;
      $string =~ s/([^[:print:]])/"\\x" . unpack("H*", $1)/eg;
      return $string;
  }
  
  sub header_get {
      my ($headers, $key) = @_;
      $key = lc $key;
      my @headers = @$headers; # copy
      my $value;
      while (my($hdr, $val) = splice @headers, 0, 2) {
          if ( lc $hdr eq $key ) {
              $value = $val;
              last;
          }
      }
      return $value;
  }
  
  my $psgi_reserved = { CONTENT_LENGTH => 1, CONTENT_TYPE => 1 };
  
  my $block_handler = sub {
      my($block, $type, $extra) = @_;
      my $cb;
      if ($type eq 'i') {
          $block =~ s/-/_/g;
          $block = uc($block);
          $block = "HTTP_${block}" unless $psgi_reserved->{$block};
          $cb =  q!_string($_[ENVS]->{'!.$block.q!'})!;
      } elsif ($type eq 'o') {
          $cb =  q!_string(header_get($_[RES]->[1],'!.$block.q!'))!;
      } elsif ($type eq 't') {
          $cb =  q!"[" . POSIX::strftime::Compiler::strftime('!.$block.q!', @lt) . "]"!;
      } elsif (exists $extra->{$type}) {
          $cb =  q!_string($extra_block_handlers->{'!.$type.q!'}->('!.$block.q!',$_[ENVS],$_[RES],$_[LENGTH],$_[REQTIME]))!;
      } else {
          Carp::croak("{$block}$type not supported");
          $cb = "-";
      }
      return q|! . | . $cb . q|
        . q!|;
  };
  
  our %char_handler = (
      '%' => q!'%'!,
      h => q!($_[ENVS]->{REMOTE_ADDR} || '-')!,
      l => q!'-'!,
      u => q!($_[ENVS]->{REMOTE_USER} || '-')!,
      t => q!'[' . $t . ']'!,
      r => q!_safe($_[ENVS]->{REQUEST_METHOD}) . " " . _safe($_[ENVS]->{REQUEST_URI}) .
                         " " . $_[ENVS]->{SERVER_PROTOCOL}!,
      s => q!$_[RES]->[0]!,
      b => q!(defined $_[LENGTH] ? $_[LENGTH] : '-')!,
      T => q!(defined $_[REQTIME] ? int($_[REQTIME]/1_000_000) : '-')!,
      D => q!(defined $_[REQTIME] ? $_[REQTIME] : '-')!,
      v => q!($_[ENVS]->{SERVER_NAME} || '-')!,
      V => q!($_[ENVS]->{HTTP_HOST} || $_[ENVS]->{SERVER_NAME} || '-')!,
      p => q!$_[ENVS]->{SERVER_PORT}!,
      P => q!$$!,
      m => q!_safe($_[ENVS]->{REQUEST_METHOD})!,
      U => q!_safe($_[ENVS]->{PATH_INFO})!,
      q => q!(($_[ENVS]->{QUERY_STRING} ne '') ? '?' . _safe($_[ENVS]->{QUERY_STRING}) : '' )!,
      H => q!$_[ENVS]->{SERVER_PROTOCOL}!,
  
  );
  
  my $char_handler = sub {
      my ($char, $extra) = @_;
      my $cb = $char_handler{$char};
      if (!$cb && exists $extra->{$char}) {
          $cb = q!_string($extra_char_handlers->{'!.$char.q!'}->($_[ENVS],$_[RES],$_[LENGTH],$_[REQTIME]))!;
      }
      unless ($cb) {
          Carp::croak "\%$char not supported.";
          return "-";
      }
      q|! . | . $cb . q|
        . q!|;
  };
  
  sub new {
      my $class = shift;
  
      my $fmt = shift || "combined";
      $fmt = $formats{$fmt} if exists $formats{$fmt};
  
      my %opts = @_;
  
      my ($code_ref, $code) = compile($fmt, $opts{block_handlers} || {}, $opts{char_handlers} || {});
      bless [$code_ref, $code], $class;
  }
  
  sub compile {
      my $fmt = shift;
      my $extra_block_handlers = shift;
      my $extra_char_handlers = shift;
      $fmt =~ s/!/\\!/g;
      $fmt =~ s!
          (?:
               \%\{(.+?)\}([a-zA-Z]) |
               \%(?:[<>])?([a-zA-Z\%])
          )
      ! $1 ? $block_handler->($1, $2, $extra_block_handlers) : $char_handler->($3, $extra_char_handlers) !egx;
      
      my @abbr = qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec );
      my $c = {};
      $fmt = q~sub {
          $_[TIME] = time() if ! defined $_[TIME];
          my @lt = localtime($_[TIME]);
          if ( ! exists $c->{tz_cache} || ! exists $c->{isdst_cache} || $lt[8] != $c->{isdst_cache} ) {
              $c->{tz_cache} = POSIX::strftime::Compiler::strftime('%z',@lt);
              $c->{isdst_cache} = $lt[8];
          }    
          my $t = sprintf '%02d/%s/%04d:%02d:%02d:%02d %s', $lt[3], $abbr[$lt[4]], $lt[5]+1900,
            $lt[2], $lt[1], $lt[0], $c->{tz_cache};
          q!~ . $fmt . q~!
      }~;
      my $code_ref = eval $fmt; ## no critic
      die $@ . "\n===\n" . $fmt if $@;
      wantarray ? ($code_ref, $fmt) : $code_ref;
  }
  
  sub log_line {
      my $self = shift;
      $self->[0]->(@_) . "\n";
  }
  
  sub code {
      my $self = shift;
      $self->[1];
  }
  
  sub code_ref {
      my $self = shift;
      $self->[0];
  }
  
  1;
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Apache::LogFormat::Compiler - Compile a log format string to perl-code 
  
  =head1 SYNOPSIS
  
    use Apache::LogFormat::Compiler;
  
    my $log_handler = Apache::LogFormat::Compiler->new("combined");
    my $log = $log_handler->log_line(
        $env,
        $res,
        $length,
        $reqtime,
        $time
    );
  
  =head1 DESCRIPTION
  
  Compile a log format string to perl-code. For faster generation of access_log lines.
  
  =head1 METHOD
  
  =over 4
  
  =item new($fmt:String)
  
  Takes a format string (or a preset template C<combined> or C<custom>)
  to specify the log format. This module implements a subset of
  L<Apache's LogFormat templates|http://httpd.apache.org/docs/2.0/mod/mod_log_config.html>:
  
     %%    a percent sign
     %h    REMOTE_ADDR from the PSGI environment, or -
     %l    remote logname not implemented (currently always -)
     %u    REMOTE_USER from the PSGI environment, or -
     %t    [local timestamp, in default format]
     %r    REQUEST_METHOD, REQUEST_URI and SERVER_PROTOCOL from the PSGI environment
     %s    the HTTP status code of the response
     %b    content length of the response
     %T    custom field for handling times in subclasses
     %D    custom field for handling sub-second times in subclasses
     %v    SERVER_NAME from the PSGI environment, or -
     %V    HTTP_HOST or SERVER_NAME from the PSGI environment, or -
     %p    SERVER_PORT from the PSGI environment
     %P    the worker's process id
     %m    REQUEST_METHOD from the PSGI environment
     %U    PATH_INFO from the PSGI environment
     %q    QUERY_STRING from the PSGI environment
     %H    SERVER_PROTOCOL from the PSGI environment
  
  In addition, custom values can be referenced, using C<%{name}>,
  with one of the mandatory modifier flags C<i>, C<o> or C<t>:
  
     %{variable-name}i    HTTP_VARIABLE_NAME value from the PSGI environment
     %{header-name}o      header-name header in the response
     %{time-format]t      localtime in the specified strftime format
  
  =item log_line($env:HashRef, $res:ArrayRef, $length:Integer, $reqtime:Integer, $time:Integer): $log:String
  
  Generates log line.
  
    $env      PSGI env request HashRef
    $res      PSGI response ArrayRef
    $length   Content-Length
    $reqtime  The time taken to serve request in microseconds. optional
    $time     Time the request was received. optional. If $time is undefined. current timestamp is used.
  
  Sample psgi 
  
    use Plack::Builder;
    use Time::HiRes;
    use Apache::LogFormat::Compiler;
  
    my $log_handler = Apache::LogFormat::Compiler->new(
        '%h %l %u %t "%r" %>s %b "%{Referer}i" "%{User-agent}i" %D'
    );
    my $compile_log_app = builder {
        enable sub {
            my $app = shift;
            sub {
                my $env = shift;
                my $t0 = [gettimeofday];
                my $res = $app->();
                my $reqtime = int(Time::HiRes::tv_interval($t0) * 1_000_000);
                $env->{psgi.error}->print($log_handler->log_line(
                    $env,$res,6,$reqtime, $t0->[0]));
            }
        };
        $app
    };
  
  =back
  
  =head1 ABOUT POSIX::strftime::Compiler
  
  This module uses L<POSIX::strftime::Compiler> for generate datetime string. POSIX::strftime::Compiler provides GNU C library compatible strftime(3). But this module will not affected by the system locale. This feature is useful when you want to write loggers, servers and portable applications.
  
  =head1 ADD CUSTOM FORMAT STRING
  
  Apache::LogFormat::Compiler allows one to add a custom format string
  
    my $log_handler = Apache::LogFormat::Compiler->new(
        '%z %{HTTP_X_FORWARDED_FOR|REMOTE_ADDR}Z',
        char_handlers => +{
            'z' => sub {
                my ($env,$req) = @_;
                return $env->{HTTP_X_FORWARDED_FOR};
            }
        },
        block_handlers => +{
            'Z' => sub {
                my ($block,$env,$req) = @_;
                # block eq 'HTTP_X_FORWARDED_FOR|REMOTE_ADDR'
                my ($main, $alt) = split('\|', $args);
                return exists $env->{$main} ? $env->{$main} : $env->{$alt};
            }
        },
    );
  
  Any single letter can be used, other than those already defined by Apache::LogFormat::Compiler.
  Your sub is called with two or three arguments: the content inside the C<{}>
  from the format (block_handlers only), the PSGI environment (C<$env>),
  and the ArrayRef of the response. It should return the string to be logged.
  
  =head1 AUTHOR
  
  Masahiro Nagano E<lt>kazeburo@gmail.comE<gt>
  
  =head1 SEE ALSO
  
  L<Plack::Middleware::AccessLog>, L<http://httpd.apache.org/docs/2.2/mod/mod_log_config.html>
  
  =head1 LICENSE
  
  Copyright (C) Masahiro Nagano
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
APACHE_LOGFORMAT_COMPILER

    $fatpacked{"Clone/PP.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'CLONE_PP';
  package Clone::PP;
  
  use 5.006;
  use strict;
  use warnings;
  use vars qw($VERSION @EXPORT_OK);
  use Exporter;
  
  $VERSION = 1.08;
  
  @EXPORT_OK = qw( clone );
  sub import { goto &Exporter::import } # lazy Exporter
  
  # These methods can be temporarily overridden to work with a given class.
  use vars qw( $CloneSelfMethod $CloneInitMethod );
  $CloneSelfMethod ||= 'clone_self';
  $CloneInitMethod ||= 'clone_init';
  
  # Used to detect looped networks and avoid infinite recursion. 
  use vars qw( %CloneCache );
  
  # Generic cloning function
  sub clone {
    my $source = shift;
  
    return undef if not defined($source);
    
    # Optional depth limit: after a given number of levels, do shallow copy.
    my $depth = shift;
    return $source if ( defined $depth and $depth -- < 1 );
    
    # Maintain a shared cache during recursive calls, then clear it at the end.
    local %CloneCache = ( undef => undef ) unless ( exists $CloneCache{undef} );
    
    return $CloneCache{ $source } if ( defined $CloneCache{ $source } );
    
    # Non-reference values are copied shallowly
    my $ref_type = ref $source or return $source;
    
    # Extract both the structure type and the class name of referent
    my $class_name;
    if ( "$source" =~ /^\Q$ref_type\E\=([A-Z]+)\(0x[0-9a-f]+\)$/ ) {
      $class_name = $ref_type;
      $ref_type = $1;
      # Some objects would prefer to clone themselves; check for clone_self().
      return $CloneCache{ $source } = $source->$CloneSelfMethod() 
  				  if $source->can($CloneSelfMethod);
    }
    
    # To make a copy:
    # - Prepare a reference to the same type of structure;
    # - Store it in the cache, to avoid looping if it refers to itself;
    # - Tie in to the same class as the original, if it was tied;
    # - Assign a value to the reference by cloning each item in the original;
    
    my $copy;
    if ($ref_type eq 'HASH') {
      $CloneCache{ $source } = $copy = {};
      if ( my $tied = tied( %$source ) ) { tie %$copy, ref $tied }
      %$copy = map { ! ref($_) ? $_ : clone($_, $depth) } %$source;
    } elsif ($ref_type eq 'ARRAY') {
      $CloneCache{ $source } = $copy = [];
      if ( my $tied = tied( @$source ) ) { tie @$copy, ref $tied }
      @$copy = map { ! ref($_) ? $_ : clone($_, $depth) } @$source;
    } elsif ($ref_type eq 'REF' or $ref_type eq 'SCALAR') {
      $CloneCache{ $source } = $copy = \( my $var = "" );
      if ( my $tied = tied( $$source ) ) { tie $$copy, ref $tied }
      $$copy = clone($$source, $depth);
    } else {
      # Shallow copy anything else; this handles a reference to code, glob, regex
      $CloneCache{ $source } = $copy = $source;
    }
    
    # - Bless it into the same class as the original, if it was blessed;
    # - If it has a post-cloning initialization method, call it.
    if ( $class_name ) {
      bless $copy, $class_name;
      $copy->$CloneInitMethod() if $copy->can($CloneInitMethod);
    }
    
    return $copy;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Clone::PP - Recursively copy Perl datatypes
  
  =head1 SYNOPSIS
  
    use Clone::PP qw(clone);
    
    $item = { 'foo' => 'bar', 'move' => [ 'zig', 'zag' ]  };
    $copy = clone( $item );
  
    $item = [ 'alpha', 'beta', { 'gamma' => 'vlissides' } ];
    $copy = clone( $item );
  
    $item = Foo->new();
    $copy = clone( $item );
  
  Or as an object method:
  
    require Clone::PP;
    push @Foo::ISA, 'Clone::PP';
    
    $item = Foo->new();
    $copy = $item->clone();
  
  =head1 DESCRIPTION
  
  This module provides a general-purpose clone function to make deep
  copies of Perl data structures. It calls itself recursively to copy
  nested hash, array, scalar and reference types, including tied
  variables and objects.
  
  The clone() function takes a scalar argument to copy. To duplicate
  arrays or hashes, pass them in by reference:
  
    my $copy = clone(\@array);    my @copy = @{ clone(\@array) };
    my $copy = clone(\%hash);     my %copy = %{ clone(\%hash) };
  
  The clone() function also accepts an optional second parameter that
  can be used to limit the depth of the copy. If you pass a limit of
  0, clone will return the same value you supplied; for a limit of
  1, a shallow copy is constructed; for a limit of 2, two layers of
  copying are done, and so on.
  
    my $shallow_copy = clone( $item, 1 );
  
  To allow objects to intervene in the way they are copied, the
  clone() function checks for a couple of optional methods. If an
  object provides a method named C<clone_self>, it is called and the
  result returned without further processing. Alternately, if an
  object provides a method named C<clone_init>, it is called on the
  copied object before it is returned.
  
  =head1 BUGS
  
  Some data types, such as globs, regexes, and code refs, are always copied shallowly.
  
  References to hash elements are not properly duplicated. (This is why two tests in t/dclone.t that are marked "todo".) For example, the following test should succeed but does not:
  
    my $hash = { foo => 1 }; 
    $hash->{bar} = \{ $hash->{foo} }; 
    my $copy = clone( \%hash ); 
    $hash->{foo} = 2; 
    $copy->{foo} = 2; 
    ok( $hash->{bar} == $copy->{bar} );
  
  To report bugs via the CPAN web tracking system, go to 
  C<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Clone-PP> or send mail 
  to C<Dist=Clone-PP#rt.cpan.org>, replacing C<#> with C<@>.
  
  =head1 SEE ALSO
  
  L<Clone> - a baseclass which provides a C<clone()> method.
  
  L<MooseX::Clone> - find-grained cloning for Moose objects.
  
  The C<dclone()> function in L<Storable>.
  
  L<Data::Clone> -
  polymorphic data cloning (see its documentation for what that means).
  
  L<Clone::Any> - use whichever of the cloning methods is available.
  
  =head1 REPOSITORY
  
  L<https://github.com/neilbowers/Clone-PP>
  
  =head1 AUTHOR AND CREDITS
  
  Developed by Matthew Simon Cavalletto at Evolution Softworks. 
  More free Perl software is available at C<www.evoscript.org>.
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2003 Matthew Simon Cavalletto. You may contact the author
  directly at C<evo@cpan.org> or C<simonm@cavalletto.org>.
  
  Code initially derived from Ref.pm. Portions Copyright 1994 David Muir Sharnoff.
  
  Interface based by Clone by Ray Finch with contributions from chocolateboy.
  Portions Copyright 2001 Ray Finch. Portions Copyright 2001 chocolateboy. 
  
  You may use, modify, and distribute this software under the same terms as Perl.
  
  =cut
CLONE_PP

    $fatpacked{"Cookie/Baker.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'COOKIE_BAKER';
  package Cookie::Baker;
  
  use 5.008001;
  use strict;
  use warnings;
  use base qw/Exporter/;
  use URI::Escape;
  
  BEGIN {
      our $VERSION = "0.11";
      our @EXPORT = qw/bake_cookie crush_cookie/;
      my $use_pp = $ENV{COOKIE_BAKER_PP};
      if (!$use_pp) {
          eval {
              require Cookie::Baker::XS;
              if ( $Cookie::Baker::XS::VERSION < $VERSION ) {
                  warn "Cookie::Baker::XS $VERSION is require. fallback to PP version";
                  die;
              }
          };
          $use_pp = !!$@;
      }
      if ($use_pp) {
          *crush_cookie = \&pp_crush_cookie;
      }
      else {
          *crush_cookie = \&Cookie::Baker::XS::crush_cookie;
      }
  }
  
  sub bake_cookie {
      my ($name,$val) = @_;
  
      return '' unless defined $val;
      my %args = ref $val ? %{$val} : (value => $val);
      $name = URI::Escape::uri_escape($name) if $name =~ m![^a-zA-Z\-\._~]!;
      my $cookie = "$name=" . URI::Escape::uri_escape($args{value}) . '; ';
      $cookie .= 'domain=' . $args{domain} . '; '  if $args{domain};
      $cookie .= 'path='. $args{path} . '; '       if $args{path};
      $cookie .= 'expires=' . _date($args{expires}) . '; ' if exists $args{expires} && defined $args{expires};
      $cookie .= 'max-age=' . $args{"max-age"} . '; ' if exists $args{"max-age"};
      if (exists $args{samesite} && $args{samesite} =~ m/^(?:lax|strict|none)/i) {
          $cookie .= 'SameSite=' . ucfirst(lc($args{samesite})) . '; '
      }
      $cookie .= 'secure; '                     if $args{secure};
      $cookie .= 'HttpOnly; '                   if $args{httponly};
      substr($cookie,-2,2,'');
      $cookie;
  }
  
  my @MON  = qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec );
  my @WDAY = qw( Sun Mon Tue Wed Thu Fri Sat );
  
  my %term = (
      's' => 1,
      'm' => 60,
      'h' => 3600,
      'd' => 86400,
      'M' => 86400 * 30,
      'y' => 86400 * 365,
  );
  
  sub _date {
      my $expires = shift;
  
      my $expires_at;
      if ($expires =~ /^\d+$/) {
          # all numbers -> epoch date
          $expires_at = $expires;
      }
      elsif ( $expires =~ /^([-+]?(?:\d+|\d*\.\d*))([smhdMy]?)/ ) {
          no warnings;
          my $offset = ($term{$2} || 1) * $1;
          $expires_at = time + $offset;
      }
      elsif ( $expires  eq 'now' ) {
          $expires_at = time;
      }
      else {
          return $expires;
      }
      my($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($expires_at);
      $year += 1900;
      # (cookies use '-' as date separator, HTTP uses ' ')
      return sprintf("%s, %02d-%s-%04d %02d:%02d:%02d GMT",
                     $WDAY[$wday], $mday, $MON[$mon], $year, $hour, $min, $sec);
  }
  
  sub pp_crush_cookie {
      my $cookie_string = shift;
      return {} unless $cookie_string;
      my %results;
      my @pairs = grep m/=/, split /; ?/, $cookie_string;
      for my $pair ( @pairs ) {
          # trim leading trailing whitespace
          $pair =~ s/^\s+//; $pair =~ s/\s+$//;
  
          my ($key, $value) = split( "=", $pair, 2 );
  
          $key = URI::Escape::uri_unescape($key);
  
          # Values can be quoted
          $value = "" unless defined $value;
          $value =~ s/\A"(.*)"\z/$1/;
          $value = URI::Escape::uri_unescape($value);
  
          # Take the first one like CGI.pm or rack do
          $results{$key} = $value unless exists $results{$key};
      }
      return \%results;
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  Cookie::Baker - Cookie string generator / parser
  
  =head1 SYNOPSIS
  
      use Cookie::Baker;
  
      $headers->push_header('Set-Cookie', bake_cookie($key,$val));
  
      my $cookies_hashref = crush_cookie($headers->header('Cookie'));
  
  =head1 DESCRIPTION
  
  Cookie::Baker provides simple cookie string generator and parser.
  
  =head1 XS IMPLEMENTATION
  
  This module tries to use L<Cookie::Baker::XS>'s crush_cookie by default.
  If this fails, it will use Cookie::Baker's pure Perl crush_cookie.
  
  There is no XS implementation of bake_cookie yet.
  
  =head1 FUNCTION
  
  =over 4
  
  =item bake_cookie
  
    my $cookie = bake_cookie('foo','val');
    my $cookie = bake_cookie('foo', {
        value => 'val',
        path => "test",
        domain => '.example.com',
        expires => '+24h'
    } );
  
  Generates a cookie string for an HTTP response header.
  The first argument is the cookie's name and the second argument is a plain string or hash reference that
  can contain keys such as C<value>, C<domain>, C<expires>, C<path>, C<httponly>, C<secure>,
  C<max-age>, C<samesite>.
  
  
  =over 4
  
  =item value
  
  Cookie's value.
  
  =item domain
  
  Cookie's domain.
  
  =item expires
  
  Cookie's expires date time. Several formats are supported:
  
    expires => time + 24 * 60 * 60 # epoch time
    expires => 'Wed, 03-Nov-2010 20:54:16 GMT'
    expires => '+30s' # 30 seconds from now
    expires => '+10m' # ten minutes from now
    expires => '+1h'  # one hour from now
    expires => '-1d'  # yesterday (i.e. "ASAP!")
    expires => '+3M'  # in three months
    expires => '+10y' # in ten years time (60*60*24*365*10 seconds)
    expires => 'now'  #immediately
  
  =item max-age
  
  If defined, sets the max-age for the cookie.
  
  =item path
  
  Cookie's path.
  
  =item httponly
  
  If true, sets HttpOnly flag. false by default.
  
  =item secure
  
  If true, sets secure flag. false by default.
  
  =item samesite
  
  If defined as 'lax' or 'strict' or 'none' (case-insensitive), sets the SameSite restriction for the cookie as described in the
  L<draft proposal|https://tools.ietf.org/html/draft-west-first-party-cookies-07>, which is already implemented in
  Chrome (v51), Safari (v12), Edge (v16),  Opera (v38) and Firefox (v60).
  
  =back
  
  =item crush_cookie
  
  Parses cookie string and returns a hashref.
  
      my $cookies_hashref = crush_cookie($headers->header('Cookie'));
      my $cookie_value = $cookies_hashref->{cookie_name}
  
  =back
  
  =head1 SEE ALSO
  
  CPAN already has many cookie related modules. But there is no simple cookie string generator and parser module.
  
  L<CGI>, L<CGI::Simple>, L<Plack>, L<Dancer::Cookie>
  
  =head1 LICENSE
  
  Copyright (C) Masahiro Nagano.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Masahiro Nagano E<lt>kazeburo@gmail.comE<gt>
  
  =cut
COOKIE_BAKER

    $fatpacked{"Exporter.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'EXPORTER';
  package Exporter;
  
  use strict;
  no strict 'refs';
  
  our $Debug = 0;
  our $ExportLevel = 0;
  our $Verbose ||= 0;
  our $VERSION = '5.77';
  our %Cache;
  
  sub as_heavy {
    require Exporter::Heavy;
    # Unfortunately, this does not work if the caller is aliased as *name = \&foo
    # Thus the need to create a lot of identical subroutines
    my $c = (caller(1))[3];
    $c =~ s/.*:://;
    \&{"Exporter::Heavy::heavy_$c"};
  }
  
  sub export {
    goto &{as_heavy()};
  }
  
  sub import {
    my $pkg = shift;
    my $callpkg = caller($ExportLevel);
  
    if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
      *{$callpkg."::import"} = \&import;
      return;
    }
  
    # We *need* to treat @{"$pkg\::EXPORT_FAIL"} since Carp uses it :-(
    my $exports = \@{"$pkg\::EXPORT"};
    # But, avoid creating things if they don't exist, which saves a couple of
    # hundred bytes per package processed.
    my $fail = ${$pkg . '::'}{EXPORT_FAIL} && \@{"$pkg\::EXPORT_FAIL"};
    return export $pkg, $callpkg, @_
      if $Verbose or $Debug or $fail && @$fail > 1;
    my $export_cache = ($Cache{$pkg} ||= {});
    my $args = @_ or @_ = @$exports;
  
    if ($args and not %$export_cache) {
      s/^&//, $export_cache->{$_} = 1
        foreach (@$exports, @{"$pkg\::EXPORT_OK"});
    }
    my $heavy;
    # Try very hard not to use {} and hence have to  enter scope on the foreach
    # We bomb out of the loop with last as soon as heavy is set.
    if ($args or $fail) {
      ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
                 or $fail and @$fail and $_ eq $fail->[0])) and last
                   foreach (@_);
    } else {
      ($heavy = /\W/) and last
        foreach (@_);
    }
    return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    local $SIG{__WARN__} = 
  	sub {require Carp; &Carp::carp} if not $SIG{__WARN__};
    # shortcut for the common case of no type character
    *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  }
  
  # Default methods
  
  sub export_fail {
      my $self = shift;
      @_;
  }
  
  # Unfortunately, caller(1)[3] "does not work" if the caller is aliased as
  # *name = \&foo.  Thus the need to create a lot of identical subroutines
  # Otherwise we could have aliased them to export().
  
  sub export_to_level {
    goto &{as_heavy()};
  }
  
  sub export_tags {
    goto &{as_heavy()};
  }
  
  sub export_ok_tags {
    goto &{as_heavy()};
  }
  
  sub require_version {
    goto &{as_heavy()};
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Exporter - Implements default import method for modules
  
  =head1 SYNOPSIS
  
  In module F<YourModule.pm>:
  
    package YourModule;
    use Exporter 'import';
    our @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
  
  or
  
    package YourModule;
    require Exporter;
    our @ISA = qw(Exporter);  # inherit all of Exporter's methods
    our @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
  
  or
  
    package YourModule;
    use parent 'Exporter';  # inherit all of Exporter's methods
    our @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
  
  In other files which wish to use C<YourModule>:
  
    use YourModule qw(frobnicate);      # import listed symbols
    frobnicate ($left, $right)          # calls YourModule::frobnicate
  
  Take a look at L</Good Practices> for some variants
  you will like to use in modern Perl code.
  
  =head1 DESCRIPTION
  
  The Exporter module implements an C<import> method which allows a module
  to export functions and variables to its users' namespaces.  Many modules
  use Exporter rather than implementing their own C<import> method because
  Exporter provides a highly flexible interface, with an implementation optimised
  for the common case.
  
  Perl automatically calls the C<import> method when processing a
  C<use> statement for a module.  Modules and C<use> are documented
  in L<perlfunc> and L<perlmod>.  Understanding the concept of
  modules and how the C<use> statement operates is important to
  understanding the Exporter.
  
  =head2 How to Export
  
  The arrays C<@EXPORT> and C<@EXPORT_OK> in a module hold lists of
  symbols that are going to be exported into the users name space by
  default, or which they can request to be exported, respectively.  The
  symbols can represent functions, scalars, arrays, hashes, or typeglobs.
  The symbols must be given by full name with the exception that the
  ampersand in front of a function is optional, e.g.
  
    our @EXPORT    = qw(afunc $scalar @array);   # afunc is a function
    our @EXPORT_OK = qw(&bfunc %hash *typeglob); # explicit prefix on &bfunc
  
  If you are only exporting function names it is recommended to omit the
  ampersand, as the implementation is faster this way.
  
  =head2 Selecting What to Export
  
  Do B<not> export method names!
  
  Do B<not> export anything else by default without a good reason!
  
  Exports pollute the namespace of the module user.  If you must export
  try to use C<@EXPORT_OK> in preference to C<@EXPORT> and avoid short or
  common symbol names to reduce the risk of name clashes.
  
  Generally anything not exported is still accessible from outside the
  module using the C<YourModule::item_name> (or C<< $blessed_ref->method >>)
  syntax.  By convention you can use a leading underscore on names to
  informally indicate that they are 'internal' and not for public use.
  
  (It is actually possible to get private functions by saying:
  
    my $subref = sub { ... };
    $subref->(@args);            # Call it as a function
    $obj->$subref(@args);        # Use it as a method
  
  However if you use them for methods it is up to you to figure out
  how to make inheritance work.)
  
  As a general rule, if the module is trying to be object oriented
  then export nothing.  If it's just a collection of functions then
  C<@EXPORT_OK> anything but use C<@EXPORT> with caution.  For function and
  method names use barewords in preference to names prefixed with
  ampersands for the export lists.
  
  Other module design guidelines can be found in L<perlmod>.
  
  =head2 How to Import
  
  In other files which wish to use your module there are three basic ways for
  them to load your module and import its symbols:
  
  =over 4
  
  =item C<use YourModule;>
  
  This imports all the symbols from YourModule's C<@EXPORT> into the namespace
  of the C<use> statement.
  
  =item C<use YourModule ();>
  
  This causes perl to load your module but does not import any symbols.
  
  =item C<use YourModule qw(...);>
  
  This imports only the symbols listed by the caller into their namespace.
  All listed symbols must be in your C<@EXPORT> or C<@EXPORT_OK>, else an error
  occurs.  The advanced export features of Exporter are accessed like this,
  but with list entries that are syntactically distinct from symbol names.
  
  =back
  
  Unless you want to use its advanced features, this is probably all you
  need to know to use Exporter.
  
  =head1 Advanced Features
  
  =head2 Specialised Import Lists
  
  If any of the entries in an import list begins with !, : or / then
  the list is treated as a series of specifications which either add to
  or delete from the list of names to import.  They are processed left to
  right. Specifications are in the form:
  
      [!]name         This name only
      [!]:DEFAULT     All names in @EXPORT
      [!]:tag         All names in $EXPORT_TAGS{tag} anonymous array
      [!]/pattern/    All names in @EXPORT and @EXPORT_OK which match
  
  A leading ! indicates that matching names should be deleted from the
  list of names to import.  If the first specification is a deletion it
  is treated as though preceded by :DEFAULT.  If you just want to import
  extra names in addition to the default set you will still need to
  include :DEFAULT explicitly.
  
  e.g., F<Module.pm> defines:
  
      our @EXPORT      = qw(A1 A2 A3 A4 A5);
      our @EXPORT_OK   = qw(B1 B2 B3 B4 B5);
      our %EXPORT_TAGS = (T1 => [qw(A1 A2 B1 B2)], T2 => [qw(A1 A2 B3 B4)]);
  
  Note that you cannot use tags in @EXPORT or @EXPORT_OK.
  
  Names in EXPORT_TAGS must also appear in @EXPORT or @EXPORT_OK.
  
  An application using Module can say something like:
  
      use Module qw(:DEFAULT :T2 !B3 A3);
  
  Other examples include:
  
      use Socket qw(!/^[AP]F_/ !SOMAXCONN !SOL_SOCKET);
      use POSIX  qw(:errno_h :termios_h !TCSADRAIN !/^EXIT/);
  
  Remember that most patterns (using //) will need to be anchored
  with a leading ^, e.g., C</^EXIT/> rather than C</EXIT/>.
  
  You can say C<BEGIN { $Exporter::Verbose=1 }> to see how the
  specifications are being processed and what is actually being imported
  into modules.
  
  =head2 Exporting Without Using Exporter's import Method
  
  Exporter has a special method, 'export_to_level' which is used in situations
  where you can't directly call Exporter's
  import method.  The export_to_level
  method looks like:
  
      MyPackage->export_to_level(
  	$where_to_export, $package, @what_to_export
      );
  
  where C<$where_to_export> is an integer telling how far up the calling stack
  to export your symbols, and C<@what_to_export> is an array telling what
  symbols *to* export (usually this is C<@_>).  The C<$package> argument is
  currently unused.
  
  For example, suppose that you have a module, A, which already has an
  import function:
  
      package A;
  
      our @ISA = qw(Exporter);
      our @EXPORT_OK = qw($b);
  
      sub import
      {
  	$A::b = 1;     # not a very useful import method
      }
  
  and you want to Export symbol C<$A::b> back to the module that called 
  package A.  Since Exporter relies on the import method to work, via 
  inheritance, as it stands Exporter::import() will never get called. 
  Instead, say the following:
  
      package A;
      our @ISA = qw(Exporter);
      our @EXPORT_OK = qw($b);
  
      sub import
      {
  	$A::b = 1;
  	A->export_to_level(1, @_);
      }
  
  This will export the symbols one level 'above' the current package - ie: to 
  the program or module that used package A. 
  
  Note: Be careful not to modify C<@_> at all before you call export_to_level
  - or people using your package will get very unexplained results!
  
  =head2 Exporting Without Inheriting from Exporter
  
  By including Exporter in your C<@ISA> you inherit an Exporter's import() method
  but you also inherit several other helper methods which you probably don't
  want and complicate the inheritance tree.  To avoid this you can do:
  
    package YourModule;
    use Exporter qw(import);
  
  which will export Exporter's own import() method into YourModule.
  Everything will work as before but you won't need to include Exporter in
  C<@YourModule::ISA>.
  
  Note: This feature was introduced in version 5.57
  of Exporter, released with perl 5.8.3.
  
  =head2 Module Version Checking
  
  The Exporter module will convert an attempt to import a number from a
  module into a call to C<< $module_name->VERSION($value) >>.  This can
  be used to validate that the version of the module being used is
  greater than or equal to the required version.
  
  For historical reasons, Exporter supplies a C<require_version> method that
  simply delegates to C<VERSION>.  Originally, before C<UNIVERSAL::VERSION>
  existed, Exporter would call C<require_version>.
  
  Since the C<UNIVERSAL::VERSION> method treats the C<$VERSION> number as
  a simple numeric value it will regard version 1.10 as lower than
  1.9.  For this reason it is strongly recommended that you use numbers
  with at least two decimal places, e.g., 1.09.
  
  =head2 Managing Unknown Symbols
  
  In some situations you may want to prevent certain symbols from being
  exported.  Typically this applies to extensions which have functions
  or constants that may not exist on some systems.
  
  The names of any symbols that cannot be exported should be listed
  in the C<@EXPORT_FAIL> array.
  
  If a module attempts to import any of these symbols the Exporter
  will give the module an opportunity to handle the situation before
  generating an error.  The Exporter will call an export_fail method
  with a list of the failed symbols:
  
    @failed_symbols = $module_name->export_fail(@failed_symbols);
  
  If the C<export_fail> method returns an empty list then no error is
  recorded and all the requested symbols are exported.  If the returned
  list is not empty then an error is generated for each symbol and the
  export fails.  The Exporter provides a default C<export_fail> method which
  simply returns the list unchanged.
  
  Uses for the C<export_fail> method include giving better error messages
  for some symbols and performing lazy architectural checks (put more
  symbols into C<@EXPORT_FAIL> by default and then take them out if someone
  actually tries to use them and an expensive check shows that they are
  usable on that platform).
  
  =head2 Tag Handling Utility Functions
  
  Since the symbols listed within C<%EXPORT_TAGS> must also appear in either
  C<@EXPORT> or C<@EXPORT_OK>, two utility functions are provided which allow
  you to easily add tagged sets of symbols to C<@EXPORT> or C<@EXPORT_OK>:
  
    our %EXPORT_TAGS = (foo => [qw(aa bb cc)], bar => [qw(aa cc dd)]);
  
    Exporter::export_tags('foo');     # add aa, bb and cc to @EXPORT
    Exporter::export_ok_tags('bar');  # add aa, cc and dd to @EXPORT_OK
  
  Any names which are not tags are added to C<@EXPORT> or C<@EXPORT_OK>
  unchanged but will trigger a warning (with C<-w>) to avoid misspelt tags
  names being silently added to C<@EXPORT> or C<@EXPORT_OK>.  Future versions
  may make this a fatal error.
  
  =head2 Generating Combined Tags
  
  If several symbol categories exist in C<%EXPORT_TAGS>, it's usually
  useful to create the utility ":all" to simplify "use" statements.
  
  The simplest way to do this is:
  
   our  %EXPORT_TAGS = (foo => [qw(aa bb cc)], bar => [qw(aa cc dd)]);
  
    # add all the other ":class" tags to the ":all" class,
    # deleting duplicates
    {
      my %seen;
  
      push @{$EXPORT_TAGS{all}},
        grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}} foreach keys %EXPORT_TAGS;
    }
  
  F<CGI.pm> creates an ":all" tag which contains some (but not really
  all) of its categories.  That could be done with one small
  change:
  
    # add some of the other ":class" tags to the ":all" class,
    # deleting duplicates
    {
      my %seen;
  
      push @{$EXPORT_TAGS{all}},
        grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}}
          foreach qw/html2 html3 netscape form cgi internal/;
    }
  
  Note that the tag names in C<%EXPORT_TAGS> don't have the leading ':'.
  
  =head2 C<AUTOLOAD>ed Constants
  
  Many modules make use of C<AUTOLOAD>ing for constant subroutines to
  avoid having to compile and waste memory on rarely used values (see
  L<perlsub> for details on constant subroutines).  Calls to such
  constant subroutines are not optimized away at compile time because
  they can't be checked at compile time for constancy.
  
  Even if a prototype is available at compile time, the body of the
  subroutine is not (it hasn't been C<AUTOLOAD>ed yet).  perl needs to
  examine both the C<()> prototype and the body of a subroutine at
  compile time to detect that it can safely replace calls to that
  subroutine with the constant value.
  
  A workaround for this is to call the constants once in a C<BEGIN> block:
  
     package My ;
  
     use Socket ;
  
     foo( SO_LINGER );  ## SO_LINGER NOT optimized away; called at runtime
     BEGIN { SO_LINGER }
     foo( SO_LINGER );  ## SO_LINGER optimized away at compile time.
  
  This forces the C<AUTOLOAD> for C<SO_LINGER> to take place before
  SO_LINGER is encountered later in C<My> package.
  
  If you are writing a package that C<AUTOLOAD>s, consider forcing
  an C<AUTOLOAD> for any constants explicitly imported by other packages
  or which are usually used when your package is C<use>d.
  
  =head1 Good Practices
  
  =head2 Declaring C<@EXPORT_OK> and Friends
  
  When using C<Exporter> with the standard C<strict> and C<warnings>
  pragmas, the C<our> keyword is needed to declare the package
  variables C<@EXPORT_OK>, C<@EXPORT>, C<@ISA>, etc.
  
    our @ISA = qw(Exporter);
    our @EXPORT_OK = qw(munge frobnicate);
  
  If backward compatibility for Perls B<under> 5.6 is important,
  one must write instead a C<use vars> statement.
  
    use vars qw(@ISA @EXPORT_OK);
    @ISA = qw(Exporter);
    @EXPORT_OK = qw(munge frobnicate);
  
  =head2 Playing Safe
  
  There are some caveats with the use of runtime statements
  like C<require Exporter> and the assignment to package
  variables, which can be very subtle for the unaware programmer.
  This may happen for instance with mutually recursive
  modules, which are affected by the time the relevant
  constructions are executed.
  
  The ideal way to never have to think about that is to use
  C<BEGIN> blocks and the simple import method.  So the first part
  of the L</SYNOPSIS> code could be rewritten as:
  
    package YourModule;
  
    use strict;
    use warnings;
  
    use Exporter 'import';
    BEGIN {
      our @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
    }
  
  Or if you need to inherit from Exporter:
  
    package YourModule;
  
    use strict;
    use warnings;
  
    BEGIN {
      require Exporter;
      our @ISA = qw(Exporter);  # inherit all of Exporter's methods
      our @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
    }
  
  The C<BEGIN> will assure that the loading of F<Exporter.pm>
  and the assignments to C<@ISA> and C<@EXPORT_OK> happen
  immediately like C<use>, leaving no room for something to get awry
  or just plain wrong.
  
  With respect to loading C<Exporter> and inheriting, there
  are alternatives with the use of modules like C<base> and C<parent>.
  
    use base qw(Exporter);
    # or
    use parent qw(Exporter);
  
  Any of these statements are nice replacements for
  C<BEGIN { require Exporter; our @ISA = qw(Exporter); }>
  with the same compile-time effect.  The basic difference
  is that C<base> code interacts with declared C<fields>
  while C<parent> is a streamlined version of the older
  C<base> code to just establish the IS-A relationship.
  
  For more details, see the documentation and code of
  L<base> and L<parent>.
  
  Another thorough remedy to that runtime
  vs. compile-time trap is to use L<Exporter::Easy>,
  which is a wrapper of Exporter that allows all
  boilerplate code at a single gulp in the
  use statement.
  
     use Exporter::Easy (
         OK => [ qw(munge frobnicate) ],
     );
     # @ISA setup is automatic
     # all assignments happen at compile time
  
  =head2 What Not to Export
  
  You have been warned already in L</Selecting What to Export>
  to not export:
  
  =over 4
  
  =item *
  
  method names (because you don't need to
  and that's likely to not do what you want),
  
  =item *
  
  anything by default (because you don't want to surprise your users...
  badly)
  
  =item *
  
  anything you don't need to (because less is more)
  
  =back
  
  There's one more item to add to this list.  Do B<not>
  export variable names.  Just because C<Exporter> lets you
  do that, it does not mean you should.
  
    @EXPORT_OK = qw($svar @avar %hvar); # DON'T!
  
  Exporting variables is not a good idea.  They can
  change under the hood, provoking horrible
  effects at-a-distance that are too hard to track
  and to fix.  Trust me: they are not worth it.
  
  To provide the capability to set/get class-wide
  settings, it is best instead to provide accessors
  as subroutines or class methods instead.
  
  =head1 SEE ALSO
  
  C<Exporter> is definitely not the only module with
  symbol exporter capabilities.  At CPAN, you may find
  a bunch of them.  Some are lighter.  Some
  provide improved APIs and features.  Pick the one
  that fits your needs.  The following is
  a sample list of such modules.
  
      Exporter::Easy
      Exporter::Lite
      Exporter::Renaming
      Exporter::Tidy
      Sub::Exporter / Sub::Installer
      Perl6::Export / Perl6::Export::Attrs
  
  =head1 LICENSE
  
  This library is free software.  You can redistribute it
  and/or modify it under the same terms as Perl itself.
  
  =cut
  
  
  
EXPORTER

    $fatpacked{"Exporter/Heavy.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'EXPORTER_HEAVY';
  package Exporter::Heavy;
  
  use strict;
  no strict 'refs';
  
  # On one line so MakeMaker will see it.
  our $VERSION = '5.77';
  
  =head1 NAME
  
  Exporter::Heavy - Exporter guts
  
  =head1 SYNOPSIS
  
  (internal use only)
  
  =head1 DESCRIPTION
  
  No user-serviceable parts inside.
  
  =cut
  
  #
  # We go to a lot of trouble not to 'require Carp' at file scope,
  #  because Carp requires Exporter, and something has to give.
  #
  
  sub _rebuild_cache {
      my ($pkg, $exports, $cache) = @_;
      s/^&// foreach @$exports;
      @{$cache}{@$exports} = (1) x @$exports;
      my $ok = \@{"${pkg}::EXPORT_OK"};
      if (@$ok) {
  	s/^&// foreach @$ok;
  	@{$cache}{@$ok} = (1) x @$ok;
      }
  }
  
  sub heavy_export {
  
      # Save the old __WARN__ handler in case it was defined
      my $oldwarn = $SIG{__WARN__};
  
      # First make import warnings look like they're coming from the "use".
      local $SIG{__WARN__} = sub {
  	# restore it back so proper stacking occurs
  	local $SIG{__WARN__} = $oldwarn;
  	my $text = shift;
  	if ($text =~ s/ at \S*Exporter\S*.pm line \d+.*\n//) {
  	    require Carp;
  	    local $Carp::CarpLevel = 1;	# ignore package calling us too.
  	    Carp::carp($text);
  	}
  	else {
  	    warn $text;
  	}
      };
      local $SIG{__DIE__} = sub {
  	require Carp;
  	local $Carp::CarpLevel = 1;	# ignore package calling us too.
  	Carp::croak("$_[0]Illegal null symbol in \@${1}::EXPORT")
  	    if $_[0] =~ /^Unable to create sub named "(.*?)::"/;
      };
  
      my($pkg, $callpkg, @imports) = @_;
      my($type, $sym, $cache_is_current, $oops);
      my($exports, $export_cache) = (\@{"${pkg}::EXPORT"},
                                     $Exporter::Cache{$pkg} ||= {});
  
      if (@imports) {
  	if (!%$export_cache) {
  	    _rebuild_cache ($pkg, $exports, $export_cache);
  	    $cache_is_current = 1;
  	}
  
  	if (grep m{^[/!:]}, @imports) {
  	    my $tagsref = \%{"${pkg}::EXPORT_TAGS"};
  	    my $tagdata;
  	    my %imports;
  	    my($remove, $spec, @names, @allexports);
  	    # negated first item implies starting with default set:
  	    unshift @imports, ':DEFAULT' if $imports[0] =~ m/^!/;
  	    foreach $spec (@imports){
  		$remove = $spec =~ s/^!//;
  
  		if ($spec =~ s/^://){
  		    if ($spec eq 'DEFAULT'){
  			@names = @$exports;
  		    }
  		    elsif ($tagdata = $tagsref->{$spec}) {
  			@names = @$tagdata;
  		    }
  		    else {
  			warn qq["$spec" is not defined in %${pkg}::EXPORT_TAGS];
  			++$oops;
  			next;
  		    }
  		}
  		elsif ($spec =~ m:^/(.*)/$:){
  		    my $patn = $1;
  		    @allexports = keys %$export_cache unless @allexports; # only do keys once
  		    @names = grep(/$patn/, @allexports); # not anchored by default
  		}
  		else {
  		    @names = ($spec); # is a normal symbol name
  		}
  
  		warn "Import ".($remove ? "del":"add").": @names "
  		    if $Exporter::Verbose;
  
  		if ($remove) {
  		   foreach $sym (@names) { delete $imports{$sym} } 
  		}
  		else {
  		    @imports{@names} = (1) x @names;
  		}
  	    }
  	    @imports = keys %imports;
  	}
  
          my @carp;
  	foreach $sym (@imports) {
  	    if (!$export_cache->{$sym}) {
  		if ($sym =~ m/^\d/) {
  		    $pkg->VERSION($sym); # inherit from UNIVERSAL
  		    # If the version number was the only thing specified
  		    # then we should act as if nothing was specified:
  		    if (@imports == 1) {
  			@imports = @$exports;
  			last;
  		    }
  		    # We need a way to emulate 'use Foo ()' but still
  		    # allow an easy version check: "use Foo 1.23, ''";
  		    if (@imports == 2 and !$imports[1]) {
  			@imports = ();
  			last;
  		    }
  		} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {
  		    # Last chance - see if they've updated EXPORT_OK since we
  		    # cached it.
  
  		    unless ($cache_is_current) {
  			%$export_cache = ();
  			_rebuild_cache ($pkg, $exports, $export_cache);
  			$cache_is_current = 1;
  		    }
  
  		    if (!$export_cache->{$sym}) {
  			# accumulate the non-exports
  			push @carp,
  			  qq["$sym" is not exported by the $pkg module];
  			$oops++;
  		    }
  		}
  	    }
  	}
  	if ($oops) {
  	    require Carp;
  	    Carp::croak(join("\n", @carp, "Can't continue after import errors"));
  	}
      }
      else {
  	@imports = @$exports;
      }
  
      my($fail, $fail_cache) = (\@{"${pkg}::EXPORT_FAIL"},
                                $Exporter::FailCache{$pkg} ||= {});
  
      if (@$fail) {
  	if (!%$fail_cache) {
  	    # Build cache of symbols. Optimise the lookup by adding
  	    # barewords twice... both with and without a leading &.
  	    # (Technique could be applied to $export_cache at cost of memory)
  	    my @expanded = map { /^\w/ ? ($_, '&'.$_) : $_ } @$fail;
  	    warn "${pkg}::EXPORT_FAIL cached: @expanded" if $Exporter::Verbose;
  	    @{$fail_cache}{@expanded} = (1) x @expanded;
  	}
  	my @failed;
  	foreach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }
  	if (@failed) {
  	    @failed = $pkg->export_fail(@failed);
  	    foreach $sym (@failed) {
                  require Carp;
  		Carp::carp(qq["$sym" is not implemented by the $pkg module ],
  			"on this architecture");
  	    }
  	    if (@failed) {
  		require Carp;
  		Carp::croak("Can't continue after import errors");
  	    }
  	}
      }
  
      warn "Importing into $callpkg from $pkg: ",
  		join(", ",sort @imports) if $Exporter::Verbose;
  
      foreach $sym (@imports) {
  	# shortcut for the common case of no type character
  	(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
  	    unless $sym =~ s/^(\W)//;
  	$type = $1;
  	no warnings 'once';
  	*{"${callpkg}::$sym"} =
  	    $type eq '&' ? \&{"${pkg}::$sym"} :
  	    $type eq '$' ? \${"${pkg}::$sym"} :
  	    $type eq '@' ? \@{"${pkg}::$sym"} :
  	    $type eq '%' ? \%{"${pkg}::$sym"} :
  	    $type eq '*' ?  *{"${pkg}::$sym"} :
  	    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
      }
  }
  
  sub heavy_export_to_level
  {
        my $pkg = shift;
        my $level = shift;
        (undef) = shift;			# XXX redundant arg
        my $callpkg = caller($level);
        $pkg->export($callpkg, @_);
  }
  
  # Utility functions
  
  sub _push_tags {
      my($pkg, $var, $syms) = @_;
      my @nontag = ();
      my $export_tags = \%{"${pkg}::EXPORT_TAGS"};
      push(@{"${pkg}::$var"},
  	map { $export_tags->{$_} ? @{$export_tags->{$_}} 
                                   : scalar(push(@nontag,$_),$_) }
  		(@$syms) ? @$syms : keys %$export_tags);
      if (@nontag and $^W) {
  	# This may change to a die one day
  	require Carp;
  	Carp::carp(join(", ", @nontag)." are not tags of $pkg");
      }
  }
  
  sub heavy_require_version {
      my($self, $wanted) = @_;
      my $pkg = ref $self || $self;
      return ${pkg}->VERSION($wanted);
  }
  
  sub heavy_export_tags {
    _push_tags((caller)[0], "EXPORT",    \@_);
  }
  
  sub heavy_export_ok_tags {
    _push_tags((caller)[0], "EXPORT_OK", \@_);
  }
  
  1;
EXPORTER_HEAVY

    $fatpacked{"HTTP/Config.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'HTTP_CONFIG';
  package HTTP::Config;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.44';
  
  use URI;
  
  sub new {
      my $class = shift;
      return bless [], $class;
  }
  
  sub entries {
      my $self = shift;
      @$self;
  }
  
  sub empty {
      my $self = shift;
      not @$self;
  }
  
  sub add {
      if (@_ == 2) {
          my $self = shift;
          push(@$self, shift);
          return;
      }
      my($self, %spec) = @_;
      push(@$self, \%spec);
      return;
  }
  
  sub find2 {
      my($self, %spec) = @_;
      my @found;
      my @rest;
   ITEM:
      for my $item (@$self) {
          for my $k (keys %spec) {
              no warnings 'uninitialized';
              if (!exists $item->{$k} || $spec{$k} ne $item->{$k}) {
                  push(@rest, $item);
                  next ITEM;
              }
          }
          push(@found, $item);
      }
      return \@found unless wantarray;
      return \@found, \@rest;
  }
  
  sub find {
      my $self = shift;
      my $f = $self->find2(@_);
      return @$f if wantarray;
      return $f->[0];
  }
  
  sub remove {
      my($self, %spec) = @_;
      my($removed, $rest) = $self->find2(%spec);
      @$self = @$rest if @$removed;
      return @$removed;
  }
  
  my %MATCH = (
      m_scheme => sub {
          my($v, $uri) = @_;
          return $uri->_scheme eq $v;  # URI known to be canonical
      },
      m_secure => sub {
          my($v, $uri) = @_;
          my $secure = $uri->can("secure") ? $uri->secure : $uri->_scheme eq "https";
          return $secure == !!$v;
      },
      m_host_port => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host_port");
          return $uri->host_port eq $v, 7;
      },
      m_host => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host");
          return $uri->host eq $v, 6;
      },
      m_port => sub {
          my($v, $uri) = @_;
          return unless $uri->can("port");
          return $uri->port eq $v;
      },
      m_domain => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host");
          my $h = $uri->host;
          $h = "$h.local" unless $h =~ /\./;
          $v = ".$v" unless $v =~ /^\./;
          return length($v), 5 if substr($h, -length($v)) eq $v;
          return 0;
      },
      m_path => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          return $uri->path eq $v, 4;
      },
      m_path_prefix => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          my $path = $uri->path;
          my $len = length($v);
          return $len, 3 if $path eq $v;
          return 0 if length($path) <= $len;
          $v .= "/" unless $v =~ m,/\z,,;
          return $len, 3 if substr($path, 0, length($v)) eq $v;
          return 0;
      },
      m_path_match => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          return $uri->path =~ $v;
      },
      m_uri__ => sub {
          my($v, $k, $uri) = @_;
          return unless $uri->can($k);
          return 1 unless defined $v;
          return $uri->$k eq $v;
      },
      m_method => sub {
          my($v, $uri, $request) = @_;
          return $request && $request->method eq $v;
      },
      m_proxy => sub {
          my($v, $uri, $request) = @_;
          return $request && ($request->{proxy} || "") eq $v;
      },
      m_code => sub {
          my($v, $uri, $request, $response) = @_;
          $v =~ s/xx\z//;
          return unless $response;
          return length($v), 2 if substr($response->code, 0, length($v)) eq $v;
      },
      m_media_type => sub {  # for request too??
          my($v, $uri, $request, $response) = @_;
          return unless $response;
          return 1, 1 if $v eq "*/*";
          my $ct = $response->content_type;
          return 2, 1 if $v =~ s,/\*\z,, && $ct =~ m,^\Q$v\E/,;
          return 3, 1 if $v eq "html" && $response->content_is_html;
          return 4, 1 if $v eq "xhtml" && $response->content_is_xhtml;
          return 10, 1 if $v eq $ct;
          return 0;
      },
      m_header__ => sub {
          my($v, $k, $uri, $request, $response) = @_;
          return unless $request;
          my $req_header = $request->header($k);
          return 1 if defined($req_header) && $req_header eq $v;
          if ($response) {
              my $res_header = $response->header($k);
              return 1 if defined($res_header) && $res_header eq $v;
          }
          return 0;
      },
      m_response_attr__ => sub {
          my($v, $k, $uri, $request, $response) = @_;
          return unless $response;
          return 1 if !defined($v) && exists $response->{$k};
          return 0 unless exists $response->{$k};
          return 1 if $response->{$k} eq $v;
          return 0;
      },
  );
  
  sub matching {
      my $self = shift;
      if (@_ == 1) {
          if ($_[0]->can("request")) {
              unshift(@_, $_[0]->request);
              unshift(@_, undef) unless defined $_[0];
          }
          unshift(@_, $_[0]->uri_canonical) if $_[0] && $_[0]->can("uri_canonical");
      }
      my($uri, $request, $response) = @_;
      $uri = URI->new($uri) unless ref($uri);
  
      my @m;
   ITEM:
      for my $item (@$self) {
          my $order;
          for my $ikey (keys %$item) {
              my $mkey = $ikey;
              my $k;
              $k = $1 if $mkey =~ s/__(.*)/__/;
              if (my $m = $MATCH{$mkey}) {
                  #print "$ikey $mkey\n";
                  my($c, $o);
                  my @arg = (
                      defined($k) ? $k : (),
                      $uri, $request, $response
                  );
                  my $v = $item->{$ikey};
                  $v = [$v] unless ref($v) eq "ARRAY";
                  for (@$v) {
                      ($c, $o) = $m->($_, @arg);
                      #print "  - $_ ==> $c $o\n";
                      last if $c;
                  }
                  next ITEM unless $c;
                  $order->[$o || 0] += $c;
              }
          }
          $order->[7] ||= 0;
          $item->{_order} = join(".", reverse map sprintf("%03d", $_ || 0), @$order);
          push(@m, $item);
      }
      @m = sort { $b->{_order} cmp $a->{_order} } @m;
      delete $_->{_order} for @m;
      return @m if wantarray;
      return $m[0];
  }
  
  sub add_item {
      my $self = shift;
      my $item = shift;
      return $self->add(item => $item, @_);
  }
  
  sub remove_items {
      my $self = shift;
      return map $_->{item}, $self->remove(@_);
  }
  
  sub matching_items {
      my $self = shift;
      return map $_->{item}, $self->matching(@_);
  }
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Config - Configuration for request and response objects
  
  =head1 VERSION
  
  version 6.44
  
  =head1 SYNOPSIS
  
   use HTTP::Config;
   my $c = HTTP::Config->new;
   $c->add(m_domain => ".example.com", m_scheme => "http", verbose => 1);
   
   use HTTP::Request;
   my $request = HTTP::Request->new(GET => "http://www.example.com");
   
   if (my @m = $c->matching($request)) {
      print "Yadayada\n" if $m[0]->{verbose};
   }
  
  =head1 DESCRIPTION
  
  An C<HTTP::Config> object is a list of entries that
  can be matched against request or request/response pairs.  Its
  purpose is to hold configuration data that can be looked up given a
  request or response object.
  
  Each configuration entry is a hash.  Some keys specify matching to
  occur against attributes of request/response objects.  Other keys can
  be used to hold user data.
  
  The following methods are provided:
  
  =over 4
  
  =item $conf = HTTP::Config->new
  
  Constructs a new empty C<HTTP::Config> object and returns it.
  
  =item $conf->entries
  
  Returns the list of entries in the configuration object.
  In scalar context returns the number of entries.
  
  =item $conf->empty
  
  Return true if there are no entries in the configuration object.
  This is just a shorthand for C<< not $conf->entries >>.
  
  =item $conf->add( %matchspec, %other )
  
  =item $conf->add( \%entry )
  
  Adds a new entry to the configuration.
  You can either pass separate key/value pairs or a hash reference.
  
  =item $conf->remove( %spec )
  
  Removes (and returns) the entries that have matches for all the key/value pairs in %spec.
  If %spec is empty this will match all entries; so it will empty the configuration object.
  
  =item $conf->matching( $uri, $request, $response )
  
  =item $conf->matching( $uri )
  
  =item $conf->matching( $request )
  
  =item $conf->matching( $response )
  
  Returns the entries that match the given $uri, $request and $response triplet.
  
  If called with a single $request object then the $uri is obtained by calling its 'uri_canonical' method.
  If called with a single $response object, then the request object is obtained by calling its 'request' method;
  and then the $uri is obtained as if a single $request was provided.
  
  The entries are returned with the most specific matches first.
  In scalar context returns the most specific match or C<undef> in none match.
  
  =item $conf->add_item( $item, %matchspec )
  
  =item $conf->remove_items( %spec )
  
  =item $conf->matching_items( $uri, $request, $response )
  
  Wrappers that hides the entries themselves.
  
  =back
  
  =head2 Matching
  
  The following keys on a configuration entry specify matching.  For all
  of these you can provide an array of values instead of a single value.
  The entry matches if at least one of the values in the array matches.
  
  Entries that require match against a response object attribute will never match
  unless a response object was provided.
  
  =over
  
  =item m_scheme => $scheme
  
  Matches if the URI uses the specified scheme; e.g. "http".
  
  =item m_secure => $bool
  
  If $bool is TRUE; matches if the URI uses a secure scheme.  If $bool
  is FALSE; matches if the URI does not use a secure scheme.  An example
  of a secure scheme is "https".
  
  =item m_host_port => "$hostname:$port"
  
  Matches if the URI's host_port method return the specified value.
  
  =item m_host => $hostname
  
  Matches if the URI's host method returns the specified value.
  
  =item m_port => $port
  
  Matches if the URI's port method returns the specified value.
  
  =item m_domain => ".$domain"
  
  Matches if the URI's host method return a value that within the given
  domain.  The hostname "www.example.com" will for instance match the
  domain ".com".
  
  =item m_path => $path
  
  Matches if the URI's path method returns the specified value.
  
  =item m_path_prefix => $path
  
  Matches if the URI's path is the specified path or has the specified
  path as prefix.
  
  =item m_path_match => $Regexp
  
  Matches if the regular expression matches the URI's path.  Eg. qr/\.html$/.
  
  =item m_method => $method
  
  Matches if the request method matches the specified value. Eg. "GET" or "POST".
  
  =item m_code => $digit
  
  =item m_code => $status_code
  
  Matches if the response status code matches.  If a single digit is
  specified; matches for all response status codes beginning with that digit.
  
  =item m_proxy => $url
  
  Matches if the request is to be sent to the given Proxy server.
  
  =item m_media_type => "*/*"
  
  =item m_media_type => "text/*"
  
  =item m_media_type => "html"
  
  =item m_media_type => "xhtml"
  
  =item m_media_type => "text/html"
  
  Matches if the response media type matches.
  
  With a value of "html" matches if $response->content_is_html returns TRUE.
  With a value of "xhtml" matches if $response->content_is_xhtml returns TRUE.
  
  =item m_uri__I<$method> => undef
  
  Matches if the URI object provides the method.
  
  =item m_uri__I<$method> => $string
  
  Matches if the URI's $method method returns the given value.
  
  =item m_header__I<$field> => $string
  
  Matches if either the request or the response have a header $field with the given value.
  
  =item m_response_attr__I<$key> => undef
  
  =item m_response_attr__I<$key> => $string
  
  Matches if the response object has that key, or the entry has the given value.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<HTTP::Request>, L<HTTP::Response>
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  #ABSTRACT: Configuration for request and response objects
  
HTTP_CONFIG

    $fatpacked{"HTTP/Date.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'HTTP_DATE';
  package HTTP::Date;
  
  use strict;
  
  our $VERSION = '6.05';
  
  require Exporter;
  our @ISA       = qw(Exporter);
  our @EXPORT    = qw(time2str str2time);
  our @EXPORT_OK = qw(parse_date time2iso time2isoz);
  
  require Time::Local;
  
  our ( @DoW, @MoY, %MoY );
  @DoW       = qw(Sun Mon Tue Wed Thu Fri Sat);
  @MoY       = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
  @MoY{@MoY} = ( 1 .. 12 );
  
  my %GMT_ZONE = ( GMT => 1, UTC => 1, UT => 1, Z => 1 );
  
  sub time2str (;$) {
      my $time = shift;
      $time = time unless defined $time;
      my ( $sec, $min, $hour, $mday, $mon, $year, $wday ) = gmtime($time);
      sprintf(
          "%s, %02d %s %04d %02d:%02d:%02d GMT",
          $DoW[$wday],
          $mday, $MoY[$mon], $year + 1900,
          $hour, $min,       $sec
      );
  }
  
  sub str2time ($;$) {
      my $str = shift;
      return undef unless defined $str;
  
      # fast exit for strictly conforming string
      if ( $str
          =~ /^[SMTWF][a-z][a-z], (\d\d) ([JFMAJSOND][a-z][a-z]) (\d\d\d\d) (\d\d):(\d\d):(\d\d) GMT$/
      ) {
          return eval {
              my $t = Time::Local::timegm( $6, $5, $4, $1, $MoY{$2} - 1, $3 );
              $t < 0 ? undef : $t;
          };
      }
  
      my @d = parse_date($str);
      return undef unless @d;
      $d[1]--;    # month
  
      my $tz = pop(@d);
      unless ( defined $tz ) {
          unless ( defined( $tz = shift ) ) {
              return eval {
                  my $frac = $d[-1];
                  $frac -= ( $d[-1] = int($frac) );
                  my $t = Time::Local::timelocal( reverse @d ) + $frac;
                  $t < 0 ? undef : $t;
              };
          }
      }
  
      my $offset = 0;
      if ( $GMT_ZONE{ uc $tz } ) {
  
          # offset already zero
      }
      elsif ( $tz =~ /^([-+])?(\d\d?):?(\d\d)?$/ ) {
          $offset = 3600 * $2;
          $offset += 60 * $3 if $3;
          $offset *= -1      if $1 && $1 eq '-';
      }
      else {
          eval { require Time::Zone } || return undef;
          $offset = Time::Zone::tz_offset($tz);
          return undef unless defined $offset;
      }
  
      return eval {
          my $frac = $d[-1];
          $frac -= ( $d[-1] = int($frac) );
          my $t = Time::Local::timegm( reverse @d ) + $frac;
          $t < 0 ? undef : $t - $offset;
      };
  }
  
  sub parse_date ($) {
      local ($_) = shift;
      return unless defined;
  
      # More lax parsing below
      s/^\s+//;                                            # kill leading space
      s/^(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)[a-z]*,?\s*//i;    # Useless weekday
  
      my ( $day, $mon, $yr, $hr, $min, $sec, $tz, $ampm );
  
      # Then we are able to check for most of the formats with this regexp
      (
          ( $day, $mon, $yr, $hr, $min, $sec, $tz )
          = /^
       (\d\d?)               # day
          (?:\s+|[-\/])
       (\w+)                 # month
          (?:\s+|[-\/])
       (\d+)                 # year
       (?:
             (?:\s+|:)       # separator before clock
          (\d\d?):(\d\d)     # hour:min
          (?::(\d\d))?       # optional seconds
       )?                    # optional clock
          \s*
       ([-+]?\d{2,4}|(?![APap][Mm]\b)[A-Za-z]+)? # timezone
          \s*
       (?:\(\w+\)|\w{3,})?   # ASCII representation of timezone.
          \s*$
      /x
          )
  
          ||
  
          # Try the ctime and asctime format
          (
          ( $mon, $day, $hr, $min, $sec, $tz, $yr )
          = /^
       (\w{1,3})             # month
          \s+
       (\d\d?)               # day
          \s+
       (\d\d?):(\d\d)        # hour:min
       (?::(\d\d))?          # optional seconds
          \s+
       (?:([A-Za-z]+)\s+)?   # optional timezone
       (\d+)                 # year
          \s*$               # allow trailing whitespace
      /x
          )
  
          ||
  
          # Then the Unix 'ls -l' date format
          (
          ( $mon, $day, $yr, $hr, $min, $sec )
          = /^
       (\w{3})               # month
          \s+
       (\d\d?)               # day
          \s+
       (?:
          (\d\d\d\d) |       # year
          (\d{1,2}):(\d{2})  # hour:min
              (?::(\d\d))?       # optional seconds
       )
       \s*$
         /x
          )
  
          ||
  
          # ISO 8601 format '1996-02-29 12:00:00 -0100' and variants
          (
          ( $yr, $mon, $day, $hr, $min, $sec, $tz )
          = /^
        (\d{4})              # year
           [-\/]?
        (\d\d?)              # numerical month
           [-\/]?
        (\d\d?)              # day
       (?:
             (?:\s+|[-:Tt])  # separator before clock
          (\d\d?):?(\d\d)    # hour:min
          (?::?(\d\d(?:\.\d*)?))?  # optional seconds (and fractional)
       )?                    # optional clock
          \s*
       ([-+]?\d\d?:?(:?\d\d)?
        |Z|z)?               # timezone  (Z is "zero meridian", i.e. GMT)
          \s*$
      /x
          )
  
          ||
  
          # Windows 'dir' 11-12-96  03:52PM
          (
          ( $mon, $day, $yr, $hr, $min, $ampm )
          = /^
            (\d{2})                # numerical month
               -
            (\d{2})                # day
               -
            (\d{2})                # year
               \s+
            (\d\d?):(\d\d)([APap][Mm])  # hour:min AM or PM
               \s*$
          /x
          )
  
          || return;    # unrecognized format
  
      # Translate month name to number
      $mon
          = $MoY{$mon}
          || $MoY{"\u\L$mon"}
          || ( $mon =~ /^\d\d?$/ && $mon >= 1 && $mon <= 12 && int($mon) )
          || return;
  
      # If the year is missing, we assume first date before the current,
      # because of the formats we support such dates are mostly present
      # on "ls -l" listings.
      unless ( defined $yr ) {
          my $cur_mon;
          ( $cur_mon, $yr ) = (localtime)[ 4, 5 ];
          $yr += 1900;
          $cur_mon++;
          $yr-- if $mon > $cur_mon;
      }
      elsif ( length($yr) < 3 ) {
  
          # Find "obvious" year
          my $cur_yr = (localtime)[5] + 1900;
          my $m      = $cur_yr % 100;
          my $tmp    = $yr;
          $yr += $cur_yr - $m;
          $m  -= $tmp;
          $yr += ( $m > 0 ) ? 100 : -100
              if abs($m) > 50;
      }
  
      # Make sure clock elements are defined
      $hr  = 0 unless defined($hr);
      $min = 0 unless defined($min);
      $sec = 0 unless defined($sec);
  
      # Compensate for AM/PM
      if ($ampm) {
          $ampm = uc $ampm;
          $hr   = 0 if $hr == 12 && $ampm eq 'AM';
          $hr += 12 if $ampm eq 'PM' && $hr != 12;
      }
  
      return ( $yr, $mon, $day, $hr, $min, $sec, $tz )
          if wantarray;
  
      if ( defined $tz ) {
          $tz = "Z" if $tz =~ /^(GMT|UTC?|[-+]?0+)$/;
      }
      else {
          $tz = "";
      }
      return sprintf(
          "%04d-%02d-%02d %02d:%02d:%02d%s",
          $yr, $mon, $day, $hr, $min, $sec, $tz
      );
  }
  
  sub time2iso (;$) {
      my $time = shift;
      $time = time unless defined $time;
      my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime($time);
      sprintf(
          "%04d-%02d-%02d %02d:%02d:%02d",
          $year + 1900, $mon + 1, $mday, $hour, $min, $sec
      );
  }
  
  sub time2isoz (;$) {
      my $time = shift;
      $time = time unless defined $time;
      my ( $sec, $min, $hour, $mday, $mon, $year ) = gmtime($time);
      sprintf(
          "%04d-%02d-%02d %02d:%02d:%02dZ",
          $year + 1900, $mon + 1, $mday, $hour, $min, $sec
      );
  }
  
  1;
  
  # ABSTRACT: HTTP::Date - date conversion routines
  #
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Date - HTTP::Date - date conversion routines
  
  =head1 VERSION
  
  version 6.05
  
  =head1 SYNOPSIS
  
   use HTTP::Date;
  
   $string = time2str($time);    # Format as GMT ASCII time
   $time = str2time($string);    # convert ASCII date to machine time
  
  =head1 DESCRIPTION
  
  This module provides functions that deal the date formats used by the
  HTTP protocol (and then some more).  Only the first two functions,
  time2str() and str2time(), are exported by default.
  
  =over 4
  
  =item time2str( [$time] )
  
  The time2str() function converts a machine time (seconds since epoch)
  to a string.  If the function is called without an argument or with an
  undefined argument, it will use the current time.
  
  The string returned is in the format preferred for the HTTP protocol.
  This is a fixed length subset of the format defined by RFC 1123,
  represented in Universal Time (GMT).  An example of a time stamp
  in this format is:
  
     Sun, 06 Nov 1994 08:49:37 GMT
  
  =item str2time( $str [, $zone] )
  
  The str2time() function converts a string to machine time.  It returns
  C<undef> if the format of $str is unrecognized, otherwise whatever the
  C<Time::Local> functions can make out of the parsed time.  Dates
  before the system's epoch may not work on all operating systems.  The
  time formats recognized are the same as for parse_date().
  
  The function also takes an optional second argument that specifies the
  default time zone to use when converting the date.  This parameter is
  ignored if the zone is found in the date string itself.  If this
  parameter is missing, and the date string format does not contain any
  zone specification, then the local time zone is assumed.
  
  If the zone is not "C<GMT>" or numerical (like "C<-0800>" or
  "C<+0100>"), then the C<Time::Zone> module must be installed in order
  to get the date recognized.
  
  =item parse_date( $str )
  
  This function will try to parse a date string, and then return it as a
  list of numerical values followed by a (possible undefined) time zone
  specifier; ($year, $month, $day, $hour, $min, $sec, $tz).  The $year
  will be the full 4-digit year, and $month numbers start with 1 (for January).
  
  In scalar context the numbers are interpolated in a string of the
  "YYYY-MM-DD hh:mm:ss TZ"-format and returned.
  
  If the date is unrecognized, then the empty list is returned (C<undef> in
  scalar context).
  
  The function is able to parse the following formats:
  
   "Wed, 09 Feb 1994 22:23:32 GMT"       -- HTTP format
   "Thu Feb  3 17:03:55 GMT 1994"        -- ctime(3) format
   "Thu Feb  3 00:00:00 1994",           -- ANSI C asctime() format
   "Tuesday, 08-Feb-94 14:15:29 GMT"     -- old rfc850 HTTP format
   "Tuesday, 08-Feb-1994 14:15:29 GMT"   -- broken rfc850 HTTP format
  
   "03/Feb/1994:17:03:55 -0700"   -- common logfile format
   "09 Feb 1994 22:23:32 GMT"     -- HTTP format (no weekday)
   "08-Feb-94 14:15:29 GMT"       -- rfc850 format (no weekday)
   "08-Feb-1994 14:15:29 GMT"     -- broken rfc850 format (no weekday)
  
   "1994-02-03 14:15:29 -0100"    -- ISO 8601 format
   "1994-02-03 14:15:29"          -- zone is optional
   "1994-02-03"                   -- only date
   "1994-02-03T14:15:29"          -- Use T as separator
   "19940203T141529Z"             -- ISO 8601 compact format
   "19940203"                     -- only date
  
   "08-Feb-94"         -- old rfc850 HTTP format    (no weekday, no time)
   "08-Feb-1994"       -- broken rfc850 HTTP format (no weekday, no time)
   "09 Feb 1994"       -- proposed new HTTP format  (no weekday, no time)
   "03/Feb/1994"       -- common logfile format     (no time, no offset)
  
   "Feb  3  1994"      -- Unix 'ls -l' format
   "Feb  3 17:03"      -- Unix 'ls -l' format
  
   "11-15-96  03:52PM" -- Windows 'dir' format
  
  The parser ignores leading and trailing whitespace.  It also allow the
  seconds to be missing and the month to be numerical in most formats.
  
  If the year is missing, then we assume that the date is the first
  matching date I<before> current month.  If the year is given with only
  2 digits, then parse_date() will select the century that makes the
  year closest to the current date.
  
  =item time2iso( [$time] )
  
  Same as time2str(), but returns a "YYYY-MM-DD hh:mm:ss"-formatted
  string representing time in the local time zone.
  
  =item time2isoz( [$time] )
  
  Same as time2str(), but returns a "YYYY-MM-DD hh:mm:ssZ"-formatted
  string representing Universal Time.
  
  =back
  
  =head1 SEE ALSO
  
  L<perlfunc/time>, L<Time::Zone>
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1995-2019 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
HTTP_DATE

    $fatpacked{"HTTP/Entity/Parser.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'HTTP_ENTITY_PARSER';
  package HTTP::Entity::Parser;
  
  use 5.008001;
  use strict;
  use warnings;
  use Stream::Buffered;
  use Module::Load;
  
  our $VERSION = "0.25";
  
  our $BUFFER_LENGTH = 65536;
  
  our %LOADED;
  our @DEFAULT_PARSER = qw/
      OctetStream
      UrlEncoded
      MultiPart
      JSON
  /;
  for my $parser ( @DEFAULT_PARSER ) {
      load "HTTP::Entity::Parser::".$parser;
      $LOADED{"HTTP::Entity::Parser::".$parser} = 1;
  }
  
  sub new {
      my $class = shift;
      my %args = (
          buffer_length => $BUFFER_LENGTH,
          @_,
      );
      bless [ [], $args{buffer_length} ], $class;
  }
  
  sub register {
      my ($self,$content_type, $klass, $opts) = @_;
      if ( !$LOADED{$klass} ) {
          load $klass;
          $LOADED{$klass} = 1;
      }
      push @{$self->[0]}, [$content_type, $klass, $opts];
  }
  
  sub parse {
      my ($self, $env) = @_;
  
      my $buffer_length = $self->[1];
      my $ct = $env->{CONTENT_TYPE} || '';
  
      my $parser;
      for my $handler (@{$self->[0]}) {
          if ( $ct eq $handler->[0] || index($ct, $handler->[0]) == 0) {
              $parser = $handler->[1]->new($env, $handler->[2]);
              last;
          }
      }
  
      if ( !$parser ) {
          $parser = HTTP::Entity::Parser::OctetStream->new();
      }
  
  
      my $input = $env->{'psgi.input'};
      if (!$input) {
          # no input
          return ([], []);
      }
  
      my $buffer;
      if ($env->{'psgix.input.buffered'}) {
          # Just in case if input is read by middleware/apps beforehand
          $input->seek(0, 0);
      } else {
          $buffer = Stream::Buffered->new();
      }
  
      my $chunked = do { no warnings; lc delete $env->{HTTP_TRANSFER_ENCODING} eq 'chunked' };
      if ( my $cl = $env->{CONTENT_LENGTH} ) {
          my $spin = 0;
          while ($cl > 0) {
              $input->read(my $chunk, $cl < $buffer_length ? $cl : $buffer_length);
              my $read = length $chunk;
              $cl -= $read;
              $parser->add($chunk);
              $buffer->print($chunk) if $buffer;
              if ($read == 0 && $spin++ > 2000) {
                  Carp::croak "Bad Content-Length: maybe client disconnect? ($cl bytes remaining)";
              }
          }
      }
      elsif ($chunked) {
          my $chunk_buffer = '';
          my $length;
          my $spin = 0;
          DECHUNK: while(1) {
              $input->read(my $chunk, $buffer_length);
              my $read = length $chunk;
              if ($read == 0 ) {
                  Carp::croak "Malformed chunked request" if $spin++ > 2000;
                  next;
              }
              $chunk_buffer .= $chunk;
              while ( $chunk_buffer =~ s/^(([0-9a-fA-F]+).*\015\012)// ) {
                  my $trailer   = $1;
                  my $chunk_len = hex $2;
                  if ($chunk_len == 0) {
                      last DECHUNK;
                  } elsif (length $chunk_buffer < $chunk_len + 2) {
                      $chunk_buffer = $trailer . $chunk_buffer;
                      last;
                  }
                  my $loaded = substr $chunk_buffer, 0, $chunk_len, '';
                  $parser->add($loaded);
                  $buffer->print($loaded);
                  $chunk_buffer =~ s/^\015\012//;
                  $length += $chunk_len;
              }
          }
          $env->{CONTENT_LENGTH} = $length;
      }
  
      if ($buffer) {
          $env->{'psgix.input.buffered'} = 1;
          $env->{'psgi.input'} = $buffer->rewind;
      } else {
          $input->seek(0, 0);
      }
  
      $parser->finalize();
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  HTTP::Entity::Parser - PSGI compliant HTTP Entity Parser
  
  =head1 SYNOPSIS
  
      use HTTP::Entity::Parser;
  
      my $parser = HTTP::Entity::Parser->new;
      $parser->register('application/x-www-form-urlencoded','HTTP::Entity::Parser::UrlEncoded');
      $parser->register('multipart/form-data','HTTP::Entity::Parser::MultiPart');
      $parser->register('application/json','HTTP::Entity::Parser::JSON');
  
      sub app {
          my $env = shift;
          my ( $params, $uploads) = $parser->parse($env);
      }
  
  =head1 DESCRIPTION
  
  HTTP::Entity::Parser is a PSGI-compliant HTTP Entity parser. This module also is compatible
  with L<HTTP::Body>. Unlike HTTP::Body, HTTP::Entity::Parser reads HTTP entities from
  PSGI's environment C<< $env->{'psgi.input'} >> and parses it.
  This module supports application/x-www-form-urlencoded, multipart/form-data and application/json.
  
  =head1 METHODS
  
  =over 4
  
  =item new( buffer_length => $length:Intger)
  
  Create the instance.
  
  =over 4
  
  =item buffer_length
  
  The buffer length that HTTP::Entity::Parser reads from psgi.input. 16384 by default.
  
  =back
  
  =item register($content_type:String, $class:String, $opts:HashRef)
  
  Register parser class.
  
    $parser->register('application/x-www-form-urlencoded','HTTP::Entity::Parser::UrlEncoded');
    $parser->register('multipart/form-data','HTTP::Entity::Parser::MultiPart');
    $parser->register('application/json','HTTP::Entity::Parser::JSON');
  
  If the request content_type matches the registered type, HTTP::Entity::Parser uses the registered
  parser class. If content_type does not match any registered type, HTTP::Entity::Parser::OctetStream is used.
  
  =item parse($env:HashRef)
  
  parse HTTP entities from PSGI's env.
  
    my ( $params:ArrayRef, $uploads:ArrayRef) = $parser->parse($env);
  
  C<$param> is a key-value pair list.
  
     my ( $params, $uploads) = $parser->parse($env);
     my $body_parameters = Hash::MultiValue->new(@$params);
  
  C<$uploads> is an ArrayRef of HashRef.
  
     my ( $params, $uploads) = $parser->parse($env);
     warn Dumper($uploads->[0]);
     {
         "name" => "upload", #field name
         "headers" => [
             "Content-Type" => "application/octet-stream",
             "Content-Disposition" => "form-data; name=\"upload\"; filename=\"hello.pl\""
         ],
         "size" => 78, #size of upload content
         "filename" => "hello.png", #original filename in the client
         "tempname" => "/tmp/XXXXX", # path to the temporary file where uploaded file is saved
     }
  
  When used with L<Plack::Request::Upload>:
  
     my ( $params, $uploads) = $parser->parse($env);
      my $upload_hmv = Hash::MultiValue->new();
      while ( my ($k,$v) = splice @$uploads, 0, 2 ) {
          my %copy = %$v;
          $copy{headers} = HTTP::Headers::Fast->new(@{$v->{headers}});
          $upload_hmv->add($k, Plack::Request::Upload->new(%copy));
      }
  
  =back
  
  =head1 PARSERS
  
  =over 4
  
  =item OctetStream
  
  Default parser, This parser does not parse entity, always return empty list.
  
  =item UrlEncoded
  
  For C<application/x-www-form-urlencoded>. It is used for HTTP POST without file upload
  
  =item MultiPart
  
  For C<multipart/form-data>. It is used for HTTP POST contains file upload.
  
  MultiPart parser use L<HTTP::MultiPartParser>.
  
  =item JSON
  
  For C<application/json>. This parser decodes JSON body automatically.
  
  It is convenient to use with Ajax forms.
  
  =back
  
  =head1 WHAT'S DIFFERENT FROM HTTP::Body
  
  HTTP::Entity::Parser accept PSGI's env and read body from it.
  
  HTTP::Entity::Parser is able to choose parsers by the instance, HTTP::Body requires to modify global variables.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<HTTP::Body>
  
  =item L<HTTP::MultiPartParser>
  
  =item L<Plack::Request>
  
  =item L<WWW::Form::UrlEncoded>
  
  HTTP::Entity::Parser uses this for parse application/x-www-form-urlencoded
  
  =back
  
  =head1 LICENSE
  
  Copyright (C) Masahiro Nagano.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Masahiro Nagano E<lt>kazeburo@gmail.comE<gt>
  
  Tokuhiro Matsuno E<lt>tokuhirom@gmail.comE<gt>
  
  This module is based on tokuhirom's code, see L<https://github.com/plack/Plack/pull/434>
  
  =cut
HTTP_ENTITY_PARSER

    $fatpacked{"HTTP/Entity/Parser/JSON.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'HTTP_ENTITY_PARSER_JSON';
  package HTTP::Entity::Parser::JSON;
  
  use strict;
  use warnings;
  use JSON::MaybeXS qw/decode_json/;
  use Encode qw/encode_utf8/;
  
  sub new {
      bless [''], $_[0];
  }
  
  sub add {
      my $self = shift;
      if (defined $_[0]) {
          $self->[0] .= $_[0];
      }
  }
  
  sub finalize {
      my $self = shift;
  
      my $p = decode_json($self->[0]);
      my @params;
      if (ref $p eq 'HASH') {
          while (my ($k, $v) = each %$p) {
              push @params, _encode($k), _encode($v);
          }
      }
      return (\@params, []);
  }
  
  sub _encode {
      my ($data) = @_;
  
      if (ref $data eq "ARRAY") {
          my @result;
          for my $d (@$data) {
              push @result, _encode($d);
          }
          return \@result;
      }
      elsif (ref $data eq "HASH") {
          my %result;
          while (my ($k, $v) = each %$data) {
              $result{_encode($k)} = _encode($v);
          }
          return \%result;
      }
  
      return defined $data ? encode_utf8($data) : undef;
  }
  
  1;
  
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  HTTP::Entity::Parser::JSON - parser for application/json
  
  =head1 SYNOPSIS
  
      use HTTP::Entity::Parser;
  
      my $parser = HTTP::Entity::Parser->new;
      $parser->register('application/json','HTTP::Entity::Parser::JSON');
  
  =head1 LICENSE
  
  Copyright (C) Masahiro Nagano.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Masahiro Nagano E<lt>kazeburo@gmail.comE<gt>
  
  Tokuhiro Matsuno E<lt>tokuhirom@gmail.comE<gt>
  
  =cut
HTTP_ENTITY_PARSER_JSON

    $fatpacked{"HTTP/Entity/Parser/MultiPart.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'HTTP_ENTITY_PARSER_MULTIPART';
  package HTTP::Entity::Parser::MultiPart;
  
  use strict;
  use warnings;
  use HTTP::MultiPartParser;
  use File::Temp qw/tempfile/;
  use Carp qw//;
  use Fcntl ":seek";
  
  #
  # copy from https://gist.github.com/chansen/7163968
  #
  sub extract_form_data {
      local $_ = shift;
      # Fast exit for common form-data disposition
      if (/\A form-data; \s name="((?:[^"]|\\")*)" (?: ;\s filename="((?:[^"]|\\")*)" )? \z/x) {
          return ($1, $2);
      }
  
      # disposition type must be form-data
      s/\A \s* form-data \s* ; //xi
        or return;
  
      my (%p, $k, $v);
      while (length) {
          s/ ^ \s+   //x;
          s/   \s+ $ //x;
  
          # skip empty parameters and unknown tokens
          next if s/^ [^\s"=;]* \s* ; //x;
  
          # parameter name (token)
          s/^ ([^\s"=;]+) \s* = \s* //x
            or return;
          $k = lc $1;
          # quoted parameter value
          if (s/^ "((?:[^"]|\\")*)" \s* (?: ; | $) //x) {
              $v = $1;
          }
          # unquoted parameter value (token)
          elsif (s/^ ([^\s";]*) \s* (?: ; | $) //x) {
              $v = $1;
          }
          else {
              return;
          }
          if ($k eq 'name' || $k eq 'filename') {
              return () if exists $p{$k};
              $p{$k} = $v;
          }
      }
      return exists $p{name} ? @p{qw(name filename)} : ();
  }
  
  sub new {
      my ($class, $env, $opts) = @_;
  
      my $self = bless { }, $class;
  
      my @uploads;
      my @params;
  
      unless (defined $env->{CONTENT_TYPE}) {
          Carp::croak("Missing CONTENT_TYPE in PSGI env");
      }
      unless ( $env->{CONTENT_TYPE} =~ /boundary=\"?([^\";]+)\"?/ ) {
          Carp::croak("Invalid boundary in content_type: $env->{CONTENT_TYPE}");
      }
      my $boundary = $1;
  
  
      my $part;
      my $parser = HTTP::MultiPartParser->new(
          boundary => $boundary,
          on_header => sub {
              my ($headers) = @_;
  
              my $disposition;
              foreach (@$headers) {
                  if (/\A Content-Disposition: [\x09\x20]* (.*)/xi) {
                      $disposition = $1;
                      last;
                  }
              }
  
              (defined $disposition)
                  or die q/Content-Disposition header is missing in part/;
  
              my ($disposition_name, $disposition_filename) = extract_form_data($disposition);
              defined $disposition_name
                  or die q/Parameter 'name' is missing from Content-Disposition header/;
  
              $part = {
                  name    => $disposition_name,
                  headers => $headers,
              };
  
              if ( defined $disposition_filename ) {
                  $part->{filename} = $disposition_filename;
                  $self->{tempdir} ||= do {
                      my $dir = File::Temp->newdir('XXXXX', TMPDIR => 1, CLEANUP => 1);
                      # Temporary dirs will remove after the request.
                      push @{$env->{'http.entity.parser.multipart.tempdir'}}, $dir;
                      $dir;
  
                  };
                  my ($tempfh, $tempname) = tempfile(UNLINK => 0, DIR => $self->{tempdir});
                  $part->{fh} = $tempfh;
                  $part->{tempname} = $tempname;
              }
          },
          on_body => sub {
              my ($chunk, $final) = @_;
  
              my $fh = $part->{fh};
              if ($fh) {
                  print $fh $chunk
                      or die qq/Could not write to file handle: '$!'/;
                  if ($final && $part->{filename} ne "" ) { # compatible with HTTP::Body
                      seek($fh, 0, SEEK_SET)
                          or die qq/Could not rewind file handle: '$!'/;
  
                      my @headers = map { split(/\s*:\s*/, $_, 2) }
                          @{$part->{headers}};
                      push @uploads, $part->{name}, {
                          name     => $part->{name},
                          headers  => \@headers,
                          size     => -s $part->{fh},
                          filename => $part->{filename},
                          tempname => $part->{tempname},
                      };
                  }
              } else {
                  $part->{data} .= $chunk;
                  if ($final) {
                      push @params, $part->{name}, $part->{data};
                  }
              }
          },
          $opts->{on_error} ? (on_error => $opts->{on_error}) : (),
      );
  
      $self->{parser}  = $parser;
      $self->{params}  = \@params;
      $self->{uploads} = \@uploads;
  
      return $self;
  }
  
  sub add {
      my $self = shift;
      $self->{parser}->parse($_[0]) if defined $_[0];
  }
  
  sub finalize {
      my $self = shift;
      (delete $self->{parser})->finish();
      return ($self->{params}, $self->{uploads});
  }
  
  
  1;
  
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  HTTP::Entity::Parser::MultiPart - parser for multipart/form-data
  
  =head1 SYNOPSIS
  
      use HTTP::Entity::Parser;
      
      my $parser = HTTP::Entity::Parser->new;
      $parser->register('multipart/form-data','HTTP::Entity::Parser::MultiPart');
  
  =head1 DESCRIPTION
  
  This is a parser class for multipart/form-data.
  
  MultiPart parser use L<HTTP::MultiPartParser>.
  
  =head1 LICENSE
  
  Copyright (C) Masahiro Nagano.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Masahiro Nagano E<lt>kazeburo@gmail.comE<gt>
  
  Tokuhiro Matsuno E<lt>tokuhirom@gmail.comE<gt>
  
  =cut
  
  
HTTP_ENTITY_PARSER_MULTIPART

    $fatpacked{"HTTP/Entity/Parser/OctetStream.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'HTTP_ENTITY_PARSER_OCTETSTREAM';
  package HTTP::Entity::Parser::OctetStream;
  
  use strict;
  use warnings;
  
  sub new {
      bless [], $_[0];
  }
  
  sub add { }
  
  sub finalize {
      return ([],[]);
  }
  
  1;
  
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  HTTP::Entity::Parser::OctetStream - parser for application/octet-stream
  
  =head1 SYNOPSIS
  
      use HTTP::Entity::Parser;
      
      my $parser = HTTP::Entity::Parser->new;
      my ($params, $uplaods) = $parser->parse($env); # [] , []
  
  =head1 DESCRIPTION
  
  This is a parser class for application/octet-stream and other.
  This is used as default parser.
  
  OctetStream always returns empty list.
  
  =head1 LICENSE
  
  Copyright (C) Masahiro Nagano.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Masahiro Nagano E<lt>kazeburo@gmail.comE<gt>
  
  Tokuhiro Matsuno E<lt>tokuhirom@gmail.comE<gt>
  
  =cut
  
  
HTTP_ENTITY_PARSER_OCTETSTREAM

    $fatpacked{"HTTP/Entity/Parser/UrlEncoded.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'HTTP_ENTITY_PARSER_URLENCODED';
  package HTTP::Entity::Parser::UrlEncoded;
  
  use strict;
  use warnings;
  use WWW::Form::UrlEncoded qw/parse_urlencoded_arrayref/;
  
  sub new {
      bless [''], $_[0];
  }
  
  sub add {
      my $self = shift;
      if (defined $_[0]) {
          $self->[0] .= $_[0];
      }
  }
  
  sub finalize {
      return (parse_urlencoded_arrayref($_[0]->[0]), []);
  }
  
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  HTTP::Entity::Parser::UrlEncoded - parser for application/x-www-form-urlencoded
  
  =head1 SYNOPSIS
  
      use HTTP::Entity::Parser;
      
      my $parser = HTTP::Entity::Parser->new;
      $parser->register('application/x-www-form-urlencoded','HTTP::Entity::Parser::UrlEncoded');
  
  =head1 DESCRIPTION
  
  This is a parser class for application/x-www-form-urlencoded.
  
  =head1 LICENSE
  
  Copyright (C) Masahiro Nagano.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Masahiro Nagano E<lt>kazeburo@gmail.comE<gt>
  
  Tokuhiro Matsuno E<lt>tokuhirom@gmail.comE<gt>
  
  =cut
  
  
HTTP_ENTITY_PARSER_URLENCODED

    $fatpacked{"HTTP/Headers.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'HTTP_HEADERS';
  package HTTP::Headers;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.44';
  
  use Clone qw(clone);
  use Carp ();
  
  # The $TRANSLATE_UNDERSCORE variable controls whether '_' can be used
  # as a replacement for '-' in header field names.
  our $TRANSLATE_UNDERSCORE = 1 unless defined $TRANSLATE_UNDERSCORE;
  
  # "Good Practice" order of HTTP message headers:
  #    - General-Headers
  #    - Request-Headers
  #    - Response-Headers
  #    - Entity-Headers
  
  my @general_headers = qw(
      Cache-Control Connection Date Pragma Trailer Transfer-Encoding Upgrade
      Via Warning
  );
  
  my @request_headers = qw(
      Accept Accept-Charset Accept-Encoding Accept-Language
      Authorization Expect From Host
      If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since
      Max-Forwards Proxy-Authorization Range Referer TE User-Agent
  );
  
  my @response_headers = qw(
      Accept-Ranges Age ETag Location Proxy-Authenticate Retry-After Server
      Vary WWW-Authenticate
  );
  
  my @entity_headers = qw(
      Allow Content-Encoding Content-Language Content-Length Content-Location
      Content-MD5 Content-Range Content-Type Expires Last-Modified
  );
  
  my %entity_header = map { lc($_) => 1 } @entity_headers;
  
  my @header_order = (
      @general_headers,
      @request_headers,
      @response_headers,
      @entity_headers,
  );
  
  # Make alternative representations of @header_order.  This is used
  # for sorting and case matching.
  my %header_order;
  my %standard_case;
  
  {
      my $i = 0;
      for (@header_order) {
  	my $lc = lc $_;
  	$header_order{$lc} = ++$i;
  	$standard_case{$lc} = $_;
      }
  }
  
  
  
  sub new
  {
      my($class) = shift;
      my $self = bless {}, $class;
      $self->header(@_) if @_; # set up initial headers
      $self;
  }
  
  
  sub header
  {
      my $self = shift;
      Carp::croak('Usage: $h->header($field, ...)') unless @_;
      my(@old);
      my %seen;
      while (@_) {
  	my $field = shift;
          my $op = @_ ? ($seen{lc($field)}++ ? 'PUSH' : 'SET') : 'GET';
  	@old = $self->_header($field, shift, $op);
      }
      return @old if wantarray;
      return $old[0] if @old <= 1;
      join(", ", @old);
  }
  
  sub clear
  {
      my $self = shift;
      %$self = ();
  }
  
  
  sub push_header
  {
      my $self = shift;
      return $self->_header(@_, 'PUSH_H') if @_ == 2;
      while (@_) {
  	$self->_header(splice(@_, 0, 2), 'PUSH_H');
      }
  }
  
  
  sub init_header
  {
      Carp::croak('Usage: $h->init_header($field, $val)') if @_ != 3;
      shift->_header(@_, 'INIT');
  }
  
  
  sub remove_header
  {
      my($self, @fields) = @_;
      my $field;
      my @values;
      foreach $field (@fields) {
  	$field =~ tr/_/-/ if $field !~ /^:/ && $TRANSLATE_UNDERSCORE;
  	my $v = delete $self->{lc $field};
  	push(@values, ref($v) eq 'ARRAY' ? @$v : $v) if defined $v;
      }
      return @values;
  }
  
  sub remove_content_headers
  {
      my $self = shift;
      unless (defined(wantarray)) {
  	# fast branch that does not create return object
  	delete @$self{grep $entity_header{$_} || /^content-/, keys %$self};
  	return;
      }
  
      my $c = ref($self)->new;
      for my $f (grep $entity_header{$_} || /^content-/, keys %$self) {
  	$c->{$f} = delete $self->{$f};
      }
      if (exists $self->{'::std_case'}) {
  	$c->{'::std_case'} = $self->{'::std_case'};
      }
      $c;
  }
  
  
  sub _header
  {
      my($self, $field, $val, $op) = @_;
  
      Carp::croak("Illegal field name '$field'")
          if rindex($field, ':') > 1 || !length($field);
  
      unless ($field =~ /^:/) {
  	$field =~ tr/_/-/ if $TRANSLATE_UNDERSCORE;
  	my $old = $field;
  	$field = lc $field;
  	unless($standard_case{$field} || $self->{'::std_case'}{$field}) {
  	    # generate a %std_case entry for this field
  	    $old =~ s/\b(\w)/\u$1/g;
  	    $self->{'::std_case'}{$field} = $old;
  	}
      }
  
      $op ||= defined($val) ? 'SET' : 'GET';
      if ($op eq 'PUSH_H') {
  	# Like PUSH but where we don't care about the return value
  	if (exists $self->{$field}) {
  	    my $h = $self->{$field};
  	    if (ref($h) eq 'ARRAY') {
  		push(@$h, ref($val) eq "ARRAY" ? @$val : $val);
  	    }
  	    else {
  		$self->{$field} = [$h, ref($val) eq "ARRAY" ? @$val : $val]
  	    }
  	    return;
  	}
  	$self->{$field} = $val;
  	return;
      }
  
      my $h = $self->{$field};
      my @old = ref($h) eq 'ARRAY' ? @$h : (defined($h) ? ($h) : ());
  
      unless ($op eq 'GET' || ($op eq 'INIT' && @old)) {
  	if (defined($val)) {
  	    my @new = ($op eq 'PUSH') ? @old : ();
  	    if (ref($val) ne 'ARRAY') {
  		push(@new, $val);
  	    }
  	    else {
  		push(@new, @$val);
  	    }
  	    $self->{$field} = @new > 1 ? \@new : $new[0];
  	}
  	elsif ($op ne 'PUSH') {
  	    delete $self->{$field};
  	}
      }
      @old;
  }
  
  
  sub _sorted_field_names
  {
      my $self = shift;
      return [ sort {
          ($header_order{$a} || 999) <=> ($header_order{$b} || 999) ||
           $a cmp $b
      } grep !/^::/, keys %$self ];
  }
  
  
  sub header_field_names {
      my $self = shift;
      return map $standard_case{$_} || $self->{'::std_case'}{$_} || $_, @{ $self->_sorted_field_names },
  	if wantarray;
      return grep !/^::/, keys %$self;
  }
  
  
  sub scan
  {
      my($self, $sub) = @_;
      my $key;
      for $key (@{ $self->_sorted_field_names }) {
  	my $vals = $self->{$key};
  	if (ref($vals) eq 'ARRAY') {
  	    my $val;
  	    for $val (@$vals) {
  		$sub->($standard_case{$key} || $self->{'::std_case'}{$key} || $key, $val);
  	    }
  	}
  	else {
  	    $sub->($standard_case{$key} || $self->{'::std_case'}{$key} || $key, $vals);
  	}
      }
  }
  
  sub flatten {
  	my($self)=@_;
  
  	(
  		map {
  			my $k = $_;
  			map {
  				( $k => $_ )
  			} $self->header($_);
  		} $self->header_field_names
  	);
  }
  
  sub as_string
  {
      my($self, $endl) = @_;
      $endl = "\n" unless defined $endl;
  
      my @result = ();
      for my $key (@{ $self->_sorted_field_names }) {
  	next if index($key, '_') == 0;
  	my $vals = $self->{$key};
  	if ( ref($vals) eq 'ARRAY' ) {
  	    for my $val (@$vals) {
  		$val = '' if not defined $val;
  		my $field = $standard_case{$key} || $self->{'::std_case'}{$key} || $key;
  		$field =~ s/^://;
  		if ( index($val, "\n") >= 0 ) {
  		    $val = _process_newline($val, $endl);
  		}
  		push @result, $field . ': ' . $val;
  	    }
  	}
  	else {
  	    $vals = '' if not defined $vals;
  	    my $field = $standard_case{$key} || $self->{'::std_case'}{$key} || $key;
  	    $field =~ s/^://;
  	    if ( index($vals, "\n") >= 0 ) {
  		$vals = _process_newline($vals, $endl);
  	    }
  	    push @result, $field . ': ' . $vals;
  	}
      }
  
      join($endl, @result, '');
  }
  
  sub _process_newline {
      local $_ = shift;
      my $endl = shift;
      # must handle header values with embedded newlines with care
      s/\s+$//;        # trailing newlines and space must go
      s/\n(\x0d?\n)+/\n/g;     # no empty lines
      s/\n([^\040\t])/\n $1/g; # initial space for continuation
      s/\n/$endl/g;    # substitute with requested line ending
      $_;
  }
  
  
  sub _date_header
  {
      require HTTP::Date;
      my($self, $header, $time) = @_;
      my($old) = $self->_header($header);
      if (defined $time) {
  	$self->_header($header, HTTP::Date::time2str($time));
      }
      $old =~ s/;.*// if defined($old);
      HTTP::Date::str2time($old);
  }
  
  
  sub date                { shift->_date_header('Date',                @_); }
  sub expires             { shift->_date_header('Expires',             @_); }
  sub if_modified_since   { shift->_date_header('If-Modified-Since',   @_); }
  sub if_unmodified_since { shift->_date_header('If-Unmodified-Since', @_); }
  sub last_modified       { shift->_date_header('Last-Modified',       @_); }
  
  # This is used as a private LWP extension.  The Client-Date header is
  # added as a timestamp to a response when it has been received.
  sub client_date         { shift->_date_header('Client-Date',         @_); }
  
  # The retry_after field is dual format (can also be a expressed as
  # number of seconds from now), so we don't provide an easy way to
  # access it until we have know how both these interfaces can be
  # addressed.  One possibility is to return a negative value for
  # relative seconds and a positive value for epoch based time values.
  #sub retry_after       { shift->_date_header('Retry-After',       @_); }
  
  sub content_type      {
      my $self = shift;
      my $ct = $self->{'content-type'};
      $self->{'content-type'} = shift if @_;
      $ct = $ct->[0] if ref($ct) eq 'ARRAY';
      return '' unless defined($ct) && length($ct);
      my @ct = split(/;\s*/, $ct, 2);
      for ($ct[0]) {
  	s/\s+//g;
  	$_ = lc($_);
      }
      wantarray ? @ct : $ct[0];
  }
  
  sub content_type_charset {
      my $self = shift;
      require HTTP::Headers::Util;
      my $h = $self->{'content-type'};
      $h = $h->[0] if ref($h);
      $h = "" unless defined $h;
      my @v = HTTP::Headers::Util::split_header_words($h);
      if (@v) {
  	my($ct, undef, %ct_param) = @{$v[0]};
  	my $charset = $ct_param{charset};
  	if ($ct) {
  	    $ct = lc($ct);
  	    $ct =~ s/\s+//;
  	}
  	if ($charset) {
  	    $charset = uc($charset);
  	    $charset =~ s/^\s+//;  $charset =~ s/\s+\z//;
  	    undef($charset) if $charset eq "";
  	}
  	return $ct, $charset if wantarray;
  	return $charset;
      }
      return undef, undef if wantarray;
      return undef;
  }
  
  sub content_is_text {
      my $self = shift;
      return $self->content_type =~ m,^text/,;
  }
  
  sub content_is_html {
      my $self = shift;
      return $self->content_type eq 'text/html' || $self->content_is_xhtml;
  }
  
  sub content_is_xhtml {
      my $ct = shift->content_type;
      return $ct eq "application/xhtml+xml" ||
             $ct eq "application/vnd.wap.xhtml+xml";
  }
  
  sub content_is_xml {
      my $ct = shift->content_type;
      return 1 if $ct eq "text/xml";
      return 1 if $ct eq "application/xml";
      return 1 if $ct =~ /\+xml$/;
      return 0;
  }
  
  sub referer           {
      my $self = shift;
      if (@_ && $_[0] =~ /#/) {
  	# Strip fragment per RFC 2616, section 14.36.
  	my $uri = shift;
  	if (ref($uri)) {
  	    $uri = $uri->clone;
  	    $uri->fragment(undef);
  	}
  	else {
  	    $uri =~ s/\#.*//;
  	}
  	unshift @_, $uri;
      }
      ($self->_header('Referer', @_))[0];
  }
  *referrer = \&referer;  # on tchrist's request
  
  sub title             { (shift->_header('Title',            @_))[0] }
  sub content_encoding  { (shift->_header('Content-Encoding', @_))[0] }
  sub content_language  { (shift->_header('Content-Language', @_))[0] }
  sub content_length    { (shift->_header('Content-Length',   @_))[0] }
  
  sub user_agent        { (shift->_header('User-Agent',       @_))[0] }
  sub server            { (shift->_header('Server',           @_))[0] }
  
  sub from              { (shift->_header('From',             @_))[0] }
  sub warning           { (shift->_header('Warning',          @_))[0] }
  
  sub www_authenticate  { (shift->_header('WWW-Authenticate', @_))[0] }
  sub authorization     { (shift->_header('Authorization',    @_))[0] }
  
  sub proxy_authenticate  { (shift->_header('Proxy-Authenticate',  @_))[0] }
  sub proxy_authorization { (shift->_header('Proxy-Authorization', @_))[0] }
  
  sub authorization_basic       { shift->_basic_auth("Authorization",       @_) }
  sub proxy_authorization_basic { shift->_basic_auth("Proxy-Authorization", @_) }
  
  sub _basic_auth {
      require MIME::Base64;
      my($self, $h, $user, $passwd) = @_;
      my($old) = $self->_header($h);
      if (defined $user) {
  	Carp::croak("Basic authorization user name can't contain ':'")
  	  if $user =~ /:/;
  	$passwd = '' unless defined $passwd;
  	$self->_header($h => 'Basic ' .
                               MIME::Base64::encode("$user:$passwd", ''));
      }
      if (defined $old && $old =~ s/^\s*Basic\s+//) {
  	my $val = MIME::Base64::decode($old);
  	return $val unless wantarray;
  	return split(/:/, $val, 2);
      }
      return;
  }
  
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Headers - Class encapsulating HTTP Message headers
  
  =head1 VERSION
  
  version 6.44
  
  =head1 SYNOPSIS
  
   require HTTP::Headers;
   $h = HTTP::Headers->new;
  
   $h->header('Content-Type' => 'text/plain');  # set
   $ct = $h->header('Content-Type');            # get
   $h->remove_header('Content-Type');           # delete
  
  =head1 DESCRIPTION
  
  The C<HTTP::Headers> class encapsulates HTTP-style message headers.
  The headers consist of attribute-value pairs also called fields, which
  may be repeated, and which are printed in a particular order.  The
  field names are cases insensitive.
  
  Instances of this class are usually created as member variables of the
  C<HTTP::Request> and C<HTTP::Response> classes, internal to the
  library.
  
  The following methods are available:
  
  =over 4
  
  =item $h = HTTP::Headers->new
  
  Constructs a new C<HTTP::Headers> object.  You might pass some initial
  attribute-value pairs as parameters to the constructor.  I<E.g.>:
  
   $h = HTTP::Headers->new(
         Date         => 'Thu, 03 Feb 1994 00:00:00 GMT',
         Content_Type => 'text/html; version=3.2',
         Content_Base => 'http://www.perl.org/');
  
  The constructor arguments are passed to the C<header> method which is
  described below.
  
  =item $h->clone
  
  Returns a copy of this C<HTTP::Headers> object.
  
  =item $h->header( $field )
  
  =item $h->header( $field => $value )
  
  =item $h->header( $f1 => $v1, $f2 => $v2, ... )
  
  Get or set the value of one or more header fields.  The header field
  name ($field) is not case sensitive.  To make the life easier for perl
  users who wants to avoid quoting before the => operator, you can use
  '_' as a replacement for '-' in header names.
  
  The header() method accepts multiple ($field => $value) pairs, which
  means that you can update several fields with a single invocation.
  
  The $value argument may be a plain string or a reference to an array
  of strings for a multi-valued field. If the $value is provided as
  C<undef> then the field is removed.  If the $value is not given, then
  that header field will remain unchanged. In addition to being a string,
  $value may be something that stringifies.
  
  The old value (or values) of the last of the header fields is returned.
  If no such field exists C<undef> will be returned.
  
  A multi-valued field will be returned as separate values in list
  context and will be concatenated with ", " as separator in scalar
  context.  The HTTP spec (RFC 2616) promises that joining multiple
  values in this way will not change the semantic of a header field, but
  in practice there are cases like old-style Netscape cookies (see
  L<HTTP::Cookies>) where "," is used as part of the syntax of a single
  field value.
  
  Examples:
  
   $header->header(MIME_Version => '1.0',
  		 User_Agent   => 'My-Web-Client/0.01');
   $header->header(Accept => "text/html, text/plain, image/*");
   $header->header(Accept => [qw(text/html text/plain image/*)]);
   @accepts = $header->header('Accept');  # get multiple values
   $accepts = $header->header('Accept');  # get values as a single string
  
  =item $h->push_header( $field => $value )
  
  =item $h->push_header( $f1 => $v1, $f2 => $v2, ... )
  
  Add a new field value for the specified header field.  Previous values
  for the same field are retained.
  
  As for the header() method, the field name ($field) is not case
  sensitive and '_' can be used as a replacement for '-'.
  
  The $value argument may be a scalar or a reference to a list of
  scalars.
  
   $header->push_header(Accept => 'image/jpeg');
   $header->push_header(Accept => [map "image/$_", qw(gif png tiff)]);
  
  =item $h->init_header( $field => $value )
  
  Set the specified header to the given value, but only if no previous
  value for that field is set.
  
  The header field name ($field) is not case sensitive and '_'
  can be used as a replacement for '-'.
  
  The $value argument may be a scalar or a reference to a list of
  scalars.
  
  =item $h->remove_header( $field, ... )
  
  This function removes the header fields with the specified names.
  
  The header field names ($field) are not case sensitive and '_'
  can be used as a replacement for '-'.
  
  The return value is the values of the fields removed.  In scalar
  context the number of fields removed is returned.
  
  Note that if you pass in multiple field names then it is generally not
  possible to tell which of the returned values belonged to which field.
  
  =item $h->remove_content_headers
  
  This will remove all the header fields used to describe the content of
  a message.  All header field names prefixed with C<Content-> fall
  into this category, as well as C<Allow>, C<Expires> and
  C<Last-Modified>.  RFC 2616 denotes these fields as I<Entity Header
  Fields>.
  
  The return value is a new C<HTTP::Headers> object that contains the
  removed headers only.
  
  =item $h->clear
  
  This will remove all header fields.
  
  =item $h->header_field_names
  
  Returns the list of distinct names for the fields present in the
  header.  The field names have case as suggested by HTTP spec, and the
  names are returned in the recommended "Good Practice" order.
  
  In scalar context return the number of distinct field names.
  
  =item $h->scan( \&process_header_field )
  
  Apply a subroutine to each header field in turn.  The callback routine
  is called with two parameters; the name of the field and a single
  value (a string).  If a header field is multi-valued, then the
  routine is called once for each value.  The field name passed to the
  callback routine has case as suggested by HTTP spec, and the headers
  will be visited in the recommended "Good Practice" order.
  
  Any return values of the callback routine are ignored.  The loop can
  be broken by raising an exception (C<die>), but the caller of scan()
  would have to trap the exception itself.
  
  =item $h->flatten()
  
  Returns the list of pairs of keys and values.
  
  =item $h->as_string
  
  =item $h->as_string( $eol )
  
  Return the header fields as a formatted MIME header.  Since it
  internally uses the C<scan> method to build the string, the result
  will use case as suggested by HTTP spec, and it will follow
  recommended "Good Practice" of ordering the header fields.  Long header
  values are not folded.
  
  The optional $eol parameter specifies the line ending sequence to
  use.  The default is "\n".  Embedded "\n" characters in header field
  values will be substituted with this line ending sequence.
  
  =back
  
  =head1 CONVENIENCE METHODS
  
  The most frequently used headers can also be accessed through the
  following convenience methods.  Most of these methods can both be used to read
  and to set the value of a header.  The header value is set if you pass
  an argument to the method.  The old header value is always returned.
  If the given header did not exist then C<undef> is returned.
  
  Methods that deal with dates/times always convert their value to system
  time (seconds since Jan 1, 1970) and they also expect this kind of
  value when the header value is set.
  
  =over 4
  
  =item $h->date
  
  This header represents the date and time at which the message was
  originated. I<E.g.>:
  
    $h->date(time);  # set current date
  
  =item $h->expires
  
  This header gives the date and time after which the entity should be
  considered stale.
  
  =item $h->if_modified_since
  
  =item $h->if_unmodified_since
  
  These header fields are used to make a request conditional.  If the requested
  resource has (or has not) been modified since the time specified in this field,
  then the server will return a C<304 Not Modified> response instead of
  the document itself.
  
  =item $h->last_modified
  
  This header indicates the date and time at which the resource was last
  modified. I<E.g.>:
  
    # check if document is more than 1 hour old
    if (my $last_mod = $h->last_modified) {
        if ($last_mod < time - 60*60) {
  	  ...
        }
    }
  
  =item $h->content_type
  
  The Content-Type header field indicates the media type of the message
  content. I<E.g.>:
  
    $h->content_type('text/html');
  
  The value returned will be converted to lower case, and potential
  parameters will be chopped off and returned as a separate value if in
  an array context.  If there is no such header field, then the empty
  string is returned.  This makes it safe to do the following:
  
    if ($h->content_type eq 'text/html') {
       # we enter this place even if the real header value happens to
       # be 'TEXT/HTML; version=3.0'
       ...
    }
  
  =item $h->content_type_charset
  
  Returns the upper-cased charset specified in the Content-Type header.  In list
  context return the lower-cased bare content type followed by the upper-cased
  charset.  Both values will be C<undef> if not specified in the header.
  
  =item $h->content_is_text
  
  Returns TRUE if the Content-Type header field indicate that the
  content is textual.
  
  =item $h->content_is_html
  
  Returns TRUE if the Content-Type header field indicate that the
  content is some kind of HTML (including XHTML).  This method can't be
  used to set Content-Type.
  
  =item $h->content_is_xhtml
  
  Returns TRUE if the Content-Type header field indicate that the
  content is XHTML.  This method can't be used to set Content-Type.
  
  =item $h->content_is_xml
  
  Returns TRUE if the Content-Type header field indicate that the
  content is XML.  This method can't be used to set Content-Type.
  
  =item $h->content_encoding
  
  The Content-Encoding header field is used as a modifier to the
  media type.  When present, its value indicates what additional
  encoding mechanism has been applied to the resource.
  
  =item $h->content_length
  
  A decimal number indicating the size in bytes of the message content.
  
  =item $h->content_language
  
  The natural language(s) of the intended audience for the message
  content.  The value is one or more language tags as defined by RFC
  1766.  Eg. "no" for some kind of Norwegian and "en-US" for English the
  way it is written in the US.
  
  =item $h->title
  
  The title of the document.  In libwww-perl this header will be
  initialized automatically from the E<lt>TITLE>...E<lt>/TITLE> element
  of HTML documents.  I<This header is no longer part of the HTTP
  standard.>
  
  =item $h->user_agent
  
  This header field is used in request messages and contains information
  about the user agent originating the request.  I<E.g.>:
  
    $h->user_agent('Mozilla/5.0 (compatible; MSIE 7.0; Windows NT 6.0)');
  
  =item $h->server
  
  The server header field contains information about the software being
  used by the originating server program handling the request.
  
  =item $h->from
  
  This header should contain an Internet e-mail address for the human
  user who controls the requesting user agent.  The address should be
  machine-usable, as defined by RFC822.  E.g.:
  
    $h->from('King Kong <king@kong.com>');
  
  I<This header is no longer part of the HTTP standard.>
  
  =item $h->referer
  
  Used to specify the address (URI) of the document from which the
  requested resource address was obtained.
  
  The "Free On-line Dictionary of Computing" as this to say about the
  word I<referer>:
  
       <World-Wide Web> A misspelling of "referrer" which
       somehow made it into the {HTTP} standard.  A given {web
       page}'s referer (sic) is the {URL} of whatever web page
       contains the link that the user followed to the current
       page.  Most browsers pass this information as part of a
       request.
  
       (1998-10-19)
  
  By popular demand C<referrer> exists as an alias for this method so you
  can avoid this misspelling in your programs and still send the right
  thing on the wire.
  
  When setting the referrer, this method removes the fragment from the
  given URI if it is present, as mandated by RFC2616.  Note that
  the removal does I<not> happen automatically if using the header(),
  push_header() or init_header() methods to set the referrer.
  
  =item $h->www_authenticate
  
  This header must be included as part of a C<401 Unauthorized> response.
  The field value consist of a challenge that indicates the
  authentication scheme and parameters applicable to the requested URI.
  
  =item $h->proxy_authenticate
  
  This header must be included in a C<407 Proxy Authentication Required>
  response.
  
  =item $h->authorization
  
  =item $h->proxy_authorization
  
  A user agent that wishes to authenticate itself with a server or a
  proxy, may do so by including these headers.
  
  =item $h->authorization_basic
  
  This method is used to get or set an authorization header that use the
  "Basic Authentication Scheme".  In array context it will return two
  values; the user name and the password.  In scalar context it will
  return I<"uname:password"> as a single string value.
  
  When used to set the header value, it expects two arguments.  I<E.g.>:
  
    $h->authorization_basic($uname, $password);
  
  The method will croak if the $uname contains a colon ':'.
  
  =item $h->proxy_authorization_basic
  
  Same as authorization_basic() but will set the "Proxy-Authorization"
  header instead.
  
  =back
  
  =head1 NON-CANONICALIZED FIELD NAMES
  
  The header field name spelling is normally canonicalized including the
  '_' to '-' translation.  There are some application where this is not
  appropriate.  Prefixing field names with ':' allow you to force a
  specific spelling.  For example if you really want a header field name
  to show up as C<foo_bar> instead of "Foo-Bar", you might set it like
  this:
  
    $h->header(":foo_bar" => 1);
  
  These field names are returned with the ':' intact for
  $h->header_field_names and the $h->scan callback, but the colons do
  not show in $h->as_string.
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  #ABSTRACT: Class encapsulating HTTP Message headers
  
HTTP_HEADERS

    $fatpacked{"HTTP/Headers/Auth.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'HTTP_HEADERS_AUTH';
  package HTTP::Headers::Auth;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.44';
  
  use HTTP::Headers;
  
  package
      HTTP::Headers;
  
  BEGIN {
      # we provide a new (and better) implementations below
      undef(&www_authenticate);
      undef(&proxy_authenticate);
  }
  
  require HTTP::Headers::Util;
  
  sub _parse_authenticate
  {
      my @ret;
      for (HTTP::Headers::Util::split_header_words(@_)) {
  	if (!defined($_->[1])) {
  	    # this is a new auth scheme
  	    push(@ret, shift(@$_) => {});
  	    shift @$_;
  	}
  	if (@ret) {
  	    # this a new parameter pair for the last auth scheme
  	    while (@$_) {
  		my $k = shift @$_;
  		my $v = shift @$_;
  	        $ret[-1]{$k} = $v;
  	    }
  	}
  	else {
  	    # something wrong, parameter pair without any scheme seen
  	    # IGNORE
  	}
      }
      @ret;
  }
  
  sub _authenticate
  {
      my $self = shift;
      my $header = shift;
      my @old = $self->_header($header);
      if (@_) {
  	$self->remove_header($header);
  	my @new = @_;
  	while (@new) {
  	    my $a_scheme = shift(@new);
  	    if ($a_scheme =~ /\s/) {
  		# assume complete valid value, pass it through
  		$self->push_header($header, $a_scheme);
  	    }
  	    else {
  		my @param;
  		if (@new) {
  		    my $p = $new[0];
  		    if (ref($p) eq "ARRAY") {
  			@param = @$p;
  			shift(@new);
  		    }
  		    elsif (ref($p) eq "HASH") {
  			@param = %$p;
  			shift(@new);
  		    }
  		}
  		my $val = ucfirst(lc($a_scheme));
  		if (@param) {
  		    my $sep = " ";
  		    while (@param) {
  			my $k = shift @param;
  			my $v = shift @param;
  			if ($v =~ /[^0-9a-zA-Z]/ || lc($k) eq "realm") {
  			    # must quote the value
  			    $v =~ s,([\\\"]),\\$1,g;
  			    $v = qq("$v");
  			}
  			$val .= "$sep$k=$v";
  			$sep = ", ";
  		    }
  		}
  		$self->push_header($header, $val);
  	    }
  	}
      }
      return unless defined wantarray;
      wantarray ? _parse_authenticate(@old) : join(", ", @old);
  }
  
  
  sub www_authenticate    { shift->_authenticate("WWW-Authenticate", @_)   }
  sub proxy_authenticate  { shift->_authenticate("Proxy-Authenticate", @_) }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Headers::Auth
  
  =head1 VERSION
  
  version 6.44
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
HTTP_HEADERS_AUTH

    $fatpacked{"HTTP/Headers/ETag.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'HTTP_HEADERS_ETAG';
  package HTTP::Headers::ETag;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.44';
  
  require HTTP::Date;
  
  require HTTP::Headers;
  package
      HTTP::Headers;
  
  sub _etags
  {
      my $self = shift;
      my $header = shift;
      my @old = _split_etag_list($self->_header($header));
      if (@_) {
  	$self->_header($header => join(", ", _split_etag_list(@_)));
      }
      wantarray ? @old : join(", ", @old);
  }
  
  sub etag          { shift->_etags("ETag", @_); }
  sub if_match      { shift->_etags("If-Match", @_); }
  sub if_none_match { shift->_etags("If-None-Match", @_); }
  
  sub if_range {
      # Either a date or an entity-tag
      my $self = shift;
      my @old = $self->_header("If-Range");
      if (@_) {
  	my $new = shift;
  	if (!defined $new) {
  	    $self->remove_header("If-Range");
  	}
  	elsif ($new =~ /^\d+$/) {
  	    $self->_date_header("If-Range", $new);
  	}
  	else {
  	    $self->_etags("If-Range", $new);
  	}
      }
      return unless defined(wantarray);
      for (@old) {
  	my $t = HTTP::Date::str2time($_);
  	$_ = $t if $t;
      }
      wantarray ? @old : join(", ", @old);
  }
  
  
  # Split a list of entity tag values.  The return value is a list
  # consisting of one element per entity tag.  Suitable for parsing
  # headers like C<If-Match>, C<If-None-Match>.  You might even want to
  # use it on C<ETag> and C<If-Range> entity tag values, because it will
  # normalize them to the common form.
  #
  #  entity-tag	  = [ weak ] opaque-tag
  #  weak		  = "W/"
  #  opaque-tag	  = quoted-string
  
  
  sub _split_etag_list
  {
      my(@val) = @_;
      my @res;
      for (@val) {
          while (length) {
              my $weak = "";
  	    $weak = "W/" if s,^\s*[wW]/,,;
              my $etag = "";
  	    if (s/^\s*(\"[^\"\\]*(?:\\.[^\"\\]*)*\")//) {
  		push(@res, "$weak$1");
              }
              elsif (s/^\s*,//) {
                  push(@res, qq(W/"")) if $weak;
              }
              elsif (s/^\s*([^,\s]+)//) {
                  $etag = $1;
  		$etag =~ s/([\"\\])/\\$1/g;
  	        push(@res, qq($weak"$etag"));
              }
              elsif (s/^\s+// || !length) {
                  push(@res, qq(W/"")) if $weak;
              }
              else {
  	 	die "This should not happen: '$_'";
              }
          }
     }
     @res;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Headers::ETag
  
  =head1 VERSION
  
  version 6.44
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
HTTP_HEADERS_ETAG

    $fatpacked{"HTTP/Headers/Fast.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'HTTP_HEADERS_FAST';
  package HTTP::Headers::Fast;
  use strict;
  use warnings;
  use 5.00800;
  use Carp ();
  
  our $VERSION = '0.22';
  
  our $TRANSLATE_UNDERSCORE = 1;
  
  # "Good Practice" order of HTTP message headers:
  #    - General-Headers
  #    - Request-Headers
  #    - Response-Headers
  #    - Entity-Headers
  
  # yappo says "Readonly sucks".
  my $OP_GET    = 0;
  my $OP_SET    = 1;
  my $OP_INIT   = 2;
  my $OP_PUSH   = 3;
  
  my @general_headers = qw(
    Cache-Control Connection Date Pragma Trailer Transfer-Encoding Upgrade
    Via Warning
  );
  
  my @request_headers = qw(
    Accept Accept-Charset Accept-Encoding Accept-Language
    Authorization Expect From Host
    If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since
    Max-Forwards Proxy-Authorization Range Referer TE User-Agent
  );
  
  my @response_headers = qw(
    Accept-Ranges Age ETag Location Proxy-Authenticate Retry-After Server
    Vary WWW-Authenticate
  );
  
  my @entity_headers = qw(
    Allow Content-Encoding Content-Language Content-Length Content-Location
    Content-MD5 Content-Range Content-Type Expires Last-Modified
  );
  
  my %entity_header = map { lc($_) => 1 } @entity_headers;
  
  my @header_order =
    ( @general_headers, @request_headers, @response_headers, @entity_headers, );
  
  # Make alternative representations of @header_order.  This is used
  # for sorting and case matching.
  my %header_order;
  our %standard_case;
  
  {
      my $i = 0;
      for (@header_order) {
          my $lc = lc $_;
          $header_order{$lc}  = ++$i;
          $standard_case{$lc} = $_;
      }
  }
  
  sub new {
      my ($class) = shift;
      my $self = bless {}, $class;
      $self->header(@_) if @_;    # set up initial headers
      $self;
  }
  
  sub isa {
      my ($self, $klass) = @_;
      my $proto = ref $self || $self;
      return ($proto eq $klass || $klass eq 'HTTP::Headers') ? 1 : 0;
  }
  
  sub header {
      my $self = shift;
      Carp::croak('Usage: $h->header($field, ...)') unless @_;
      my (@old);
  
      if (@_ == 1) {
          @old = $self->_header_get(@_);
      } elsif( @_ == 2 ) {
          @old = $self->_header_set(@_);
      } else {
          my %seen;
          while (@_) {
              my $field = shift;
              if ( $seen{ lc $field }++ ) {
                  @old = $self->_header_push($field, shift);
              } else {
                  @old = $self->_header_set($field, shift);
              }
          }
      }
      return @old    if wantarray;
      return $old[0] if @old <= 1;
      join( ", ", @old );
  }
  
  sub clear {
      my $self = shift;
      %$self = ();
  }
  
  sub push_header {
      my $self = shift;
  
      if (@_ == 2) {
          my ($field, $val) = @_;
          $field = _standardize_field_name($field) unless $field =~ /^:/;
  
          my $h = $self->{$field};
          if (!defined $h) {
              $h = [];
              $self->{$field} = $h;
          } elsif (ref $h ne 'ARRAY') {
              $h = [ $h ];
              $self->{$field} = $h;
          }
      
          push @$h, ref $val ne 'ARRAY' ? $val : @$val;
      } else {
          while ( my ($field, $val) = splice( @_, 0, 2 ) ) {
              $field = _standardize_field_name($field) unless $field =~ /^:/;
  
              my $h = $self->{$field};
              if (!defined $h) {
                  $h = [];
                  $self->{$field} = $h;
              } elsif (ref $h ne 'ARRAY') {
                  $h = [ $h ];
                  $self->{$field} = $h;
              }
      
              push @$h, ref $val ne 'ARRAY' ? $val : @$val;
          }
      }
      return ();
  }
  
  sub init_header {
      Carp::croak('Usage: $h->init_header($field, $val)') if @_ != 3;
      shift->_header( @_, $OP_INIT );
  }
  
  sub remove_header {
      my ( $self, @fields ) = @_;
      my $field;
      my @values;
      for my $field (@fields) {
          $field =~ tr/_/-/ if $field !~ /^:/ && $TRANSLATE_UNDERSCORE;
          my $v = delete $self->{ lc $field };
          push( @values, ref($v) eq 'ARRAY' ? @$v : $v ) if defined $v;
      }
      return @values;
  }
  
  sub remove_content_headers {
      my $self = shift;
      unless ( defined(wantarray) ) {
  
          # fast branch that does not create return object
          delete @$self{ grep $entity_header{$_} || /^content-/, keys %$self };
          return;
      }
  
      my $c = ref($self)->new;
      for my $f ( grep $entity_header{$_} || /^content-/, keys %$self ) {
          $c->{$f} = delete $self->{$f};
      }
      $c;
  }
  
  my %field_name;
  sub _standardize_field_name {
      my $field = shift;
  
      $field =~ tr/_/-/ if $TRANSLATE_UNDERSCORE;
      if (my $cache = $field_name{$field}) {
          return $cache;
      }
  
      my $old = $field;
      $field = lc $field;
      unless ( defined $standard_case{$field} ) {
          # generate a %standard_case entry for this field
          $old =~ s/\b(\w)/\u$1/g;
          $standard_case{$field} = $old;
      }
      $field_name{$old} = $field;
      return $field;
  }
  
  sub _header_get {
      my ($self, $field, $skip_standardize) = @_;
  
      $field = _standardize_field_name($field) unless $skip_standardize || $field =~ /^:/;
  
      my $h = $self->{$field};
      return (ref($h) eq 'ARRAY') ? @$h : ( defined($h) ? ($h) : () );
  }
  
  sub _header_set {
      my ($self, $field, $val) = @_;
  
      $field = _standardize_field_name($field) unless $field =~ /^:/;
  
      my $h = $self->{$field};
      my @old = ref($h) eq 'ARRAY' ? @$h : ( defined($h) ? ($h) : () );
      if ( defined($val) ) {
          if (ref $val eq 'ARRAY' && scalar(@$val) == 1) {
              $val = $val->[0];
          }
          $self->{$field} = $val;
      } else {
          delete $self->{$field};
      }
      return @old;
  }
  
  sub _header_push {
      my ($self, $field, $val) = @_;
  
      $field = _standardize_field_name($field) unless $field =~ /^:/;
  
      my $h = $self->{$field};
      if (ref($h) eq 'ARRAY') {
          my @old = @$h;
          push @$h, ref $val ne 'ARRAY' ? $val : @$val;
          return @old;
      } elsif (defined $h) {
          $self->{$field} = [$h, ref $val ne 'ARRAY' ? $val : @$val ];
          return ($h);
      } else {
          $self->{$field} = ref $val ne 'ARRAY' ? $val : @$val;
          return ();
      }
  }
  
  sub _header {
      my ($self, $field, $val, $op) = @_;
  
      $field = _standardize_field_name($field) unless $field =~ /^:/;
  
      $op ||= defined($val) ? $OP_SET : $OP_GET;
  
      my $h = $self->{$field};
      my @old = ref($h) eq 'ARRAY' ? @$h : ( defined($h) ? ($h) : () );
  
      unless ( $op == $OP_GET || ( $op == $OP_INIT && @old ) ) {
          if ( defined($val) ) {
              my @new = ( $op == $OP_PUSH ) ? @old : ();
              if ( ref($val) ne 'ARRAY' ) {
                  push( @new, $val );
              }
              else {
                  push( @new, @$val );
              }
              $self->{$field} = @new > 1 ? \@new : $new[0];
          }
          elsif ( $op != $OP_PUSH ) {
              delete $self->{$field};
          }
      }
      @old;
  }
  
  sub _sorted_field_names {
      my $self = shift;
      return [ sort {
          ( $header_order{$a} || 999 ) <=> ( $header_order{$b} || 999 )
            || $a cmp $b
      } keys %$self ];
  }
  
  sub header_field_names {
      my $self = shift;
      return map $standard_case{$_} || $_, @{ $self->_sorted_field_names }
        if wantarray;
      return keys %$self;
  }
  
  sub scan {
      my ( $self, $sub ) = @_;
      for my $key (@{ $self->_sorted_field_names }) {
          next if substr($key, 0, 1) eq '_';
          my $vals = $self->{$key};
          if ( ref($vals) eq 'ARRAY' ) {
              for my $val (@$vals) {
                  $sub->( $standard_case{$key} || $key, $val );
              }
          }
          else {
              $sub->( $standard_case{$key} || $key, $vals );
          }
      }
  }
  
  sub _process_newline {
      local $_ = shift;
      my $endl = shift;
      # must handle header values with embedded newlines with care
      s/\s+$//;        # trailing newlines and space must go
      s/\n(\x0d?\n)+/\n/g;     # no empty lines
      s/\n([^\040\t])/\n $1/g; # intial space for continuation
      s/\n/$endl/g;    # substitute with requested line ending
      $_;
  }
  
  sub _as_string {
      my ($self, $endl, $fieldnames) = @_;
  
      my @result;
      for my $key ( @$fieldnames ) {
          next if index($key, '_') == 0;
          my $vals = $self->{$key};
          if ( ref($vals) eq 'ARRAY' ) {
              for my $val (@$vals) {
                  my $field = $standard_case{$key} || $key;
                  $field =~ s/^://;
                  if ( index($val, "\n") >= 0 ) {
                      $val = _process_newline($val, $endl);
                  }
                  push @result, $field . ': ' . $val;
              }
          } else {
              my $field = $standard_case{$key} || $key;
              $field =~ s/^://;
              if ( index($vals, "\n") >= 0 ) {
                  $vals = _process_newline($vals, $endl);
              }
              push @result, $field . ': ' . $vals;
          }
      }
  
      join( $endl, @result, '' );
  }
  
  sub as_string {
      my ( $self, $endl ) = @_;
      $endl = "\n" unless defined $endl;
      $self->_as_string($endl, $self->_sorted_field_names);
  }
  
  sub as_string_without_sort {
      my ( $self, $endl ) = @_;
      $endl = "\n" unless defined $endl;
      $self->_as_string($endl, [keys(%$self)]);
  }
  
  
  sub _psgi_flatten {
      my ($self, $keys) = @_;
      my @headers;
      for my $key ( @{$keys} ) {
          next if substr($key, 0, 1) eq '_';
          my $vals = $self->{$key};
          if ( ref($vals) eq 'ARRAY' ) {
              for my $val (@$vals) {
                  $val =~ s/\015\012[\040|\011]+/chr(32)/ge; # replace LWS with a single SP
                  $val =~ s/\015|\012//g; # remove CR and LF since the char is invalid here
                  push @headers, $standard_case{$key} || $key, $val;
              }
          }
          else {
              $vals =~ s/\015\012[\040|\011]+/chr(32)/ge; # replace LWS with a single SP
              $vals =~ s/\015|\012//g; # remove CR and LF since the char is invalid here
              push @headers, $standard_case{$key} || $key, $vals;
          }
      }
      return \@headers;
  }
  
  sub psgi_flatten {
      $_[0]->_psgi_flatten($_[0]->_sorted_field_names);
  }
  
  
  sub psgi_flatten_without_sort {
      $_[0]->_psgi_flatten([keys %{$_[0]}]);
  }
  
  {
      my $storable_required;
      sub clone {
          unless ($storable_required) {
              require Storable;
              $storable_required++;
          }
          goto &Storable::dclone;
      }
  }
  
  sub _date_header {
      require HTTP::Date;
      my ( $self, $header, $time ) = @_;
      my $old;
      if ( defined $time ) {
          ($old) = $self->_header_set( $header, HTTP::Date::time2str($time) );
      } else {
          ($old) = $self->_header_get($header, 1);
      }
      $old =~ s/;.*// if defined($old);
      HTTP::Date::str2time($old);
  }
  
  sub date                { shift->_date_header( 'date',                @_ ); }
  sub expires             { shift->_date_header( 'expires',             @_ ); }
  sub if_modified_since   { shift->_date_header( 'if-modified-since',   @_ ); }
  sub if_unmodified_since { shift->_date_header( 'if-unmodified-since', @_ ); }
  sub last_modified       { shift->_date_header( 'last-modified',       @_ ); }
  
  # This is used as a private LWP extension.  The Client-Date header is
  # added as a timestamp to a response when it has been received.
  sub client_date { shift->_date_header( 'client-date', @_ ); }
  
  # The retry_after field is dual format (can also be a expressed as
  # number of seconds from now), so we don't provide an easy way to
  # access it until we have know how both these interfaces can be
  # addressed.  One possibility is to return a negative value for
  # relative seconds and a positive value for epoch based time values.
  #sub retry_after       { shift->_date_header('Retry-After',       @_); }
  
  sub content_type {
      my $self = shift;
      my $ct   = $self->{'content-type'};
      $self->{'content-type'} = shift if @_;
      $ct = $ct->[0] if ref($ct) eq 'ARRAY';
      return '' unless defined($ct) && length($ct);
      my @ct = split( /;\s*/, $ct, 2 );
      for ( $ct[0] ) {
          s/\s+//g;
          $_ = lc($_);
      }
      wantarray ? @ct : $ct[0];
  }
  
  sub content_type_charset {
      my $self = shift;
      my $h = $self->{'content-type'};
      $h = $h->[0] if ref($h);
      $h = "" unless defined $h;
      my @v = _split_header_words($h);
      if (@v) {
  	my($ct, undef, %ct_param) = @{$v[0]};
  	my $charset = $ct_param{charset};
  	if ($ct) {
  	    $ct = lc($ct);
  	    $ct =~ s/\s+//;
  	}
  	if ($charset) {
  	    $charset = uc($charset);
  	    $charset =~ s/^\s+//;  $charset =~ s/\s+\z//;
  	    undef($charset) if $charset eq "";
  	}
  	return $ct, $charset if wantarray;
  	return $charset;
      }
      return undef, undef if wantarray;
      return undef;
  }
  
  sub _split_header_words
  {
      my(@val) = @_;
      my @res;
      for (@val) {
  	my @cur;
  	while (length) {
  	    if (s/^\s*(=*[^\s=;,]+)//) {  # 'token' or parameter 'attribute'
  		push(@cur, $1);
  		# a quoted value
  		if (s/^\s*=\s*\"([^\"\\]*(?:\\.[^\"\\]*)*)\"//) {
  		    my $val = $1;
  		    $val =~ s/\\(.)/$1/g;
  		    push(@cur, $val);
  		# some unquoted value
  		}
  		elsif (s/^\s*=\s*([^;,\s]*)//) {
  		    my $val = $1;
  		    $val =~ s/\s+$//;
  		    push(@cur, $val);
  		# no value, a lone token
  		}
  		else {
  		    push(@cur, undef);
  		}
  	    }
  	    elsif (s/^\s*,//) {
  		push(@res, [@cur]) if @cur;
  		@cur = ();
  	    }
  	    elsif (s/^\s*;// || s/^\s+//) {
  		# continue
  	    }
  	    else {
  		die "This should not happen: '$_'";
  	    }
  	}
  	push(@res, \@cur) if @cur;
      }
  
      for my $arr (@res) {
  	for (my $i = @$arr - 2; $i >= 0; $i -= 2) {
  	    $arr->[$i] = lc($arr->[$i]);
  	}
      }
      return @res;
  }
  
  sub content_is_text {
      my $self = shift;
      return $self->content_type =~ m,^text/,;
  }
  
  sub content_is_html {
      my $self = shift;
      return $self->content_type eq 'text/html' || $self->content_is_xhtml;
  }
  
  sub content_is_xhtml {
      my $ct = shift->content_type;
      return $ct eq "application/xhtml+xml"
        || $ct   eq "application/vnd.wap.xhtml+xml";
  }
  
  sub content_is_xml {
      my $ct = shift->content_type;
      return 1 if $ct eq "text/xml";
      return 1 if $ct eq "application/xml";
      return 1 if $ct =~ /\+xml$/;
      return 0;
  }
  
  sub referer {
      my $self = shift;
      if ( @_ && $_[0] =~ /#/ ) {
  
          # Strip fragment per RFC 2616, section 14.36.
          my $uri = shift;
          if ( ref($uri) ) {
              $uri = $uri->clone;
              $uri->fragment(undef);
          }
          else {
              $uri =~ s/\#.*//;
          }
          unshift @_, $uri;
      }
      ( $self->_header( 'Referer', @_ ) )[0];
  }
  *referrer = \&referer;    # on tchrist's request
  
  for my $key (qw/content-length content-language content-encoding title user-agent server from warnings www-authenticate authorization proxy-authenticate proxy-authorization/) {
      no strict 'refs';
      (my $meth = $key) =~ s/-/_/g;
      *{$meth} = sub {
          my $self = shift;
          if (@_) {
              ( $self->_header_set( $key, @_ ) )[0]
          } else {
              my $h = $self->{$key};
              (ref($h) eq 'ARRAY') ? $h->[0] : $h;
          }
      };
  }
  
  sub authorization_basic { shift->_basic_auth( "Authorization", @_ ) }
  sub proxy_authorization_basic {
      shift->_basic_auth( "Proxy-Authorization", @_ );
  }
  
  sub _basic_auth {
      require MIME::Base64;
      my ( $self, $h, $user, $passwd ) = @_;
      my ($old) = $self->_header($h);
      if ( defined $user ) {
          Carp::croak("Basic authorization user name can't contain ':'")
            if $user =~ /:/;
          $passwd = '' unless defined $passwd;
          $self->_header(
              $h => 'Basic ' . MIME::Base64::encode( "$user:$passwd", '' ) );
      }
      if ( defined $old && $old =~ s/^\s*Basic\s+// ) {
          my $val = MIME::Base64::decode($old);
          return $val unless wantarray;
          return split( /:/, $val, 2 );
      }
      return;
  }
  
  1;
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  HTTP::Headers::Fast - faster implementation of HTTP::Headers
  
  =head1 SYNOPSIS
  
    use HTTP::Headers::Fast;
    # and, same as HTTP::Headers.
  
  =head1 DESCRIPTION
  
  HTTP::Headers::Fast is a perl class for parsing/writing HTTP headers.
  
  The interface is same as HTTP::Headers.
  
  =head1 WHY YET ANOTHER ONE?
  
  HTTP::Headers is a very good. But I needed a faster implementation, fast  =)
  
  =head1 ADDITIONAL METHODS
  
  =over 4
  
  =item as_string_without_sort
  
  as_string method sorts the header names.But, sorting is bit slow.
  
  In this method, stringify the instance of HTTP::Headers::Fast without sorting.
  
  =item psgi_flatten
  
  returns PSGI compatible arrayref of header.
  
      my $headers:ArrayRef = $header->flatten
  
  =item psgi_flatten_without_sort
  
  same as flatten but returns arrayref without sorting.
  
  =back
  
  =head1 @ISA HACK
  
  If you want HTTP::Headers::Fast to pretend like it's really HTTP::Headers, you can try the following hack:
  
      unshift @HTTP::Headers::Fast::ISA, 'HTTP::Headers';
  
  =head1 BENCHMARK
  
      HTTP::Headers 5.818, HTTP::Headers::Fast 0.01
  
      -- push_header
              Rate orig fast
      orig 144928/s   -- -20%
      fast 181818/s  25%   --
  
      -- push_header_many
              Rate orig fast
      orig 74627/s   -- -16%
      fast 89286/s  20%   --
  
      -- get_date
              Rate orig fast
      orig 34884/s   -- -14%
      fast 40541/s  16%   --
  
      -- set_date
              Rate orig fast
      orig 21505/s   -- -19%
      fast 26525/s  23%   --
  
      -- scan
              Rate orig fast
      orig 57471/s   --  -1%
      fast 57803/s   1%   --
  
      -- get_header
              Rate orig fast
      orig 120337/s   -- -24%
      fast 157729/s  31%   --
  
      -- set_header
              Rate orig fast
      orig  79745/s   -- -30%
      fast 113766/s  43%   --
  
      -- get_content_length
              Rate orig fast
      orig 182482/s   -- -77%
      fast 793651/s 335%   --
  
      -- as_string
              Rate orig fast
      orig 23753/s   -- -41%
      fast 40161/s  69%   --
  
  =head1 AUTHOR
  
      Tokuhiro Matsuno E<lt>tokuhirom@gmail.comE<gt>
      Daisuke Maki
  
  And HTTP::Headers' originally written by Gisle Aas.
  
  =head1 THANKS TO
  
  Markstos
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
HTTP_HEADERS_FAST

    $fatpacked{"HTTP/Headers/Util.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'HTTP_HEADERS_UTIL';
  package HTTP::Headers::Util;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.44';
  
  use Exporter 5.57 'import';
  
  our @EXPORT_OK=qw(split_header_words _split_header_words join_header_words);
  
  
  sub split_header_words {
      my @res = &_split_header_words;
      for my $arr (@res) {
  	for (my $i = @$arr - 2; $i >= 0; $i -= 2) {
  	    $arr->[$i] = lc($arr->[$i]);
  	}
      }
      return @res;
  }
  
  sub _split_header_words
  {
      my(@val) = @_;
      my @res;
      for (@val) {
  	my @cur;
  	while (length) {
  	    if (s/^\s*(=*[^\s=;,]+)//) {  # 'token' or parameter 'attribute'
  		push(@cur, $1);
  		# a quoted value
  		if (s/^\s*=\s*\"([^\"\\]*(?:\\.[^\"\\]*)*)\"//) {
  		    my $val = $1;
  		    $val =~ s/\\(.)/$1/g;
  		    push(@cur, $val);
  		# some unquoted value
  		}
  		elsif (s/^\s*=\s*([^;,\s]*)//) {
  		    my $val = $1;
  		    $val =~ s/\s+$//;
  		    push(@cur, $val);
  		# no value, a lone token
  		}
  		else {
  		    push(@cur, undef);
  		}
  	    }
  	    elsif (s/^\s*,//) {
  		push(@res, [@cur]) if @cur;
  		@cur = ();
  	    }
  	    elsif (s/^\s*;// || s/^\s+// || s/^=//) {
  		# continue
  	    }
  	    else {
  		die "This should not happen: '$_'";
  	    }
  	}
  	push(@res, \@cur) if @cur;
      }
      @res;
  }
  
  
  sub join_header_words
  {
      @_ = ([@_]) if @_ && !ref($_[0]);
      my @res;
      for (@_) {
  	my @cur = @$_;
  	my @attr;
  	while (@cur) {
  	    my $k = shift @cur;
  	    my $v = shift @cur;
  	    if (defined $v) {
  		if ($v =~ /[\x00-\x20()<>@,;:\\\"\/\[\]?={}\x7F-\xFF]/ || !length($v)) {
  		    $v =~ s/([\"\\])/\\$1/g;  # escape " and \
  		    $k .= qq(="$v");
  		}
  		else {
  		    # token
  		    $k .= "=$v";
  		}
  	    }
  	    push(@attr, $k);
  	}
  	push(@res, join("; ", @attr)) if @attr;
      }
      join(", ", @res);
  }
  
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Headers::Util - Header value parsing utility functions
  
  =head1 VERSION
  
  version 6.44
  
  =head1 SYNOPSIS
  
    use HTTP::Headers::Util qw(split_header_words);
    @values = split_header_words($h->header("Content-Type"));
  
  =head1 DESCRIPTION
  
  This module provides a few functions that helps parsing and
  construction of valid HTTP header values.  None of the functions are
  exported by default.
  
  The following functions are available:
  
  =over 4
  
  =item split_header_words( @header_values )
  
  This function will parse the header values given as argument into a
  list of anonymous arrays containing key/value pairs.  The function
  knows how to deal with ",", ";" and "=" as well as quoted values after
  "=".  A list of space separated tokens are parsed as if they were
  separated by ";".
  
  If the @header_values passed as argument contains multiple values,
  then they are treated as if they were a single value separated by
  comma ",".
  
  This means that this function is useful for parsing header fields that
  follow this syntax (BNF as from the HTTP/1.1 specification, but we relax
  the requirement for tokens).
  
    headers           = #header
    header            = (token | parameter) *( [";"] (token | parameter))
  
    token             = 1*<any CHAR except CTLs or separators>
    separators        = "(" | ")" | "<" | ">" | "@"
                      | "," | ";" | ":" | "\" | <">
                      | "/" | "[" | "]" | "?" | "="
                      | "{" | "}" | SP | HT
  
    quoted-string     = ( <"> *(qdtext | quoted-pair ) <"> )
    qdtext            = <any TEXT except <">>
    quoted-pair       = "\" CHAR
  
    parameter         = attribute "=" value
    attribute         = token
    value             = token | quoted-string
  
  Each I<header> is represented by an anonymous array of key/value
  pairs.  The keys will be all be forced to lower case.
  The value for a simple token (not part of a parameter) is C<undef>.
  Syntactically incorrect headers will not necessarily be parsed as you
  would want.
  
  This is easier to describe with some examples:
  
     split_header_words('foo="bar"; port="80,81"; DISCARD, BAR=baz');
     split_header_words('text/html; charset="iso-8859-1"');
     split_header_words('Basic realm="\\"foo\\\\bar\\""');
  
  will return
  
     [foo=>'bar', port=>'80,81', discard=> undef], [bar=>'baz' ]
     ['text/html' => undef, charset => 'iso-8859-1']
     [basic => undef, realm => "\"foo\\bar\""]
  
  If you don't want the function to convert tokens and attribute keys to
  lower case you can call it as C<_split_header_words> instead (with a
  leading underscore).
  
  =item join_header_words( @arrays )
  
  This will do the opposite of the conversion done by split_header_words().
  It takes a list of anonymous arrays as arguments (or a list of
  key/value pairs) and produces a single header value.  Attribute values
  are quoted if needed.
  
  Example:
  
     join_header_words(["text/plain" => undef, charset => "iso-8859/1"]);
     join_header_words("text/plain" => undef, charset => "iso-8859/1");
  
  will both return the string:
  
     text/plain; charset="iso-8859/1"
  
  =back
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  #ABSTRACT: Header value parsing utility functions
  
HTTP_HEADERS_UTIL

    $fatpacked{"HTTP/Message.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'HTTP_MESSAGE';
  package HTTP::Message;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.44';
  
  require HTTP::Headers;
  require Carp;
  
  our $MAXIMUM_BODY_SIZE;
  
  my $CRLF = "\015\012";   # "\r\n" is not portable
  unless ($HTTP::URI_CLASS) {
      if ($ENV{PERL_HTTP_URI_CLASS}
      &&  $ENV{PERL_HTTP_URI_CLASS} =~ /^([\w:]+)$/) {
          $HTTP::URI_CLASS = $1;
      } else {
          $HTTP::URI_CLASS = "URI";
      }
  }
  eval "require $HTTP::URI_CLASS"; die $@ if $@;
  
  *_utf8_downgrade = defined(&utf8::downgrade) ?
      sub {
          utf8::downgrade($_[0], 1) or
              Carp::croak("HTTP::Message content must be bytes")
      }
      :
      sub {
      };
  
  sub new
  {
      my($class, $header, $content) = @_;
      if (defined $header) {
  	Carp::croak("Bad header argument") unless ref $header;
          if (ref($header) eq "ARRAY") {
  	    $header = HTTP::Headers->new(@$header);
  	}
  	else {
  	    $header = $header->clone;
  	}
      }
      else {
  	$header = HTTP::Headers->new;
      }
      if (defined $content) {
          _utf8_downgrade($content);
      }
      else {
          $content = '';
      }
  
      bless {
  	'_headers' => $header,
  	'_content' => $content,
  	'_max_body_size' => $HTTP::Message::MAXIMUM_BODY_SIZE,
      }, $class;
  }
  
  sub parse
  {
      my($class, $str) = @_;
  
      my @hdr;
      while (1) {
  	if ($str =~ s/^([^\s:]+)[ \t]*: ?(.*)\n?//) {
  	    push(@hdr, $1, $2);
  	    $hdr[-1] =~ s/\r\z//;
  	}
  	elsif (@hdr && $str =~ s/^([ \t].*)\n?//) {
  	    $hdr[-1] .= "\n$1";
  	    $hdr[-1] =~ s/\r\z//;
  	}
  	else {
  	    $str =~ s/^\r?\n//;
  	    last;
  	}
      }
      local $HTTP::Headers::TRANSLATE_UNDERSCORE;
      new($class, \@hdr, $str);
  }
  
  
  sub clone
  {
      my $self  = shift;
      my $clone = HTTP::Message->new($self->headers,
  				   $self->content);
      $clone->protocol($self->protocol);
      $clone;
  }
  
  
  sub clear {
      my $self = shift;
      $self->{_headers}->clear;
      $self->content("");
      delete $self->{_parts};
      return;
  }
  
  
  sub protocol {
      shift->_elem('_protocol',  @_);
  }
  
  sub headers {
      my $self = shift;
  
      # recalculation of _content might change headers, so we
      # need to force it now
      $self->_content unless exists $self->{_content};
  
      $self->{_headers};
  }
  
  sub headers_as_string {
      shift->headers->as_string(@_);
  }
  
  
  sub content  {
  
      my $self = $_[0];
      if (defined(wantarray)) {
  	$self->_content unless exists $self->{_content};
  	my $old = $self->{_content};
  	$old = $$old if ref($old) eq "SCALAR";
  	&_set_content if @_ > 1;
  	return $old;
      }
  
      if (@_ > 1) {
  	&_set_content;
      }
      else {
  	Carp::carp("Useless content call in void context") if $^W;
      }
  }
  
  
  sub _set_content {
      my $self = $_[0];
      _utf8_downgrade($_[1]);
      if (!ref($_[1]) && ref($self->{_content}) eq "SCALAR") {
  	${$self->{_content}} = defined( $_[1] ) ? $_[1] : '';
      }
      else {
  	die "Can't set content to be a scalar reference" if ref($_[1]) eq "SCALAR";
  	$self->{_content} = defined( $_[1] ) ? $_[1] : '';
  	delete $self->{_content_ref};
      }
      delete $self->{_parts} unless $_[2];
  }
  
  
  sub add_content
  {
      my $self = shift;
      $self->_content unless exists $self->{_content};
      my $chunkref = \$_[0];
      $chunkref = $$chunkref if ref($$chunkref);  # legacy
  
      _utf8_downgrade($$chunkref);
  
      my $ref = ref($self->{_content});
      if (!$ref) {
  	$self->{_content} .= $$chunkref;
      }
      elsif ($ref eq "SCALAR") {
  	${$self->{_content}} .= $$chunkref;
      }
      else {
  	Carp::croak("Can't append to $ref content");
      }
      delete $self->{_parts};
  }
  
  sub add_content_utf8 {
      my($self, $buf)  = @_;
      utf8::upgrade($buf);
      utf8::encode($buf);
      $self->add_content($buf);
  }
  
  sub content_ref
  {
      my $self = shift;
      $self->_content unless exists $self->{_content};
      delete $self->{_parts};
      my $old = \$self->{_content};
      my $old_cref = $self->{_content_ref};
      if (@_) {
  	my $new = shift;
  	Carp::croak("Setting content_ref to a non-ref") unless ref($new);
  	delete $self->{_content};  # avoid modifying $$old
  	$self->{_content} = $new;
  	$self->{_content_ref}++;
      }
      $old = $$old if $old_cref;
      return $old;
  }
  
  
  sub content_charset
  {
      my $self = shift;
      if (my $charset = $self->content_type_charset) {
  	return $charset;
      }
  
      # time to start guessing
      my $cref = $self->decoded_content(ref => 1, charset => "none");
  
      # Unicode BOM
      for ($$cref) {
  	return "UTF-8"     if /^\xEF\xBB\xBF/;
  	return "UTF-32LE" if /^\xFF\xFE\x00\x00/;
  	return "UTF-32BE" if /^\x00\x00\xFE\xFF/;
  	return "UTF-16LE" if /^\xFF\xFE/;
  	return "UTF-16BE" if /^\xFE\xFF/;
      }
  
      if ($self->content_is_xml) {
  	# http://www.w3.org/TR/2006/REC-xml-20060816/#sec-guessing
  	# XML entity not accompanied by external encoding information and not
  	# in UTF-8 or UTF-16 encoding must begin with an XML encoding declaration,
  	# in which the first characters must be '<?xml'
  	for ($$cref) {
  	    return "UTF-32BE" if /^\x00\x00\x00</;
  	    return "UTF-32LE" if /^<\x00\x00\x00/;
  	    return "UTF-16BE" if /^(?:\x00\s)*\x00</;
  	    return "UTF-16LE" if /^(?:\s\x00)*<\x00/;
  	    if (/^\s*(<\?xml[^\x00]*?\?>)/) {
  		if ($1 =~ /\sencoding\s*=\s*(["'])(.*?)\1/) {
  		    my $enc = $2;
  		    $enc =~ s/^\s+//; $enc =~ s/\s+\z//;
  		    return $enc if $enc;
  		}
  	    }
  	}
  	return "UTF-8";
      }
      elsif ($self->content_is_html) {
  	# look for <META charset="..."> or <META content="...">
  	# http://dev.w3.org/html5/spec/Overview.html#determining-the-character-encoding
  	require IO::HTML;
  	# Use relaxed search to match previous versions of HTTP::Message:
  	my $encoding = IO::HTML::find_charset_in($$cref, { encoding    => 1,
  	                                                   need_pragma => 0 });
  	return $encoding->mime_name if $encoding;
      }
      elsif ($self->content_type eq "application/json") {
  	for ($$cref) {
  	    # RFC 4627, ch 3
  	    return "UTF-32BE" if /^\x00\x00\x00./s;
  	    return "UTF-32LE" if /^.\x00\x00\x00/s;
  	    return "UTF-16BE" if /^\x00.\x00./s;
  	    return "UTF-16LE" if /^.\x00.\x00/s;
  	    return "UTF-8";
  	}
      }
      if ($self->content_type =~ /^text\//) {
  	for ($$cref) {
  	    if (length) {
  		return "US-ASCII" unless /[\x80-\xFF]/;
  		require Encode;
  		eval {
  		    Encode::decode_utf8($_, Encode::FB_CROAK() | Encode::LEAVE_SRC());
  		};
  		return "UTF-8" unless $@;
  		return "ISO-8859-1";
  	    }
  	}
      }
  
      return undef;
  }
  
  sub max_body_size  {
      my $self = $_[0];
      my $old = $self->{_max_body_size};
      $self->_set_max_body_size($_[1]) if @_ > 1;
      return $old;
  }
  
  sub _set_max_body_size {
      my $self = $_[0];
      $self->{_max_body_size} = $_[1];
  }
  
  sub decoded_content
  {
      my($self, %opt) = @_;
      my $content_ref;
      my $content_ref_iscopy;
  
      eval {
  	$content_ref = $self->content_ref;
  	die "Can't decode ref content" if ref($content_ref) ne "SCALAR";
  
  	my $content_limit = exists $opt{ max_body_size } ? $opt{ max_body_size }
  			: defined $self->max_body_size ? $self->max_body_size
  			: undef
  			;
  	my %limiter_options;
  	if( defined $content_limit ) {
  	    %limiter_options = (LimitOutput => 1, Bufsize => $content_limit);
  	};
  	if (my $h = $self->header("Content-Encoding")) {
  	    $h =~ s/^\s+//;
  	    $h =~ s/\s+$//;
  	    for my $ce (reverse split(/\s*,\s*/, lc($h))) {
  		next unless $ce;
  		next if $ce eq "identity" || $ce eq "none";
  		if ($ce eq "gzip" || $ce eq "x-gzip") {
  		    require Compress::Raw::Zlib; # 'WANT_GZIP_OR_ZLIB', 'Z_BUF_ERROR';
  
  		    if( ! $content_ref_iscopy and keys %limiter_options) {
  			# Create a copy of the input because Zlib will overwrite it
  			# :-(
  			my $input = "$$content_ref";
  			$content_ref = \$input;
  			$content_ref_iscopy++;
  		    };
  		    my ($i, $status) = Compress::Raw::Zlib::Inflate->new(
  			%limiter_options,
  			ConsumeInput => 0, # overridden by Zlib if we have %limiter_options :-(
  			WindowBits => Compress::Raw::Zlib::WANT_GZIP_OR_ZLIB(),
  		    );
  		    my $res = $i->inflate( $content_ref, \my $output );
  		    $res == Compress::Raw::Zlib::Z_BUF_ERROR()
  			and Carp::croak("Decoded content would be larger than $content_limit octets");
  		    $res == Compress::Raw::Zlib::Z_OK()
  		    or $res == Compress::Raw::Zlib::Z_STREAM_END()
  		    or die "Can't gunzip content: $res";
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq 'br') {
  		    require IO::Uncompress::Brotli;
  		    my $bro = IO::Uncompress::Brotli->create;
  
  		    my $output;
  		    if( defined $content_limit ) {
  			$output = eval { $bro->decompress( $$content_ref, $content_limit ); }
  		    } else {
  			$output = eval { $bro->decompress($$content_ref) };
  		    }
  
  		    $@ and die "Can't unbrotli content: $@";
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "x-bzip2" or $ce eq "bzip2") {
  		    require Compress::Raw::Bzip2;
  
  		    if( ! $content_ref_iscopy ) {
  			# Create a copy of the input because Bzlib2 will overwrite it
  			# :-(
  			my $input = "$$content_ref";
  			$content_ref = \$input;
  			$content_ref_iscopy++;
  		    };
  		    my ($i, $status) = Compress::Raw::Bunzip2->new(
  			1, # appendInput
  			0, # consumeInput
  			0, # small
  			$limiter_options{ LimitOutput } || 0,
  		    );
  		    my $output;
  		    $output = "\0" x $limiter_options{ Bufsize }
  			if $limiter_options{ Bufsize };
  		    my $res = $i->bzinflate( $content_ref, \$output );
  		    $res == Compress::Raw::Bzip2::BZ_OUTBUFF_FULL()
  			and Carp::croak("Decoded content would be larger than $content_limit octets");
  		    $res == Compress::Raw::Bzip2::BZ_OK()
  		    or $res == Compress::Raw::Bzip2::BZ_STREAM_END()
  			or die "Can't bunzip content: $res";
  			    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "deflate") {
  		    require IO::Uncompress::Inflate;
  		    my $output;
  		    my $status = IO::Uncompress::Inflate::inflate($content_ref, \$output, Transparent => 0);
  		    my $error = $IO::Uncompress::Inflate::InflateError;
  		    unless ($status) {
  			# "Content-Encoding: deflate" is supposed to mean the
  			# "zlib" format of RFC 1950, but Microsoft got that
  			# wrong, so some servers sends the raw compressed
  			# "deflate" data.  This tries to inflate this format.
  			$output = undef;
  			require IO::Uncompress::RawInflate;
  			unless (IO::Uncompress::RawInflate::rawinflate($content_ref, \$output)) {
  			    $self->push_header("Client-Warning" =>
  				"Could not raw inflate content: $IO::Uncompress::RawInflate::RawInflateError");
  			    $output = undef;
  			}
  		    }
  		    die "Can't inflate content: $error" unless defined $output;
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "compress" || $ce eq "x-compress") {
  		    die "Can't uncompress content";
  		}
  		elsif ($ce eq "base64") {  # not really C-T-E, but should be harmless
  		    require MIME::Base64;
  		    $content_ref = \MIME::Base64::decode($$content_ref);
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "quoted-printable") { # not really C-T-E, but should be harmless
  		    require MIME::QuotedPrint;
  		    $content_ref = \MIME::QuotedPrint::decode($$content_ref);
  		    $content_ref_iscopy++;
  		}
  		else {
  		    die "Don't know how to decode Content-Encoding '$ce'";
  		}
  	    }
  	}
  
  	if ($self->content_is_text || (my $is_xml = $self->content_is_xml)) {
  	    my $charset = lc(
  	        $opt{charset} ||
  		$self->content_type_charset ||
  		$opt{default_charset} ||
  		$self->content_charset ||
  		"ISO-8859-1"
  	    );
  	    if ($charset eq "none") {
  		# leave it as is
  	    }
  	    elsif ($charset eq "us-ascii" || $charset eq "iso-8859-1") {
  		if ($$content_ref =~ /[^\x00-\x7F]/ && defined &utf8::upgrade) {
  		    unless ($content_ref_iscopy) {
  			my $copy = $$content_ref;
  			$content_ref = \$copy;
  			$content_ref_iscopy++;
  		    }
  		    utf8::upgrade($$content_ref);
  		}
  	    }
  	    else {
  		require Encode;
  		eval {
  		    $content_ref = \Encode::decode($charset, $$content_ref,
  			 ($opt{charset_strict} ? Encode::FB_CROAK() : 0) | Encode::LEAVE_SRC());
  		};
  		if ($@) {
  		    my $retried;
  		    if ($@ =~ /^Unknown encoding/) {
  			my $alt_charset = lc($opt{alt_charset} || "");
  			if ($alt_charset && $charset ne $alt_charset) {
  			    # Retry decoding with the alternative charset
  			    $content_ref = \Encode::decode($alt_charset, $$content_ref,
  				 ($opt{charset_strict} ? Encode::FB_CROAK() : 0) | Encode::LEAVE_SRC())
  			        unless $alt_charset eq "none";
  			    $retried++;
  			}
  		    }
  		    die unless $retried;
  		}
  		die "Encode::decode() returned undef improperly" unless defined $$content_ref;
  		if ($is_xml) {
  		    # Get rid of the XML encoding declaration if present
  		    $$content_ref =~ s/^\x{FEFF}//;
  		    if ($$content_ref =~ /^(\s*<\?xml[^\x00]*?\?>)/) {
  			substr($$content_ref, 0, length($1)) =~ s/\sencoding\s*=\s*(["']).*?\1//;
  		    }
  		}
  	    }
  	}
      };
      if ($@) {
  	Carp::croak($@) if $opt{raise_error};
  	return undef;
      }
  
      return $opt{ref} ? $content_ref : $$content_ref;
  }
  
  
  sub decodable
  {
      # should match the Content-Encoding values that decoded_content can deal with
      my $self = shift;
      my @enc;
      local $@;
      # XXX preferably we should determine if the modules are available without loading
      # them here
      eval {
          require Compress::Raw::Zlib;
          push(@enc, "gzip", "x-gzip");
      };
      eval {
          require IO::Uncompress::Inflate;
          require IO::Uncompress::RawInflate;
          push(@enc, "deflate");
      };
      eval {
          require Compress::Raw::Bzip2;
          push(@enc, "x-bzip2", "bzip2");
      };
      eval {
          require IO::Uncompress::Brotli;
          push(@enc, 'br');
      };
      # we don't care about announcing the 'identity', 'base64' and
      # 'quoted-printable' stuff
      return wantarray ? @enc : join(", ", @enc);
  }
  
  
  sub decode
  {
      my $self = shift;
      return 1 unless $self->header("Content-Encoding");
      if (defined(my $content = $self->decoded_content(charset => "none"))) {
  	$self->remove_header("Content-Encoding", "Content-Length", "Content-MD5");
  	$self->content($content);
  	return 1;
      }
      return 0;
  }
  
  
  sub encode
  {
      my($self, @enc) = @_;
  
      Carp::croak("Can't encode multipart/* messages") if $self->content_type =~ m,^multipart/,;
      Carp::croak("Can't encode message/* messages") if $self->content_type =~ m,^message/,;
  
      return 1 unless @enc;  # nothing to do
  
      my $content = $self->content;
      for my $encoding (@enc) {
  	if ($encoding eq "identity" || $encoding eq "none") {
  	    # nothing to do
  	}
  	elsif ($encoding eq "base64") {
  	    require MIME::Base64;
  	    $content = MIME::Base64::encode($content);
  	}
  	elsif ($encoding eq "gzip" || $encoding eq "x-gzip") {
  	    require IO::Compress::Gzip;
  	    my $output;
  	    IO::Compress::Gzip::gzip(\$content, \$output, Minimal => 1)
  		or die "Can't gzip content: $IO::Compress::Gzip::GzipError";
  	    $content = $output;
  	}
  	elsif ($encoding eq "deflate") {
  	    require IO::Compress::Deflate;
  	    my $output;
  	    IO::Compress::Deflate::deflate(\$content, \$output)
  		or die "Can't deflate content: $IO::Compress::Deflate::DeflateError";
  	    $content = $output;
  	}
  	elsif ($encoding eq "x-bzip2" || $encoding eq "bzip2") {
  	    require IO::Compress::Bzip2;
  	    my $output;
  	    IO::Compress::Bzip2::bzip2(\$content, \$output)
  		or die "Can't bzip2 content: $IO::Compress::Bzip2::Bzip2Error";
  	    $content = $output;
  	}
  	elsif ($encoding eq "br") {
  		require IO::Compress::Brotli;
  		my $output;
  		eval { $output = IO::Compress::Brotli::bro($content) }
  		or die "Can't brotli content: $@";
  		$content = $output;
  	}
  	elsif ($encoding eq "rot13") {  # for the fun of it
  	    $content =~ tr/A-Za-z/N-ZA-Mn-za-m/;
  	}
  	else {
  	    return 0;
  	}
      }
      my $h = $self->header("Content-Encoding");
      unshift(@enc, $h) if $h;
      $self->header("Content-Encoding", join(", ", @enc));
      $self->remove_header("Content-Length", "Content-MD5");
      $self->content($content);
      return 1;
  }
  
  
  sub as_string
  {
      my($self, $eol) = @_;
      $eol = "\n" unless defined $eol;
  
      # The calculation of content might update the headers
      # so we need to do that first.
      my $content = $self->content;
  
      return join("", $self->{'_headers'}->as_string($eol),
  		    $eol,
  		    $content,
  		    (@_ == 1 && length($content) &&
  		     $content !~ /\n\z/) ? "\n" : "",
  		);
  }
  
  
  sub dump
  {
      my($self, %opt) = @_;
      my $content = $self->content;
      my $chopped = 0;
      if (!ref($content)) {
  	my $maxlen = $opt{maxlength};
  	$maxlen = 512 unless defined($maxlen);
  	if ($maxlen && length($content) > $maxlen * 1.1 + 3) {
  	    $chopped = length($content) - $maxlen;
  	    $content = substr($content, 0, $maxlen) . "...";
  	}
  
  	$content =~ s/\\/\\\\/g;
  	$content =~ s/\t/\\t/g;
  	$content =~ s/\r/\\r/g;
  
  	# no need for 3 digits in escape for these
  	$content =~ s/([\0-\11\13-\037])(?!\d)/sprintf('\\%o',ord($1))/eg;
  
  	$content =~ s/([\0-\11\13-\037\177-\377])/sprintf('\\x%02X',ord($1))/eg;
  	$content =~ s/([^\12\040-\176])/sprintf('\\x{%X}',ord($1))/eg;
  
  	# remaining whitespace
  	$content =~ s/( +)\n/("\\40" x length($1)) . "\n"/eg;
  	$content =~ s/(\n+)\n/("\\n" x length($1)) . "\n"/eg;
  	$content =~ s/\n\z/\\n/;
  
  	my $no_content = $opt{no_content};
  	$no_content = "(no content)" unless defined $no_content;
  	if ($content eq $no_content) {
  	    # escape our $no_content marker
  	    $content =~ s/^(.)/sprintf('\\x%02X',ord($1))/eg;
  	}
  	elsif ($content eq "") {
  	    $content = $no_content;
  	}
      }
  
      my @dump;
      push(@dump, $opt{preheader}) if $opt{preheader};
      push(@dump, $self->{_headers}->as_string, $content);
      push(@dump, "(+ $chopped more bytes not shown)") if $chopped;
  
      my $dump = join("\n", @dump, "");
      $dump =~ s/^/$opt{prefix}/gm if $opt{prefix};
  
      print $dump unless defined wantarray;
      return $dump;
  }
  
  # allow subclasses to override what will handle individual parts
  sub _part_class {
      return __PACKAGE__;
  }
  
  sub parts {
      my $self = shift;
      if (defined(wantarray) && (!exists $self->{_parts} || ref($self->{_content}) eq "SCALAR")) {
  	$self->_parts;
      }
      my $old = $self->{_parts};
      if (@_) {
  	my @parts = map { ref($_) eq 'ARRAY' ? @$_ : $_ } @_;
  	my $ct = $self->content_type || "";
  	if ($ct =~ m,^message/,) {
  	    Carp::croak("Only one part allowed for $ct content")
  		if @parts > 1;
  	}
  	elsif ($ct !~ m,^multipart/,) {
  	    $self->remove_content_headers;
  	    $self->content_type("multipart/mixed");
  	}
  	$self->{_parts} = \@parts;
  	_stale_content($self);
      }
      return @$old if wantarray;
      return $old->[0];
  }
  
  sub add_part {
      my $self = shift;
      if (($self->content_type || "") !~ m,^multipart/,) {
  	my $p = $self->_part_class->new(
  	    $self->remove_content_headers,
  	    $self->content(""),
  	);
  	$self->content_type("multipart/mixed");
  	$self->{_parts} = [];
          if ($p->headers->header_field_names || $p->content ne "") {
              push(@{$self->{_parts}}, $p);
          }
      }
      elsif (!exists $self->{_parts} || ref($self->{_content}) eq "SCALAR") {
  	$self->_parts;
      }
  
      push(@{$self->{_parts}}, @_);
      _stale_content($self);
      return;
  }
  
  sub _stale_content {
      my $self = shift;
      if (ref($self->{_content}) eq "SCALAR") {
  	# must recalculate now
  	$self->_content;
      }
      else {
  	# just invalidate cache
  	delete $self->{_content};
  	delete $self->{_content_ref};
      }
  }
  
  # delegate all other method calls to the headers object.
  our $AUTOLOAD;
  
  sub AUTOLOAD {
      my ( $package, $method ) = $AUTOLOAD =~ m/\A(.+)::([^:]*)\z/;
      my $code = $_[0]->can($method);
      Carp::croak(
          qq(Can't locate object method "$method" via package "$package"))
          unless $code;
      goto &$code;
  }
  
  sub can {
      my ( $self, $method ) = @_;
  
      if ( my $own_method = $self->SUPER::can($method) ) {
          return $own_method;
      }
  
      my $headers = ref($self) ? $self->headers : 'HTTP::Headers';
      if ( $headers->can($method) ) {
  
          # We create the function here so that it will not need to be
          # autoloaded or recreated the next time.
          no strict 'refs';
          *$method = sub {
              local $Carp::Internal{ +__PACKAGE__ } = 1;
              shift->headers->$method(@_);
          };
          return \&$method;
      }
  
      return undef;
  }
  
  sub DESTROY { }    # avoid AUTOLOADing it
  
  # Private method to access members in %$self
  sub _elem
  {
      my $self = shift;
      my $elem = shift;
      my $old = $self->{$elem};
      $self->{$elem} = $_[0] if @_;
      return $old;
  }
  
  
  # Create private _parts attribute from current _content
  sub _parts {
      my $self = shift;
      my $ct = $self->content_type;
      if ($ct =~ m,^multipart/,) {
  	require HTTP::Headers::Util;
  	my @h = HTTP::Headers::Util::split_header_words($self->header("Content-Type"));
  	die "Assert" unless @h;
  	my %h = @{$h[0]};
  	if (defined(my $b = $h{boundary})) {
  	    my $str = $self->content;
  	    $str =~ s/\r?\n--\Q$b\E--.*//s;
  	    if ($str =~ s/(^|.*?\r?\n)--\Q$b\E\r?\n//s) {
  		$self->{_parts} = [map $self->_part_class->parse($_),
  				   split(/\r?\n--\Q$b\E\r?\n/, $str)]
  	    }
  	}
      }
      elsif ($ct eq "message/http") {
  	require HTTP::Request;
  	require HTTP::Response;
  	my $content = $self->content;
  	my $class = ($content =~ m,^(HTTP/.*)\n,) ?
  	    "HTTP::Response" : "HTTP::Request";
  	$self->{_parts} = [$class->parse($content)];
      }
      elsif ($ct =~ m,^message/,) {
  	$self->{_parts} = [ $self->_part_class->parse($self->content) ];
      }
  
      $self->{_parts} ||= [];
  }
  
  
  # Create private _content attribute from current _parts
  sub _content {
      my $self = shift;
      my $ct = $self->{_headers}->header("Content-Type") || "multipart/mixed";
      if ($ct =~ m,^\s*message/,i) {
  	_set_content($self, $self->{_parts}[0]->as_string($CRLF), 1);
  	return;
      }
  
      require HTTP::Headers::Util;
      my @v = HTTP::Headers::Util::split_header_words($ct);
      Carp::carp("Multiple Content-Type headers") if @v > 1;
      @v = @{$v[0]};
  
      my $boundary;
      my $boundary_index;
      for (my @tmp = @v; @tmp;) {
  	my($k, $v) = splice(@tmp, 0, 2);
  	if ($k eq "boundary") {
  	    $boundary = $v;
  	    $boundary_index = @v - @tmp - 1;
  	    last;
  	}
      }
  
      my @parts = map $_->as_string($CRLF), @{$self->{_parts}};
  
      my $bno = 0;
      $boundary = _boundary() unless defined $boundary;
   CHECK_BOUNDARY:
      {
  	for (@parts) {
  	    if (index($_, $boundary) >= 0) {
  		# must have a better boundary
  		$boundary = _boundary(++$bno);
  		redo CHECK_BOUNDARY;
  	    }
  	}
      }
  
      if ($boundary_index) {
  	$v[$boundary_index] = $boundary;
      }
      else {
  	push(@v, boundary => $boundary);
      }
  
      $ct = HTTP::Headers::Util::join_header_words(@v);
      $self->{_headers}->header("Content-Type", $ct);
  
      _set_content($self, "--$boundary$CRLF" .
  	                join("$CRLF--$boundary$CRLF", @parts) .
  			"$CRLF--$boundary--$CRLF",
                          1);
  }
  
  
  sub _boundary
  {
      my $size = shift || return "xYzZY";
      require MIME::Base64;
      my $b = MIME::Base64::encode(join("", map chr(rand(256)), 1..$size*3), "");
      $b =~ s/[\W]/X/g;  # ensure alnum only
      $b;
  }
  
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Message - HTTP style message (base class)
  
  =head1 VERSION
  
  version 6.44
  
  =head1 SYNOPSIS
  
   use parent 'HTTP::Message';
  
  =head1 DESCRIPTION
  
  An C<HTTP::Message> object contains some headers and a content body.
  The following methods are available:
  
  =over 4
  
  =item $mess = HTTP::Message->new
  
  =item $mess = HTTP::Message->new( $headers )
  
  =item $mess = HTTP::Message->new( $headers, $content )
  
  This constructs a new message object.  Normally you would want
  construct C<HTTP::Request> or C<HTTP::Response> objects instead.
  
  The optional $header argument should be a reference to an
  C<HTTP::Headers> object or a plain array reference of key/value pairs.
  If an C<HTTP::Headers> object is provided then a copy of it will be
  embedded into the constructed message, i.e. it will not be owned and
  can be modified afterwards without affecting the message.
  
  The optional $content argument should be a string of bytes.
  
  =item $mess = HTTP::Message->parse( $str )
  
  This constructs a new message object by parsing the given string.
  
  =item $mess->headers
  
  Returns the embedded C<HTTP::Headers> object.
  
  =item $mess->headers_as_string
  
  =item $mess->headers_as_string( $eol )
  
  Call the as_string() method for the headers in the
  message.  This will be the same as
  
      $mess->headers->as_string
  
  but it will make your program a whole character shorter :-)
  
  =item $mess->content
  
  =item $mess->content( $bytes )
  
  The content() method sets the raw content if an argument is given.  If no
  argument is given the content is not touched.  In either case the
  original raw content is returned.
  
  If the C<undef> argument is given, the content is reset to its default value,
  which is an empty string.
  
  Note that the content should be a string of bytes.  Strings in perl
  can contain characters outside the range of a byte.  The C<Encode>
  module can be used to turn such strings into a string of bytes.
  
  =item $mess->add_content( $bytes )
  
  The add_content() methods appends more data bytes to the end of the
  current content buffer.
  
  =item $mess->add_content_utf8( $string )
  
  The add_content_utf8() method appends the UTF-8 bytes representing the
  string to the end of the current content buffer.
  
  =item $mess->content_ref
  
  =item $mess->content_ref( \$bytes )
  
  The content_ref() method will return a reference to content buffer string.
  It can be more efficient to access the content this way if the content
  is huge, and it can even be used for direct manipulation of the content,
  for instance:
  
    ${$res->content_ref} =~ s/\bfoo\b/bar/g;
  
  This example would modify the content buffer in-place.
  
  If an argument is passed it will setup the content to reference some
  external source.  The content() and add_content() methods
  will automatically dereference scalar references passed this way.  For
  other references content() will return the reference itself and
  add_content() will refuse to do anything.
  
  =item $mess->content_charset
  
  This returns the charset used by the content in the message.  The
  charset is either found as the charset attribute of the
  C<Content-Type> header or by guessing.
  
  See L<http://www.w3.org/TR/REC-html40/charset.html#spec-char-encoding>
  for details about how charset is determined.
  
  =item $mess->decoded_content( %options )
  
  Returns the content with any C<Content-Encoding> undone and, for textual content
  (C<Content-Type> values starting with C<text/>, exactly matching
  C<application/xml>, or ending with C<+xml>), the raw content's character set
  decoded into Perl's Unicode string format. Note that this
  L<does not currently|https://github.com/libwww-perl/HTTP-Message/pull/99>
  attempt to decode declared character sets for any other content types like
  C<application/json> or C<application/javascript>.  If the C<Content-Encoding>
  or C<charset> of the message is unknown, this method will fail by returning
  C<undef>.
  
  The following options can be specified.
  
  =over
  
  =item C<charset>
  
  This overrides the charset parameter for text content.  The value
  C<none> can used to suppress decoding of the charset.
  
  =item C<default_charset>
  
  This overrides the default charset guessed by content_charset() or
  if that fails "ISO-8859-1".
  
  =item C<alt_charset>
  
  If decoding fails because the charset specified in the Content-Type header
  isn't recognized by Perl's Encode module, then try decoding using this charset
  instead of failing.  The C<alt_charset> might be specified as C<none> to simply
  return the string without any decoding of charset as alternative.
  
  =item C<charset_strict>
  
  Abort decoding if malformed characters is found in the content.  By
  default you get the substitution character ("\x{FFFD}") in place of
  malformed characters.
  
  =item C<raise_error>
  
  If TRUE then raise an exception if not able to decode content.  Reason
  might be that the specified C<Content-Encoding> or C<charset> is not
  supported.  If this option is FALSE, then decoded_content() will return
  C<undef> on errors, but will still set $@.
  
  =item C<ref>
  
  If TRUE then a reference to decoded content is returned.  This might
  be more efficient in cases where the decoded content is identical to
  the raw content as no data copying is required in this case.
  
  =back
  
  =item $mess->decodable
  
  =item HTTP::Message::decodable()
  
  This returns the encoding identifiers that decoded_content() can
  process.  In scalar context returns a comma separated string of
  identifiers.
  
  This value is suitable for initializing the C<Accept-Encoding> request
  header field.
  
  =item $mess->decode
  
  This method tries to replace the content of the message with the
  decoded version and removes the C<Content-Encoding> header.  Returns
  TRUE if successful and FALSE if not.
  
  If the message does not have a C<Content-Encoding> header this method
  does nothing and returns TRUE.
  
  Note that the content of the message is still bytes after this method
  has been called and you still need to call decoded_content() if you
  want to process its content as a string.
  
  =item $mess->encode( $encoding, ... )
  
  Apply the given encodings to the content of the message.  Returns TRUE
  if successful. The "identity" (non-)encoding is always supported; other
  currently supported encodings, subject to availability of required
  additional modules, are "gzip", "deflate", "x-bzip2", "base64" and "br".
  
  A successful call to this function will set the C<Content-Encoding>
  header.
  
  Note that C<multipart/*> or C<message/*> messages can't be encoded and
  this method will croak if you try.
  
  =item $mess->parts
  
  =item $mess->parts( @parts )
  
  =item $mess->parts( \@parts )
  
  Messages can be composite, i.e. contain other messages.  The composite
  messages have a content type of C<multipart/*> or C<message/*>.  This
  method give access to the contained messages.
  
  The argumentless form will return a list of C<HTTP::Message> objects.
  If the content type of $msg is not C<multipart/*> or C<message/*> then
  this will return the empty list.  In scalar context only the first
  object is returned.  The returned message parts should be regarded as
  read-only (future versions of this library might make it possible
  to modify the parent by modifying the parts).
  
  If the content type of $msg is C<message/*> then there will only be
  one part returned.
  
  If the content type is C<message/http>, then the return value will be
  either an C<HTTP::Request> or an C<HTTP::Response> object.
  
  If a @parts argument is given, then the content of the message will be
  modified. The array reference form is provided so that an empty list
  can be provided.  The @parts array should contain C<HTTP::Message>
  objects.  The @parts objects are owned by $mess after this call and
  should not be modified or made part of other messages.
  
  When updating the message with this method and the old content type of
  $mess is not C<multipart/*> or C<message/*>, then the content type is
  set to C<multipart/mixed> and all other content headers are cleared.
  
  This method will croak if the content type is C<message/*> and more
  than one part is provided.
  
  =item $mess->add_part( $part )
  
  This will add a part to a message.  The $part argument should be
  another C<HTTP::Message> object.  If the previous content type of
  $mess is not C<multipart/*> then the old content (together with all
  content headers) will be made part #1 and the content type made
  C<multipart/mixed> before the new part is added.  The $part object is
  owned by $mess after this call and should not be modified or made part
  of other messages.
  
  There is no return value.
  
  =item $mess->clear
  
  Will clear the headers and set the content to the empty string.  There
  is no return value
  
  =item $mess->protocol
  
  =item $mess->protocol( $proto )
  
  Sets the HTTP protocol used for the message.  The protocol() is a string
  like C<HTTP/1.0> or C<HTTP/1.1>.
  
  =item $mess->clone
  
  Returns a copy of the message object.
  
  =item $mess->as_string
  
  =item $mess->as_string( $eol )
  
  Returns the message formatted as a single string.
  
  The optional $eol parameter specifies the line ending sequence to use.
  The default is "\n".  If no $eol is given then as_string will ensure
  that the returned string is newline terminated (even when the message
  content is not).  No extra newline is appended if an explicit $eol is
  passed.
  
  =item $mess->dump( %opt )
  
  Returns the message formatted as a string.  In void context print the string.
  
  This differs from C<< $mess->as_string >> in that it escapes the bytes
  of the content so that it's safe to print them and it limits how much
  content to print.  The escapes syntax used is the same as for Perl's
  double quoted strings.  If there is no content the string "(no
  content)" is shown in its place.
  
  Options to influence the output can be passed as key/value pairs. The
  following options are recognized:
  
  =over
  
  =item maxlength => $num
  
  How much of the content to show.  The default is 512.  Set this to 0
  for unlimited.
  
  If the content is longer then the string is chopped at the limit and
  the string "...\n(### more bytes not shown)" appended.
  
  =item no_content => $str
  
  Replaces the "(no content)" marker.
  
  =item prefix => $str
  
  A string that will be prefixed to each line of the dump.
  
  =back
  
  =back
  
  All methods unknown to C<HTTP::Message> itself are delegated to the
  C<HTTP::Headers> object that is part of every message.  This allows
  convenient access to these methods.  Refer to L<HTTP::Headers> for
  details of these methods:
  
      $mess->header( $field => $val )
      $mess->push_header( $field => $val )
      $mess->init_header( $field => $val )
      $mess->remove_header( $field )
      $mess->remove_content_headers
      $mess->header_field_names
      $mess->scan( \&doit )
  
      $mess->date
      $mess->expires
      $mess->if_modified_since
      $mess->if_unmodified_since
      $mess->last_modified
      $mess->content_type
      $mess->content_encoding
      $mess->content_length
      $mess->content_language
      $mess->title
      $mess->user_agent
      $mess->server
      $mess->from
      $mess->referer
      $mess->www_authenticate
      $mess->authorization
      $mess->proxy_authorization
      $mess->authorization_basic
      $mess->proxy_authorization_basic
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  #ABSTRACT: HTTP style message (base class)
  
HTTP_MESSAGE

    $fatpacked{"HTTP/Message/PSGI.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'HTTP_MESSAGE_PSGI';
  package HTTP::Message::PSGI;
  use strict;
  use warnings;
  use parent qw(Exporter);
  our @EXPORT = qw( req_to_psgi res_from_psgi );
  
  use Carp ();
  use HTTP::Status qw(status_message);
  use URI::Escape ();
  use Plack::Util;
  use Try::Tiny;
  
  my $TRUE  = (1 == 1);
  my $FALSE = !$TRUE;
  
  sub req_to_psgi {
      my $req = shift;
  
      unless (try { $req->isa('HTTP::Request') }) {
          Carp::croak("Request is not HTTP::Request: $req");
      }
  
      # from HTTP::Request::AsCGI
      my $host = $req->header('Host');
      my $uri  = $req->uri->clone;
      $uri->scheme('http')    unless $uri->scheme;
      $uri->host('localhost') unless $uri->host;
      $uri->port(80)          unless $uri->port;
      $uri->host_port($host)  unless !$host || ( $host eq $uri->host_port );
  
      my $input;
      my $content = $req->content;
      if (ref $content eq 'CODE') {
          if (defined $req->content_length) {
              $input = HTTP::Message::PSGI::ChunkedInput->new($content);
          } else {
              $req->header("Transfer-Encoding" => "chunked");
              $input = HTTP::Message::PSGI::ChunkedInput->new($content, 1);
          }
      } else {
          open $input, "<", \$content;
          $req->content_length(length $content)
              unless defined $req->content_length;
      }
  
      my $env = {
          PATH_INFO         => URI::Escape::uri_unescape($uri->path || '/'),
          QUERY_STRING      => $uri->query || '',
          SCRIPT_NAME       => '',
          SERVER_NAME       => $uri->host,
          SERVER_PORT       => $uri->port,
          SERVER_PROTOCOL   => $req->protocol || 'HTTP/1.1',
          REMOTE_ADDR       => '127.0.0.1',
          REMOTE_HOST       => 'localhost',
          REMOTE_PORT       => int( rand(64000) + 1000 ),                   # not in RFC 3875
          REQUEST_URI       => $uri->path_query || '/',                     # not in RFC 3875
          REQUEST_METHOD    => $req->method,
          'psgi.version'      => [ 1, 1 ],
          'psgi.url_scheme'   => $uri->scheme eq 'https' ? 'https' : 'http',
          'psgi.input'        => $input,
          'psgi.errors'       => *STDERR,
          'psgi.multithread'  => $FALSE,
          'psgi.multiprocess' => $FALSE,
          'psgi.run_once'     => $TRUE,
          'psgi.streaming'    => $TRUE,
          'psgi.nonblocking'  => $FALSE,
          @_,
      };
  
      for my $field ( $req->headers->header_field_names ) {
          my $key = uc("HTTP_$field");
          $key =~ tr/-/_/;
          $key =~ s/^HTTP_// if $field =~ /^Content-(Length|Type)$/;
  
          unless ( exists $env->{$key} ) {
              $env->{$key} = $req->headers->header($field);
          }
      }
  
      if ($env->{SCRIPT_NAME}) {
          $env->{PATH_INFO} =~ s/^\Q$env->{SCRIPT_NAME}\E/\//;
          $env->{PATH_INFO} =~ s/^\/+/\//;
      }
  
      if (!defined($env->{HTTP_HOST}) && $req->uri->can('host')) {
          $env->{HTTP_HOST} = $req->uri->host;
          $env->{HTTP_HOST} .= ':' . $req->uri->port
              if $req->uri->port ne $req->uri->default_port;
      }
  
      return $env;
  }
  
  sub res_from_psgi {
      my ($psgi_res) = @_;
  
      require HTTP::Response;
  
      my $res;
      if (ref $psgi_res eq 'ARRAY') {
          _res_from_psgi($psgi_res, \$res);
      } elsif (ref $psgi_res eq 'CODE') {
          $psgi_res->(sub {
              _res_from_psgi($_[0], \$res);
          });
      } else {
          Carp::croak("Bad response: ", defined $psgi_res ? $psgi_res : 'undef');
      }
  
      return $res;
  }
  
  sub _res_from_psgi {
      my ($status, $headers, $body) = @{+shift};
      my $res_ref = shift;
  
      my $convert_resp = sub {
          my $res = HTTP::Response->new($status);
          $res->message(status_message($status));
          $res->headers->header(@$headers) if @$headers;
  
          if (ref $body eq 'ARRAY') {
              $res->content(join '', grep defined, @$body);
          } else {
              local $/ = \4096;
              my $content = '';
              while (defined(my $buf = $body->getline)) {
                  $content .= $buf;
              }
              $body->close;
              $res->content($content);
          }
  
          ${ $res_ref } = $res;
  
          return;
      };
  
      if (!defined $body) {
          $body = [];
          my $o = Plack::Util::inline_object
              write => sub { push @$body, @_ },
              close => $convert_resp;
  
          return $o;
      }
  
      $convert_resp->();
  }
  
  sub HTTP::Request::to_psgi {
      req_to_psgi(@_);
  }
  
  sub HTTP::Response::from_psgi {
      my $class = shift;
      res_from_psgi(@_);
  }
  
  package
      HTTP::Message::PSGI::ChunkedInput;
  
  sub new {
      my($class, $content, $chunked) = @_;
  
      my $content_cb;
      if ($chunked) {
          my $done;
          $content_cb = sub {
              my $chunk = $content->();
              return if $done;
              unless (defined $chunk) {
                  $done = 1;
                  return "0\015\012\015\012";
              }
              return '' unless length $chunk;
              return sprintf('%x', length $chunk) . "\015\012$chunk\015\012";
          };
      } else {
          $content_cb = $content;
      }
  
      bless { content => $content_cb }, $class;
  }
  
  sub read {
      my $self = shift;
  
      my $chunk = $self->{content}->();
      return 0 unless defined $chunk;
  
      $_[0] = '';
      substr($_[0], $_[2] || 0, length $chunk) = $chunk;
  
      return length $chunk;
  }
  
  sub close { }
  
  package HTTP::Message::PSGI;
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Message::PSGI - Converts HTTP::Request and HTTP::Response from/to PSGI env and response
  
  =head1 SYNOPSIS
  
    use HTTP::Message::PSGI;
  
    # $req is HTTP::Request, $res is HTTP::Response
    my $env = req_to_psgi($req);
    my $res = res_from_psgi([ $status, $headers, $body ]);
  
    # Adds methods to HTTP::Request/Response class as well
    my $env = $req->to_psgi;
    my $res = HTTP::Response->from_psgi([ $status, $headers, $body ]);
  
  =head1 DESCRIPTION
  
  HTTP::Message::PSGI gives you convenient methods to convert an L<HTTP::Request>
  object to a PSGI env hash and convert a PSGI response arrayref to
  a L<HTTP::Response> object.
  
  If you want the other way around, see L<Plack::Request> and
  L<Plack::Response>.
  
  =head1 METHODS
  
  =over 4
  
  =item req_to_psgi
  
    my $env = req_to_psgi($req [, $key => $val ... ]);
  
  Converts a L<HTTP::Request> object into a PSGI env hash reference.
  
  =item HTTP::Request::to_psgi
  
    my $env = $req->to_psgi;
  
  Same as C<req_to_psgi> but an instance method in L<HTTP::Request>.
  
  =item res_from_psgi
  
    my $res = res_from_psgi([ $status, $headers, $body ]);
  
  Creates a L<HTTP::Response> object from a PSGI response array ref.
  
  =item HTTP::Response->from_psgi
  
    my $res = HTTP::Response->from_psgi([ $status, $headers, $body ]);
  
  Same as C<res_from_psgi>, but is a class method in L<HTTP::Response>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<HTTP::Request::AsCGI> L<HTTP::Message> L<Plack::Test>
  
  =cut
  
HTTP_MESSAGE_PSGI

    $fatpacked{"HTTP/MultiPartParser.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'HTTP_MULTIPARTPARSER';
  package HTTP::MultiPartParser;
  use strict;
  use warnings;
  
  BEGIN {
      our $VERSION = '0.02';
  }
  
  use Carp         qw[];
  use Scalar::Util qw[];
  
  my $_mk_parser;
  
  # RFC2046
  my $ValidBoundary = qr<\A [0-9A-Za-z'()+_,-./:=?]+ \z>x;
  
  sub new {
      my ($class, %params) = @_;
  
      my $self = {
          on_error          => \&Carp::croak,
          max_header_size   => 32 * 1024,
          max_preamble_size => 32 * 1024,
          on_header_as      => 'lines',
      };
  
      while (my ($p, $v) = each %params) {
          if ($p eq 'boundary') {
              Carp::croak(q/Parameter 'boundary' is not a valid boundary value/)
                unless ref \$v eq 'SCALAR' && defined $v && $v =~ $ValidBoundary;
              $self->{boundary} = $v;
          }
          elsif (   $p eq 'on_header'
                 || $p eq 'on_body'
                 || $p eq 'on_error') {
              Carp::croak(qq/Parameter '$p' is not a CODE reference/)
                unless ref $v eq 'CODE';
              $self->{$p} = $v;
          }
          elsif (   $p eq 'max_header_size'
                 || $p eq 'max_preamble_size') {
              Carp::croak(qq/Parameter '$p' is not a positive integer/)
                unless ref \$v eq 'SCALAR' && defined $v && $v =~ /\A [1-9][0-9]* \z/x;
              $self->{$p} = $v;
          }
          elsif ($p eq 'on_header_as') {
              Carp::croak(q/Parameter 'on_header_as' must be either 'unparsed' or 'lines'/)
                unless ref \$v eq 'SCALAR' && defined $v && $v =~ /\A (?: unparsed | lines) \z/x;
              $self->{on_header_as} = $v;
          }
          else {
              Carp::croak(qq/Unknown parameter '$p' passed to constructor/);
          }
      }
  
      for my $p (qw(boundary on_header on_body)) {
          Carp::croak(qq/Mandatory parameter '$p' is missing/)
            unless exists $self->{$p};
      }
  
      bless $self, $class;
      $self->{parser} = $_mk_parser->($self);
      return $self;
  }
  
  sub parse {
      @_ == 2 || Carp::croak(q/Usage: $parser->parse($octets)/);
      return $_[0]->{parser}->($_[1]);
  }
  
  sub finish {
      @_ == 1 || Carp::croak(q/Usage: $parser->finish()/);
      return $_[0]->{parser}->('', 1);
  }
  
  sub reset {
      @_ == 1 || Carp::croak(q/Usage: $parser->reset()/);
      $_[0]->{parser}  = $_mk_parser->($_[0]);
      $_[0]->{aborted} = !!0;
  }
  
  sub is_aborted {
      @_ == 1 || Carp::croak(q/Usage: $parser->is_aborted()/);
      return $_[0]->{aborted};
  }
  
  sub CRLF  () { "\x0D\x0A" }
  sub TRUE  () { !!1 }
  sub FALSE () { !!0 }
  
  sub STATE_PREAMBLE () { 1 }
  sub STATE_BOUNDARY () { 2 }
  sub STATE_HEADER   () { 3 }
  sub STATE_BODY     () { 4 }
  sub STATE_EPILOGUE () { 5 }
  
  $_mk_parser = sub {
      Scalar::Util::weaken(my $self = $_[0]);
  
      # RFC 2616 3.7.2 Multipart Types
      # The message body is itself a protocol element and MUST therefore use only
      # CRLF to represent line breaks between body-parts.
      my $boundary           = $self->{boundary};
      my $boundary_preamble  =        '--' . $boundary;
      my $boundary_delimiter = CRLF . '--' . $boundary;
  
      my $chunk   = '';
      my $buffer  = '';
      my $state   = STATE_PREAMBLE;
      my $finish  = FALSE;
      my $aborted = FALSE;
      
      my $on_header = $self->{on_header};
      my $on_body   = $self->{on_body};
      my $on_error  = sub {
          $aborted = $self->{aborted} = TRUE;
          goto $self->{on_error};
      };
      
      if ($self->{on_header_as} eq 'lines') {
          $on_header = sub {
              my @headers;
              for (split /\x0D\x0A/, $_[0]) {
                  if (/\A [^\x00-\x1F\x7F:]+ : /x) {
                      push @headers, $_;
                  }
                  elsif (s/\A [\x09\x20]+ //x) {
                      if (!@headers) {
                          $on_error->(q/Continuation line seen before first header/);
                          return;
                      }
                      next unless length;
                      $headers[-1] .= ' ' unless $headers[-1] =~ /[\x09\x20]\z/;
                      $headers[-1] .= $_;
                  }
                  else {
                      $on_error->(q/Malformed header line/);
                      return;
                  }
              }
              $self->{on_header}->(\@headers);
          };
      }
      
      return sub {
          $buffer .= $_[0];
          $finish  = $_[1];
  
          while (!$aborted) {
              if ($state == STATE_PREAMBLE) {
                  my $pos = index($buffer, $boundary_preamble);
                  if ($pos < 0) {
                      if (length $buffer > $self->{max_preamble_size}) {
                          $on_error->(q/Size of preamble exceeds maximum allowed/);
                          last;
                      }
                      $finish && $on_error->(q/End of stream encountered while parsing preamble/);
                      last;
                  }
                  substr($buffer, 0, $pos + 2 + length $boundary, '');
                  $state = STATE_BOUNDARY;
              }
              elsif ($state == STATE_BOUNDARY) {
                  if (length $buffer < 2) {
                      $finish && $on_error->(q/End of stream encountered while parsing boundary/);
                      last;
                  }
                  elsif (substr($buffer, 0, 2) eq CRLF) {
                      substr($buffer, 0, 2, '');
                      $state = STATE_HEADER;
                  }
                  elsif (substr($buffer, 0, 2) eq '--') {
                      if (length $buffer < 4) {
                          $finish && $on_error->(q/End of stream encountered while parsing closing boundary/);
                          last;
                      }
                      elsif (substr($buffer, 2, 2) eq CRLF) {
                          substr($buffer, 0, 4, '');
                          $state = STATE_EPILOGUE;
                      }
                      else {
                          $on_error->(q/Closing boundary does not terminate with CRLF/);
                          last;
                      }
                  }
                  else {
                      $on_error->(q/Boundary does not terminate with CRLF or hyphens/);
                      last;
                  }
              }
              elsif ($state == STATE_HEADER) {
                  my $pos = index($buffer, CRLF . CRLF);
                  if ($pos < 0) {
                      if (length $buffer > $self->{max_header_size}) {
                          $on_error->(q/Size of part header exceeds maximum allowed/);
                          last;
                      }
                      $finish && $on_error->(q/End of stream encountered while parsing part header/);
                      last;
                  }
  
                  $chunk = substr($buffer, 0, $pos + 4, '');
                  $state = STATE_BODY;
                  $on_header->($chunk);
              }
              elsif ($state == STATE_BODY) {
                  my $take = index($buffer, $boundary_delimiter);
                  if ($take < 0) {
                      $take = length($buffer) - (6 + length $boundary);
                      if ($take <= 0) {
                          $finish && $on_error->(q/End of stream encountered while parsing part body/);
                          last;
                      }
                  }
                  else {
                      $state = STATE_BOUNDARY;
                  }
  
                  $chunk = substr($buffer, 0, $take, '');
  
                  if ($state == STATE_BOUNDARY) {
                      substr($buffer, 0, 4 + length $boundary, '');
                  }
  
                  $on_body->($chunk, $state == STATE_BOUNDARY);
              }
              # RFC 2616 3.7.2 Multipart Types
              # Unlike in RFC 2046, the epilogue of any multipart message MUST be
              # empty; HTTP applications MUST NOT transmit the epilogue (even if the
              # original multipart contains an epilogue). These restrictions exist in
              # order to preserve the self-delimiting nature of a multipart message-
              # body, wherein the "end" of the message-body is indicated by the
              # ending multipart boundary.
              elsif ($state == STATE_EPILOGUE) {
                  (length $buffer == 0)
                    || $on_error->(q/Nonempty epilogue/);
                  last;
              }
              else {
                  Carp::croak(qq/panic: unknown state: $state/);
              }
          }
          return !$aborted;
      };
  };
  
  1;
HTTP_MULTIPARTPARSER

    $fatpacked{"HTTP/Parser.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'HTTP_PARSER';
  =head1 NAME
  
  HTTP::Parser - parse HTTP/1.1 request into HTTP::Request/Response object
  
  =head1 SYNOPSIS
  
   my $parser = HTTP::Parser->new();
  
   ...
  
   my $status = $parser->add($text);
  
   if(0 == $status) {
     print "request: ".$parser->request()->as_string();  # HTTP::Request
   } elsif(-3 == $status) {
     print "no content length header!\n";
   } elsif(-2 == $status) {
     print "need a line of data\n";
   } elsif(-1 == $status) {
     print "need more data\n";
   } else {  # $status > 0
     print "need $status byte(s)\n";
   }
  
  =head1 DESCRIPTION
  
  This is an HTTP request parser.  It takes chunks of text as received and
  returns a 'hint' as to what is required, or returns the HTTP::Request when
  a complete request has been read.  HTTP/1.1 chunking is supported.  It dies
  if it finds an error.
  
  =cut
  use 5.006_001;
  use strict;
  
  package HTTP::Parser;
  
  our $VERSION = '0.06';
  
  use HTTP::Request;
  use HTTP::Response;
  use URI;
  
  # token is (RFC 2616, ASCII)
  my $Token =
   qr/[\x21\x23-\x27\x2a\x2b\x2d\x2e\x30-\x39\x41-\x5a\x5e-\x7a\x7c\x7e]+/;
  
  
  =head2 new ( named params... )
  
  Create a new HTTP::Parser object.  Takes named parameters, e.g.:
  
   my $parser = HTTP::Parser->new(request => 1);
  
  =over 4
  
  =item request
  
  Allows or denies parsing an HTTP request and returning an C<HTTP::Request>
  object.
  
  =item response
  
  Allows or denies parsing an HTTP response and returning an C<HTTP::Response>
  object.
  
  =back
  
  If you pass neither C<request> nor C<response>, only requests are parsed (for
  backwards compatibility); if you pass either, the other defaults to false
  (disallowing both requests and responses is a fatal error).
  
  =cut
  sub new {
    my ($class, %p) = @_;
    $p{request} = 1 unless exists $p{response} or exists $p{request};
    die 'must allow request or response to be parsed'
     unless $p{request} or $p{response};
    @p{qw(state data)} = ('blank', '');
    my $self = bless \%p, ref $class || $class;
    return $self;
  }
  
  
  =head2 add ( string )
  
  Parse request.  Returns:
  
  =over 8
  
  =item  0
  
  if finished (call C<object> to get an HTTP::Request or Response object)
  
  =item -1
  
  if not finished but not sure how many bytes remain
  
  =item -2
  
  if waiting for a line (like 0 with a hint)
  
  =item -3
  
  if there was no content-length header, so we can't tell whether we are 
  waiting for more data or not.
  
  If you are reading from a TCP stream, you can keep adding data until 
  the connection closes gracefully (the HTTP RFC allows this).
  
  If you are reading from a file, you should keep adding until you have 
  all the data.  
  
  Once you have added all data, you may call C<object>.  if you are not 
  sure whether you have all the data, the HTTP::Response object might be 
  incomplete.
  
  =item count
  
  if waiting for that many bytes
  
  =back
  
  Dies on error.
  
  This method of parsing makes it easier to parse a request from an event-based
  system, on the other hand, it's quite alright to pass in the whole request.
  Ideally, the first chunk passed in is the header (up to the double newline),
  then whatever byte counts are requested.
  
  When a request object is returned, the X-HTTP-Version header has the HTTP
  version, the uri() method will always return a URI object, not a string.
  
  Note that a nonzero return is just a hint, and any amount of data can be
  passed in to a subsequent add() call.
  
  =cut
  sub add {
    my ($self,$s) = @_;
    $s = '' if not defined $s;
  
    $self->{data} .= $s;
  
    # pre-header blank lines are allowed (RFC 2616 4.1)
    if($self->{state} eq 'blank') {
      $self->{data} =~ s/^(\x0d?\x0a)+//;
      return -2 unless length $self->{data};
      $self->{state} = 'header';  # done with blank lines; fall through
    }
  
    # still waiting for the header
    if($self->{state} eq 'header') {
      # double line break indicates end of header; parse it
      if($self->{data} =~ /^(.*?)\x0d?\x0a\x0d?\x0a/s) {
        return $self->_parse_header(length $1);
      }
      return -2;  # still waiting for unknown amount of header lines
  
    # waiting for main body of request
    } elsif($self->{state} eq 'body') {
      return $self->_parse_body();
  
    # chunked data
    } elsif($self->{state} eq 'chunked') {
      return $self->_parse_chunk();
  
    # trailers
    } elsif($self->{state} eq 'trailer') {
      # double line break indicates end of trailer; parse it
      return $self->_parse_header(length $1,1)
       if $self->{data} =~ /^(.*?)\x0d?\x0a\x0d?\x0a/s;
      return -1;  # still waiting for unknown amount of trailer data
    }
  
    die "unknown state '$self->{state}'";
  }
  
  
  =head2 data
  
  Returns current data not parsed.  Mainly useful after a request has been
  parsed.  The data is not removed from the object's buffer, and will be
  seen before the data next passed to add().
  
  =cut
  sub data {
    shift->{data}
  }
  
  
  =head2 extra
  
  Returns the count of extra bytes (length of data()) after a request.
  
  =cut
  sub extra {
    length shift->{data}
  }
  
  
  =head2 object
  
  Returns the object request.  Only useful after the parse has completed.
  
  =cut
  sub object {
    shift->{obj}
  }
  
  # keep this for compatibility with 0.02
  sub request {
    shift->{obj}
  }
  
  
  # _parse_header ( position of double newline in data [, trailer flag] )
  #
  # helper for parse that parses an HTTP header
  # prerequisite: we have data up to a double newline in $self->{data}
  # if the trailer flag is set, we're parsing trailers
  #
  sub _parse_header {
    my ($self,$eoh,$trailer) = @_;
    my $header = substr($self->{data},0,$eoh,'');
    $self->{data} =~ s/^\x0d?\x0a\x0d?\x0a//;
  
    # parse into lines
    my @header = split /\x0d?\x0a/,$header;
    my $request = shift @header unless $trailer;
  
    # join folded lines
    my @out;
    for(@header) {
      if(s/^[ \t]+//) {
        die 'LWS on first header line' unless @out;
        $out[-1] .= $_;
      } else {
        push @out, $_;
      }
    }
  
    # parse request or response line
    my $obj;
    unless($trailer) {
      my ($major, $minor);
  
      # is it an HTTP response?
      if ($request =~ /^HTTP\/(\d+)\.(\d+)/i) {
        die 'HTTP responses not allowed' unless $self->{response};
        ($major,$minor) = ($1,$2);
        $request =~ /^HTTP\/\d+\.\d+ (\d+) (.+)$/;
        my $state = $1;
        my $msg = $2;
        $obj = $self->{obj} = HTTP::Response->new($state, $msg);
  
      # perhaps a request?
      } else {
        my ($method,$uri,$http) = split / /,$request;
        die "'$request' is not the start of a valid HTTP request or response"
         unless $http and $http =~ /^HTTP\/(\d+)\.(\d+)$/i;
        ($major,$minor) = ($1,$2);
        die 'HTTP requests not allowed' unless $self->{request};
  
        # If the Request-URI is an abs_path, we need to tell URI that we don't
        # know the scheme, otherwise it will misinterpret paths that start with
        # // as being scheme-relative uris, and will interpret the first
        # component after // as the host (see rfc 2616)
        $uri = "//$uri" if $uri =~ m(^/);
        $obj = $self->{obj} = HTTP::Request->new($method, URI->new($uri));
      }
  
      $obj->header(X_HTTP_Version => "$major.$minor");  # pseudo-header
  
    # we've already seen the initial line and created the object
    } else {
      $obj = $self->{obj};
    }
  
    # import headers
    my $token = qr/[^][\x00-\x1f\x7f()<>@,;:\\"\/?={} \t]+/;
    for $header(@header) {
      die "bad header name in '$header'" unless $header =~ s/^($token):[\t ]*//;
      $obj->push_header($1 => $header);
    }
  
    # if we're parsing trailers we don't need to look at content
    return 0 if $trailer;
  
    # see what sort of content we have, if any
    if(my $length = $obj->header('content_length')) {
      s/^\s+//, s/\s+$// for $length;
      die "bad content-length '$length'" unless $length =~ /^(\d+)$/;
      $self->{state} = 'body';
      return $self->_parse_body();
    }
  
    # check for transfer-encoding, and handle chunking
    if(my @te = $obj->header('transfer_encoding')) {
      if(grep { lc $_ eq 'chunked' } @te) {
        $self->{state} = 'chunked';
        return $self->_parse_chunk();
      }
    }
  
    # section 14.13 of the spec says an HTTP response "SHOULD" return a 
    # content-length header unless there are reasons not to
    # however, the same RFC does allow "end of connection" as a valid marker
    # of the end of data and means the server does not need to set a content
    # length header.  the only status codes that "MAY NOT" return data are
    # 1xx, 204 and 304.
    # therefore if there is no content length header, return -3 to the caller
    # so they can decide whether to keep feeding data.  if using HTTP::Parser
    # with data from tcp, you could assume that the end of a connection is
    # the end of the response data
    if($self->{response}) {
      if (!defined $obj->header('content_length') &&
       $self->object->code ne '204' &&
       $self->object->code ne '304' &&
       $self->object->code !~ /1\d\d/) {
  
        # Assume headers are finished and we are moving into body mode
        $self->{state} = 'body';
        $self->{no_content_length} = 1;
  
        # Parse any data that might be left
        return $self->_parse_body() if length $self->data;
        return -3;
      }
    }
  
    # else we have no content so return success
    return 0;
  }
  
  
  # _parse_body
  #
  # helper for parse, returns request object with content if done, else
  # count of bytes remaining
  #
  sub _parse_body {
    my $self = shift;
    my $length = $self->{obj}->header('content_length');
  
    # if the server didn't include a content length header, inform the
    # caller.  they may choose to ignore this response or wait for
    # the end of connection (which is a valid reason to assume that
    # the response is finished)
    if($self->{no_content_length}) {
      $self->{obj}->content($self->{data});
      return -3;
    }
  
    if(length $self->{data} >= $length) {
      $self->{obj}->content(substr($self->{data},0,$length,''));
      return 0;
    }
    return $length-length $self->{data};
  }
  
  
  # _parse_chunk
  #
  # helper for parse, parse chunked transfer-encoded message; returns like parse
  #
  sub _parse_chunk {
    my $self = shift;
  
  CHUNK:
  
    # need beginning of chunk with size
    if(not $self->{chunk}) {
      if($self->{data} =~ s/^([0-9a-fA-F]+)[^\x0d\x0a]*?\x0d?\x0a//) {
  
        # a zero-size chunk marks the end
        unless($self->{chunk} = hex $1) {
          $self->{state} = 'trailer';
  
          # double line break indicates end of trailer; parse it
          $self->{data} = "\x0d\x0a".$self->{data};  # count previous line break
          return $self->_parse_header(length $1,1)
           if $self->{data} =~ /^(.*?)\x0d?\x0a\x0d?\x0a/s;
          return -1;  # still waiting for unknown amount of trailer data
        }
  
      } else {
        die "expected chunked encoding, got '".substr($self->{data},0,40)."...'"
         if $self->{data} =~ /\x0d?\x0a/;
        return -2;  # waiting for a line with chunk information
      }
    }
  
    # do we have a current chunk size?
    if($self->{chunk}) {
  
      # do we have enough data to fill it, plus a CR LF?
      if(length $self->{data} > $self->{chunk} and
       substr($self->{data},$self->{chunk},2) =~ /^(\x0d?\x0a)/) {
        my $crlf = $1;
        $self->{obj}->add_content(substr($self->{data},0,$self->{chunk}));
        substr($self->{data},0,length $crlf) = '';
  
        # remove data from the buffer that we've already parsed
        $self->{data} = substr($self->{data},delete $self->{chunk});
  
        # got chunks?
        goto CHUNK;
      }
  
      return $self->{chunk}-length($self->{data})+2;  # extra CR LF
    }
  }
  
  
  =head1 AUTHOR
  
  David Robins E<lt>dbrobins@davidrobins.netE<gt>
  Fixes for 0.05 by David Cannings E<lt>david@edeca.netE<gt>
  
  =head1 SEE ALSO
  
  L<HTTP::Request>, L<HTTP::Response>.
  
  =cut
  
  
  1;
HTTP_PARSER

    $fatpacked{"HTTP/Request.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'HTTP_REQUEST';
  package HTTP::Request;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.44';
  
  use parent 'HTTP::Message';
  
  sub new
  {
      my($class, $method, $uri, $header, $content) = @_;
      my $self = $class->SUPER::new($header, $content);
      $self->method($method);
      $self->uri($uri);
      $self;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
      Carp::carp('Undefined argument to parse()') if $^W && ! defined $str;
      my $request_line;
      if (defined $str && $str =~ s/^(.*)\n//) {
  	$request_line = $1;
      }
      else {
  	$request_line = $str;
  	$str = "";
      }
  
      my $self = $class->SUPER::parse($str);
      if (defined $request_line) {
          my($method, $uri, $protocol) = split(' ', $request_line);
          $self->method($method);
          $self->uri($uri) if defined($uri);
          $self->protocol($protocol) if $protocol;
      }
      $self;
  }
  
  
  sub clone
  {
      my $self = shift;
      my $clone = bless $self->SUPER::clone, ref($self);
      $clone->method($self->method);
      $clone->uri($self->uri);
      $clone;
  }
  
  
  sub method
  {
      shift->_elem('_method', @_);
  }
  
  
  sub uri
  {
      my $self = shift;
      my $old = $self->{'_uri'};
      if (@_) {
  	my $uri = shift;
  	if (!defined $uri) {
  	    # that's ok
  	}
  	elsif (ref $uri) {
  	    Carp::croak("A URI can't be a " . ref($uri) . " reference")
  		if ref($uri) eq 'HASH' or ref($uri) eq 'ARRAY';
  	    Carp::croak("Can't use a " . ref($uri) . " object as a URI")
  		unless $uri->can('scheme') && $uri->can('canonical');
  	    $uri = $uri->clone;
  	    unless ($HTTP::URI_CLASS eq "URI") {
  		# Argh!! Hate this... old LWP legacy!
  		eval { local $SIG{__DIE__}; $uri = $uri->abs; };
  		die $@ if $@ && $@ !~ /Missing base argument/;
  	    }
  	}
  	else {
  	    $uri = $HTTP::URI_CLASS->new($uri);
  	}
  	$self->{'_uri'} = $uri;
          delete $self->{'_uri_canonical'};
      }
      $old;
  }
  
  *url = \&uri;  # legacy
  
  sub uri_canonical
  {
      my $self = shift;
  
      my $uri = $self->{_uri};
  
      if (defined (my $canon = $self->{_uri_canonical})) {
          # early bailout if these are the exact same string;
          # rely on stringification of the URI objects
          return $canon if $canon eq $uri;
      }
  
      # otherwise we need to refresh the memoized value
      $self->{_uri_canonical} = $uri->canonical;
  }
  
  
  sub accept_decodable
  {
      my $self = shift;
      $self->header("Accept-Encoding", scalar($self->decodable));
  }
  
  sub as_string
  {
      my $self = shift;
      my($eol) = @_;
      $eol = "\n" unless defined $eol;
  
      my $req_line = $self->method || "-";
      my $uri = $self->uri;
      $uri = (defined $uri) ? $uri->as_string : "-";
      $req_line .= " $uri";
      my $proto = $self->protocol;
      $req_line .= " $proto" if $proto;
  
      return join($eol, $req_line, $self->SUPER::as_string(@_));
  }
  
  sub dump
  {
      my $self = shift;
      my @pre = ($self->method || "-", $self->uri || "-");
      if (my $prot = $self->protocol) {
  	push(@pre, $prot);
      }
  
      return $self->SUPER::dump(
          preheader => join(" ", @pre),
  	@_,
      );
  }
  
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Request - HTTP style request message
  
  =head1 VERSION
  
  version 6.44
  
  =head1 SYNOPSIS
  
   require HTTP::Request;
   $request = HTTP::Request->new(GET => 'http://www.example.com/');
  
  and usually used like this:
  
   $ua = LWP::UserAgent->new;
   $response = $ua->request($request);
  
  =head1 DESCRIPTION
  
  C<HTTP::Request> is a class encapsulating HTTP style requests,
  consisting of a request line, some headers, and a content body. Note
  that the LWP library uses HTTP style requests even for non-HTTP
  protocols.  Instances of this class are usually passed to the
  request() method of an C<LWP::UserAgent> object.
  
  C<HTTP::Request> is a subclass of C<HTTP::Message> and therefore
  inherits its methods.  The following additional methods are available:
  
  =over 4
  
  =item $r = HTTP::Request->new( $method, $uri )
  
  =item $r = HTTP::Request->new( $method, $uri, $header )
  
  =item $r = HTTP::Request->new( $method, $uri, $header, $content )
  
  Constructs a new C<HTTP::Request> object describing a request on the
  object $uri using method $method.  The $method argument must be a
  string.  The $uri argument can be either a string, or a reference to a
  C<URI> object.  The optional $header argument should be a reference to
  an C<HTTP::Headers> object or a plain array reference of key/value
  pairs.  The optional $content argument should be a string of bytes.
  
  =item $r = HTTP::Request->parse( $str )
  
  This constructs a new request object by parsing the given string.
  
  =item $r->method
  
  =item $r->method( $val )
  
  This is used to get/set the method attribute.  The method should be a
  short string like "GET", "HEAD", "PUT", "PATCH" or "POST".
  
  =item $r->uri
  
  =item $r->uri( $val )
  
  This is used to get/set the uri attribute.  The $val can be a
  reference to a URI object or a plain string.  If a string is given,
  then it should be parsable as an absolute URI.
  
  =item $r->header( $field )
  
  =item $r->header( $field => $value )
  
  This is used to get/set header values and it is inherited from
  C<HTTP::Headers> via C<HTTP::Message>.  See L<HTTP::Headers> for
  details and other similar methods that can be used to access the
  headers.
  
  =item $r->accept_decodable
  
  This will set the C<Accept-Encoding> header to the list of encodings
  that decoded_content() can decode.
  
  =item $r->content
  
  =item $r->content( $bytes )
  
  This is used to get/set the content and it is inherited from the
  C<HTTP::Message> base class.  See L<HTTP::Message> for details and
  other methods that can be used to access the content.
  
  Note that the content should be a string of bytes.  Strings in perl
  can contain characters outside the range of a byte.  The C<Encode>
  module can be used to turn such strings into a string of bytes.
  
  =item $r->as_string
  
  =item $r->as_string( $eol )
  
  Method returning a textual representation of the request.
  
  =back
  
  =head1 EXAMPLES
  
  Creating requests to be sent with L<LWP::UserAgent> or others can be easy. Here
  are a few examples.
  
  =head2 Simple POST
  
  Here, we'll create a simple POST request that could be used to send JSON data
  to an endpoint.
  
      #!/usr/bin/env perl
  
      use strict;
      use warnings;
  
      use HTTP::Request ();
      use JSON::MaybeXS qw(encode_json);
  
      my $url = 'https://www.example.com/api/user/123';
      my $header = ['Content-Type' => 'application/json; charset=UTF-8'];
      my $data = {foo => 'bar', baz => 'quux'};
      my $encoded_data = encode_json($data);
  
      my $r = HTTP::Request->new('POST', $url, $header, $encoded_data);
      # at this point, we could send it via LWP::UserAgent
      # my $ua = LWP::UserAgent->new();
      # my $res = $ua->request($r);
  
  =head2 Batch POST Request
  
  Some services, like Google, allow multiple requests to be sent in one batch.
  L<https://developers.google.com/drive/v3/web/batch> for example. Using the
  C<add_part> method from L<HTTP::Message> makes this simple.
  
      #!/usr/bin/env perl
  
      use strict;
      use warnings;
  
      use HTTP::Request ();
      use JSON::MaybeXS qw(encode_json);
  
      my $auth_token = 'auth_token';
      my $batch_url = 'https://www.googleapis.com/batch';
      my $url = 'https://www.googleapis.com/drive/v3/files/fileId/permissions?fields=id';
      my $url_no_email = 'https://www.googleapis.com/drive/v3/files/fileId/permissions?fields=id&sendNotificationEmail=false';
  
      # generate a JSON post request for one of the batch entries
      my $req1 = build_json_request($url, {
          emailAddress => 'example@appsrocks.com',
          role => "writer",
          type => "user",
      });
  
      # generate a JSON post request for one of the batch entries
      my $req2 = build_json_request($url_no_email, {
          domain => "appsrocks.com",
          role => "reader",
          type => "domain",
      });
  
      # generate a multipart request to send all of the other requests
      my $r = HTTP::Request->new('POST', $batch_url, [
          'Accept-Encoding' => 'gzip',
          # if we don't provide a boundary here, HTTP::Message will generate
          # one for us. We could use UUID::uuid() here if we wanted.
          'Content-Type' => 'multipart/mixed; boundary=END_OF_PART'
      ]);
  
      # add the two POST requests to the main request
      $r->add_part($req1, $req2);
      # at this point, we could send it via LWP::UserAgent
      # my $ua = LWP::UserAgent->new();
      # my $res = $ua->request($r);
      exit();
  
      sub build_json_request {
          my ($url, $href) = @_;
          my $header = ['Authorization' => "Bearer $auth_token", 'Content-Type' => 'application/json; charset=UTF-8'];
          return HTTP::Request->new('POST', $url, $header, encode_json($href));
      }
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>, L<HTTP::Message>, L<HTTP::Request::Common>,
  L<HTTP::Response>
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  #ABSTRACT: HTTP style request message
HTTP_REQUEST

    $fatpacked{"HTTP/Request/Common.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'HTTP_REQUEST_COMMON';
  package HTTP::Request::Common;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.44';
  
  our $DYNAMIC_FILE_UPLOAD ||= 0;  # make it defined (don't know why)
  our $READ_BUFFER_SIZE      = 8192;
  
  use Exporter 5.57 'import';
  
  our @EXPORT =qw(GET HEAD PUT PATCH POST OPTIONS);
  our @EXPORT_OK = qw($DYNAMIC_FILE_UPLOAD DELETE);
  
  require HTTP::Request;
  use Carp();
  use File::Spec;
  
  my $CRLF = "\015\012";   # "\r\n" is not portable
  
  sub GET  { _simple_req('GET',  @_); }
  sub HEAD { _simple_req('HEAD', @_); }
  sub DELETE { _simple_req('DELETE', @_); }
  sub PATCH { request_type_with_data('PATCH', @_); }
  sub POST { request_type_with_data('POST', @_); }
  sub PUT { request_type_with_data('PUT', @_); }
  sub OPTIONS { request_type_with_data('OPTIONS', @_); }
  
  sub request_type_with_data
  {
      my $type = shift;
      my $url  = shift;
      my $req = HTTP::Request->new($type => $url);
      my $content;
      $content = shift if @_ and ref $_[0];
      my($k, $v);
      while (($k,$v) = splice(@_, 0, 2)) {
  	if (lc($k) eq 'content') {
  	    $content = $v;
  	}
  	else {
  	    $req->push_header($k, $v);
  	}
      }
      my $ct = $req->header('Content-Type');
      unless ($ct) {
  	$ct = 'application/x-www-form-urlencoded';
      }
      elsif ($ct eq 'form-data') {
  	$ct = 'multipart/form-data';
      }
  
      if (ref $content) {
  	if ($ct =~ m,^multipart/form-data\s*(;|$),i) {
  	    require HTTP::Headers::Util;
  	    my @v = HTTP::Headers::Util::split_header_words($ct);
  	    Carp::carp("Multiple Content-Type headers") if @v > 1;
  	    @v = @{$v[0]};
  
  	    my $boundary;
  	    my $boundary_index;
  	    for (my @tmp = @v; @tmp;) {
  		my($k, $v) = splice(@tmp, 0, 2);
  		if ($k eq "boundary") {
  		    $boundary = $v;
  		    $boundary_index = @v - @tmp - 1;
  		    last;
  		}
  	    }
  
  	    ($content, $boundary) = form_data($content, $boundary, $req);
  
  	    if ($boundary_index) {
  		$v[$boundary_index] = $boundary;
  	    }
  	    else {
  		push(@v, boundary => $boundary);
  	    }
  
  	    $ct = HTTP::Headers::Util::join_header_words(@v);
  	}
  	else {
  	    # We use a temporary URI object to format
  	    # the application/x-www-form-urlencoded content.
  	    require URI;
  	    my $url = URI->new('http:');
  	    $url->query_form(ref($content) eq "HASH" ? %$content : @$content);
  	    $content = $url->query;
  
  	    # HTML/4.01 says that line breaks are represented as "CR LF" pairs (i.e., `%0D%0A')
  	    $content =~ s/(?<!%0D)%0A/%0D%0A/g if defined($content);
  	}
      }
  
      $req->header('Content-Type' => $ct);  # might be redundant
      if (defined($content)) {
  	$req->header('Content-Length' =>
  		     length($content)) unless ref($content);
  	$req->content($content);
      }
      else {
          $req->header('Content-Length' => 0);
      }
      $req;
  }
  
  
  sub _simple_req
  {
      my($method, $url) = splice(@_, 0, 2);
      my $req = HTTP::Request->new($method => $url);
      my($k, $v);
      my $content;
      while (($k,$v) = splice(@_, 0, 2)) {
  	if (lc($k) eq 'content') {
  	    $req->add_content($v);
              $content++;
  	}
  	else {
  	    $req->push_header($k, $v);
  	}
      }
      if ($content && !defined($req->header("Content-Length"))) {
          $req->header("Content-Length", length(${$req->content_ref}));
      }
      $req;
  }
  
  
  sub form_data   # RFC1867
  {
      my($data, $boundary, $req) = @_;
      my @data = ref($data) eq "HASH" ? %$data : @$data;  # copy
      my $fhparts;
      my @parts;
      while (my ($k,$v) = splice(@data, 0, 2)) {
  	if (!ref($v)) {
  	    $k =~ s/([\\\"])/\\$1/g;  # escape quotes and backslashes
              no warnings 'uninitialized';
  	    push(@parts,
  		 qq(Content-Disposition: form-data; name="$k"$CRLF$CRLF$v));
  	}
  	else {
  	    my($file, $usename, @headers) = @$v;
  	    unless (defined $usename) {
  		$usename = $file;
  		$usename = (File::Spec->splitpath($usename))[-1] if defined($usename);
  	    }
              $k =~ s/([\\\"])/\\$1/g;
  	    my $disp = qq(form-data; name="$k");
              if (defined($usename) and length($usename)) {
                  $usename =~ s/([\\\"])/\\$1/g;
                  $disp .= qq(; filename="$usename");
              }
  	    my $content = "";
  	    my $h = HTTP::Headers->new(@headers);
  	    if ($file) {
  		open(my $fh, "<", $file) or Carp::croak("Can't open file $file: $!");
  		binmode($fh);
  		if ($DYNAMIC_FILE_UPLOAD) {
  		    # will read file later, close it now in order to
                      # not accumulate to many open file handles
                      close($fh);
  		    $content = \$file;
  		}
  		else {
  		    local($/) = undef; # slurp files
  		    $content = <$fh>;
  		    close($fh);
  		}
  		unless ($h->header("Content-Type")) {
  		    require LWP::MediaTypes;
  		    LWP::MediaTypes::guess_media_type($file, $h);
  		}
  	    }
  	    if ($h->header("Content-Disposition")) {
  		# just to get it sorted first
  		$disp = $h->header("Content-Disposition");
  		$h->remove_header("Content-Disposition");
  	    }
  	    if ($h->header("Content")) {
  		$content = $h->header("Content");
  		$h->remove_header("Content");
  	    }
  	    my $head = join($CRLF, "Content-Disposition: $disp",
  			           $h->as_string($CRLF),
  			           "");
  	    if (ref $content) {
  		push(@parts, [$head, $$content]);
  		$fhparts++;
  	    }
  	    else {
  		push(@parts, $head . $content);
  	    }
  	}
      }
      return ("", "none") unless @parts;
  
      my $content;
      if ($fhparts) {
  	$boundary = boundary(10) # hopefully enough randomness
  	    unless $boundary;
  
  	# add the boundaries to the @parts array
  	for (1..@parts-1) {
  	    splice(@parts, $_*2-1, 0, "$CRLF--$boundary$CRLF");
  	}
  	unshift(@parts, "--$boundary$CRLF");
  	push(@parts, "$CRLF--$boundary--$CRLF");
  
  	# See if we can generate Content-Length header
  	my $length = 0;
  	for (@parts) {
  	    if (ref $_) {
  	 	my ($head, $f) = @$_;
  		my $file_size;
  		unless ( -f $f && ($file_size = -s _) ) {
  		    # The file is either a dynamic file like /dev/audio
  		    # or perhaps a file in the /proc file system where
  		    # stat may return a 0 size even though reading it
  		    # will produce data.  So we cannot make
  		    # a Content-Length header.
  		    undef $length;
  		    last;
  		}
  	    	$length += $file_size + length $head;
  	    }
  	    else {
  		$length += length;
  	    }
          }
          $length && $req->header('Content-Length' => $length);
  
  	# set up a closure that will return content piecemeal
  	$content = sub {
  	    for (;;) {
  		unless (@parts) {
  		    defined $length && $length != 0 &&
  		    	Carp::croak "length of data sent did not match calculated Content-Length header.  Probably because uploaded file changed in size during transfer.";
  		    return;
  		}
  		my $p = shift @parts;
  		unless (ref $p) {
  		    $p .= shift @parts while @parts && !ref($parts[0]);
  		    defined $length && ($length -= length $p);
  		    return $p;
  		}
  		my($buf, $fh) = @$p;
                  unless (ref($fh)) {
                      my $file = $fh;
                      undef($fh);
                      open($fh, "<", $file) || Carp::croak("Can't open file $file: $!");
                      binmode($fh);
                  }
  		my $buflength = length $buf;
  		my $n = read($fh, $buf, $READ_BUFFER_SIZE, $buflength);
  		if ($n) {
  		    $buflength += $n;
  		    unshift(@parts, ["", $fh]);
  		}
  		else {
  		    close($fh);
  		}
  		if ($buflength) {
  		    defined $length && ($length -= $buflength);
  		    return $buf
  	    	}
  	    }
  	};
  
      }
      else {
  	$boundary = boundary() unless $boundary;
  
  	my $bno = 0;
        CHECK_BOUNDARY:
  	{
  	    for (@parts) {
  		if (index($_, $boundary) >= 0) {
  		    # must have a better boundary
  		    $boundary = boundary(++$bno);
  		    redo CHECK_BOUNDARY;
  		}
  	    }
  	    last;
  	}
  	$content = "--$boundary$CRLF" .
  	           join("$CRLF--$boundary$CRLF", @parts) .
  		   "$CRLF--$boundary--$CRLF";
      }
  
      wantarray ? ($content, $boundary) : $content;
  }
  
  
  sub boundary
  {
      my $size = shift || return "xYzZY";
      require MIME::Base64;
      my $b = MIME::Base64::encode(join("", map chr(rand(256)), 1..$size*3), "");
      $b =~ s/[\W]/X/g;  # ensure alnum only
      $b;
  }
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Request::Common - Construct common HTTP::Request objects
  
  =head1 VERSION
  
  version 6.44
  
  =head1 SYNOPSIS
  
    use HTTP::Request::Common;
    $ua = LWP::UserAgent->new;
    $ua->request(GET 'http://www.sn.no/');
    $ua->request(POST 'http://somewhere/foo', foo => bar, bar => foo);
    $ua->request(PATCH 'http://somewhere/foo', foo => bar, bar => foo);
    $ua->request(PUT 'http://somewhere/foo', foo => bar, bar => foo);
    $ua->request(OPTIONS 'http://somewhere/foo', foo => bar, bar => foo);
  
  =head1 DESCRIPTION
  
  This module provides functions that return newly created C<HTTP::Request>
  objects.  These functions are usually more convenient to use than the
  standard C<HTTP::Request> constructor for the most common requests.
  
  Note that L<LWP::UserAgent> has several convenience methods, including
  C<get>, C<head>, C<delete>, C<post> and C<put>.
  
  The following functions are provided:
  
  =over 4
  
  =item GET $url
  
  =item GET $url, Header => Value,...
  
  The C<GET> function returns an L<HTTP::Request> object initialized with
  the "GET" method and the specified URL.  It is roughly equivalent to the
  following call
  
    HTTP::Request->new(
       GET => $url,
       HTTP::Headers->new(Header => Value,...),
    )
  
  but is less cluttered.  What is different is that a header named
  C<Content> will initialize the content part of the request instead of
  setting a header field.  Note that GET requests should normally not
  have a content, so this hack makes more sense for the C<PUT>, C<PATCH>
   and C<POST> functions described below.
  
  The C<get(...)> method of L<LWP::UserAgent> exists as a shortcut for
  C<< $ua->request(GET ...) >>.
  
  =item HEAD $url
  
  =item HEAD $url, Header => Value,...
  
  Like GET() but the method in the request is "HEAD".
  
  The C<head(...)>  method of L<LWP::UserAgent> exists as a shortcut for
  C<< $ua->request(HEAD ...) >>.
  
  =item DELETE $url
  
  =item DELETE $url, Header => Value,...
  
  Like C<GET> but the method in the request is C<DELETE>.  This function
  is not exported by default.
  
  =item PATCH $url
  
  =item PATCH $url, Header => Value,...
  
  =item PATCH $url, $form_ref, Header => Value,...
  
  =item PATCH $url, Header => Value,..., Content => $form_ref
  
  =item PATCH $url, Header => Value,..., Content => $content
  
  The same as C<POST> below, but the method in the request is C<PATCH>.
  
  =item PUT $url
  
  =item PUT $url, Header => Value,...
  
  =item PUT $url, $form_ref, Header => Value,...
  
  =item PUT $url, Header => Value,..., Content => $form_ref
  
  =item PUT $url, Header => Value,..., Content => $content
  
  The same as C<POST> below, but the method in the request is C<PUT>
  
  =item OPTIONS $url
  
  =item OPTIONS $url, Header => Value,...
  
  =item OPTIONS $url, $form_ref, Header => Value,...
  
  =item OPTIONS $url, Header => Value,..., Content => $form_ref
  
  =item OPTIONS $url, Header => Value,..., Content => $content
  
  The same as C<POST> below, but the method in the request is C<OPTIONS>
  
  This was added in version 6.21, so you should require that in your code:
  
   use HTTP::Request::Common 6.21;
  
  =item POST $url
  
  =item POST $url, Header => Value,...
  
  =item POST $url, $form_ref, Header => Value,...
  
  =item POST $url, Header => Value,..., Content => $form_ref
  
  =item POST $url, Header => Value,..., Content => $content
  
  C<POST>, C<PATCH> and C<PUT> all work with the same parameters.
  
    %data = ( title => 'something', body => something else' );
    $ua = LWP::UserAgent->new();
    $request = HTTP::Request::Common::POST( $url, [ %data ] );
    $response = $ua->request($request);
  
  They take a second optional array or hash reference
  parameter C<$form_ref>.  The content can also be specified
  directly using the C<Content> pseudo-header, and you may also provide
  the C<$form_ref> this way.
  
  The C<Content> pseudo-header steals a bit of the header field namespace as
  there is no way to directly specify a header that is actually called
  "Content".  If you really need this you must update the request
  returned in a separate statement.
  
  The C<$form_ref> argument can be used to pass key/value pairs for the
  form content.  By default we will initialize a request using the
  C<application/x-www-form-urlencoded> content type.  This means that
  you can emulate an HTML E<lt>form> POSTing like this:
  
    POST 'http://www.perl.org/survey.cgi',
         [ name   => 'Gisle Aas',
           email  => 'gisle@aas.no',
           gender => 'M',
           born   => '1964',
           perc   => '3%',
         ];
  
  This will create an L<HTTP::Request> object that looks like this:
  
    POST http://www.perl.org/survey.cgi
    Content-Length: 66
    Content-Type: application/x-www-form-urlencoded
  
    name=Gisle%20Aas&email=gisle%40aas.no&gender=M&born=1964&perc=3%25
  
  Multivalued form fields can be specified by either repeating the field
  name or by passing the value as an array reference.
  
  The POST method also supports the C<multipart/form-data> content used
  for I<Form-based File Upload> as specified in RFC 1867.  You trigger
  this content format by specifying a content type of C<'form-data'> as
  one of the request headers.  If one of the values in the C<$form_ref> is
  an array reference, then it is treated as a file part specification
  with the following interpretation:
  
    [ $file, $filename, Header => Value... ]
    [ undef, $filename, Header => Value,..., Content => $content ]
  
  The first value in the array ($file) is the name of a file to open.
  This file will be read and its content placed in the request.  The
  routine will croak if the file can't be opened.  Use an C<undef> as
  $file value if you want to specify the content directly with a
  C<Content> header.  The $filename is the filename to report in the
  request.  If this value is undefined, then the basename of the $file
  will be used.  You can specify an empty string as $filename if you
  want to suppress sending the filename when you provide a $file value.
  
  If a $file is provided by no C<Content-Type> header, then C<Content-Type>
  and C<Content-Encoding> will be filled in automatically with the values
  returned by C<LWP::MediaTypes::guess_media_type()>
  
  Sending my F<~/.profile> to the survey used as example above can be
  achieved by this:
  
    POST 'http://www.perl.org/survey.cgi',
         Content_Type => 'form-data',
         Content      => [ name  => 'Gisle Aas',
                           email => 'gisle@aas.no',
                           gender => 'M',
                           born   => '1964',
                           init   => ["$ENV{HOME}/.profile"],
                         ]
  
  This will create an L<HTTP::Request> object that almost looks this (the
  boundary and the content of your F<~/.profile> is likely to be
  different):
  
    POST http://www.perl.org/survey.cgi
    Content-Length: 388
    Content-Type: multipart/form-data; boundary="6G+f"
  
    --6G+f
    Content-Disposition: form-data; name="name"
  
    Gisle Aas
    --6G+f
    Content-Disposition: form-data; name="email"
  
    gisle@aas.no
    --6G+f
    Content-Disposition: form-data; name="gender"
  
    M
    --6G+f
    Content-Disposition: form-data; name="born"
  
    1964
    --6G+f
    Content-Disposition: form-data; name="init"; filename=".profile"
    Content-Type: text/plain
  
    PATH=/local/perl/bin:$PATH
    export PATH
  
    --6G+f--
  
  If you set the C<$DYNAMIC_FILE_UPLOAD> variable (exportable) to some TRUE
  value, then you get back a request object with a subroutine closure as
  the content attribute.  This subroutine will read the content of any
  files on demand and return it in suitable chunks.  This allow you to
  upload arbitrary big files without using lots of memory.  You can even
  upload infinite files like F</dev/audio> if you wish; however, if
  the file is not a plain file, there will be no C<Content-Length> header
  defined for the request.  Not all servers (or server
  applications) like this.  Also, if the file(s) change in size between
  the time the C<Content-Length> is calculated and the time that the last
  chunk is delivered, the subroutine will C<Croak>.
  
  The C<post(...)>  method of L<LWP::UserAgent> exists as a shortcut for
  C<< $ua->request(POST ...) >>.
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Request>, L<LWP::UserAgent>
  
  Also, there are some examples in L<HTTP::Request/"EXAMPLES"> that you might
  find useful. For example, batch requests are explained there.
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  #ABSTRACT: Construct common HTTP::Request objects
HTTP_REQUEST_COMMON

    $fatpacked{"HTTP/Response.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'HTTP_RESPONSE';
  package HTTP::Response;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.44';
  
  use parent 'HTTP::Message';
  
  use HTTP::Status ();
  
  
  sub new
  {
      my($class, $rc, $msg, $header, $content) = @_;
      my $self = $class->SUPER::new($header, $content);
      $self->code($rc);
      $self->message($msg);
      $self;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
      Carp::carp('Undefined argument to parse()') if $^W && ! defined $str;
      my $status_line;
      if (defined $str && $str =~ s/^(.*)\n//) {
  	$status_line = $1;
      }
      else {
  	$status_line = $str;
  	$str = "";
      }
  
      $status_line =~ s/\r\z// if defined $status_line;
  
      my $self = $class->SUPER::parse($str);
      if (defined $status_line) {
          my($protocol, $code, $message);
          if ($status_line =~ /^\d{3} /) {
             # Looks like a response created by HTTP::Response->new
             ($code, $message) = split(' ', $status_line, 2);
          } else {
             ($protocol, $code, $message) = split(' ', $status_line, 3);
          }
          $self->protocol($protocol) if $protocol;
          $self->code($code) if defined($code);
          $self->message($message) if defined($message);
      }
      $self;
  }
  
  
  sub clone
  {
      my $self = shift;
      my $clone = bless $self->SUPER::clone, ref($self);
      $clone->code($self->code);
      $clone->message($self->message);
      $clone->request($self->request->clone) if $self->request;
      # we don't clone previous
      $clone;
  }
  
  
  sub code      { shift->_elem('_rc',      @_); }
  sub message   { shift->_elem('_msg',     @_); }
  sub previous  { shift->_elem('_previous',@_); }
  sub request   { shift->_elem('_request', @_); }
  
  
  sub status_line
  {
      my $self = shift;
      my $code = $self->{'_rc'}  || "000";
      my $mess = $self->{'_msg'} || HTTP::Status::status_message($code) || "Unknown code";
      return "$code $mess";
  }
  
  
  sub base
  {
      my $self = shift;
      my $base = (
  	$self->header('Content-Base'),        # used to be HTTP/1.1
  	$self->header('Base'),                # HTTP/1.0
      )[0];
      if ($base && $base =~ /^$URI::scheme_re:/o) {
  	# already absolute
  	return $HTTP::URI_CLASS->new($base);
      }
  
      my $req = $self->request;
      if ($req) {
          # if $base is undef here, the return value is effectively
          # just a copy of $self->request->uri.
          return $HTTP::URI_CLASS->new_abs($base, $req->uri);
      }
  
      # can't find an absolute base
      return undef;
  }
  
  
  sub redirects {
      my $self = shift;
      my @r;
      my $r = $self;
      while (my $p = $r->previous) {
          push(@r, $p);
          $r = $p;
      }
      return @r unless wantarray;
      return reverse @r;
  }
  
  
  sub filename
  {
      my $self = shift;
      my $file;
  
      my $cd = $self->header('Content-Disposition');
      if ($cd) {
  	require HTTP::Headers::Util;
  	if (my @cd = HTTP::Headers::Util::split_header_words($cd)) {
  	    my ($disposition, undef, %cd_param) = @{$cd[-1]};
  	    $file = $cd_param{filename};
  
  	    # RFC 2047 encoded?
  	    if ($file && $file =~ /^=\?(.+?)\?(.+?)\?(.+)\?=$/) {
  		my $charset = $1;
  		my $encoding = uc($2);
  		my $encfile = $3;
  
  		if ($encoding eq 'Q' || $encoding eq 'B') {
  		    local($SIG{__DIE__});
  		    eval {
  			if ($encoding eq 'Q') {
  			    $encfile =~ s/_/ /g;
  			    require MIME::QuotedPrint;
  			    $encfile = MIME::QuotedPrint::decode($encfile);
  			}
  			else { # $encoding eq 'B'
  			    require MIME::Base64;
  			    $encfile = MIME::Base64::decode($encfile);
  			}
  
  			require Encode;
  			require Encode::Locale;
  			Encode::from_to($encfile, $charset, "locale_fs");
  		    };
  
  		    $file = $encfile unless $@;
  		}
  	    }
  	}
      }
  
      unless (defined($file) && length($file)) {
  	my $uri;
  	if (my $cl = $self->header('Content-Location')) {
  	    $uri = URI->new($cl);
  	}
  	elsif (my $request = $self->request) {
  	    $uri = $request->uri;
  	}
  
  	if ($uri) {
  	    $file = ($uri->path_segments)[-1];
  	}
      }
  
      if ($file) {
  	$file =~ s,.*[\\/],,;  # basename
      }
  
      if ($file && !length($file)) {
  	$file = undef;
      }
  
      $file;
  }
  
  
  sub as_string
  {
      my $self = shift;
      my($eol) = @_;
      $eol = "\n" unless defined $eol;
  
      my $status_line = $self->status_line;
      my $proto = $self->protocol;
      $status_line = "$proto $status_line" if $proto;
  
      return join($eol, $status_line, $self->SUPER::as_string(@_));
  }
  
  
  sub dump
  {
      my $self = shift;
  
      my $status_line = $self->status_line;
      my $proto = $self->protocol;
      $status_line = "$proto $status_line" if $proto;
  
      return $self->SUPER::dump(
  	preheader => $status_line,
          @_,
      );
  }
  
  
  sub is_info     { HTTP::Status::is_info     (shift->{'_rc'}); }
  sub is_success  { HTTP::Status::is_success  (shift->{'_rc'}); }
  sub is_redirect { HTTP::Status::is_redirect (shift->{'_rc'}); }
  sub is_error    { HTTP::Status::is_error    (shift->{'_rc'}); }
  sub is_client_error { HTTP::Status::is_client_error (shift->{'_rc'}); }
  sub is_server_error { HTTP::Status::is_server_error (shift->{'_rc'}); }
  
  
  sub error_as_HTML
  {
      my $self = shift;
      my $title = 'An Error Occurred';
      my $body  = $self->status_line;
      $body =~ s/&/&amp;/g;
      $body =~ s/</&lt;/g;
      return <<EOM;
  <html>
  <head><title>$title</title></head>
  <body>
  <h1>$title</h1>
  <p>$body</p>
  </body>
  </html>
  EOM
  }
  
  
  sub current_age
  {
      my $self = shift;
      my $time = shift;
  
      # Implementation of RFC 2616 section 13.2.3
      # (age calculations)
      my $response_time = $self->client_date;
      my $date = $self->date;
  
      my $age = 0;
      if ($response_time && $date) {
  	$age = $response_time - $date;  # apparent_age
  	$age = 0 if $age < 0;
      }
  
      my $age_v = $self->header('Age');
      if ($age_v && $age_v > $age) {
  	$age = $age_v;   # corrected_received_age
      }
  
      if ($response_time) {
  	my $request = $self->request;
  	if ($request) {
  	    my $request_time = $request->date;
  	    if ($request_time && $request_time < $response_time) {
  		# Add response_delay to age to get 'corrected_initial_age'
  		$age += $response_time - $request_time;
  	    }
  	}
  	$age += ($time || time) - $response_time;
      }
      return $age;
  }
  
  
  sub freshness_lifetime
  {
      my($self, %opt) = @_;
  
      # First look for the Cache-Control: max-age=n header
      for my $cc ($self->header('Cache-Control')) {
  	for my $cc_dir (split(/\s*,\s*/, $cc)) {
  	    return $1 if $cc_dir =~ /^max-age\s*=\s*(\d+)/i;
  	}
      }
  
      # Next possibility is to look at the "Expires" header
      my $date = $self->date || $self->client_date || $opt{time} || time;
      if (my $expires = $self->expires) {
  	return $expires - $date;
      }
  
      # Must apply heuristic expiration
      return undef if exists $opt{heuristic_expiry} && !$opt{heuristic_expiry};
  
      # Default heuristic expiration parameters
      $opt{h_min} ||= 60;
      $opt{h_max} ||= 24 * 3600;
      $opt{h_lastmod_fraction} ||= 0.10; # 10% since last-mod suggested by RFC2616
      $opt{h_default} ||= 3600;
  
      # Should give a warning if more than 24 hours according to
      # RFC 2616 section 13.2.4.  Here we just make this the default
      # maximum value.
  
      if (my $last_modified = $self->last_modified) {
  	my $h_exp = ($date - $last_modified) * $opt{h_lastmod_fraction};
  	return $opt{h_min} if $h_exp < $opt{h_min};
  	return $opt{h_max} if $h_exp > $opt{h_max};
  	return $h_exp;
      }
  
      # default when all else fails
      return $opt{h_min} if $opt{h_min} > $opt{h_default};
      return $opt{h_default};
  }
  
  
  sub is_fresh
  {
      my($self, %opt) = @_;
      $opt{time} ||= time;
      my $f = $self->freshness_lifetime(%opt);
      return undef unless defined($f);
      return $f > $self->current_age($opt{time});
  }
  
  
  sub fresh_until
  {
      my($self, %opt) = @_;
      $opt{time} ||= time;
      my $f = $self->freshness_lifetime(%opt);
      return undef unless defined($f);
      return $f - $self->current_age($opt{time}) + $opt{time};
  }
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Response - HTTP style response message
  
  =head1 VERSION
  
  version 6.44
  
  =head1 SYNOPSIS
  
  Response objects are returned by the request() method of the C<LWP::UserAgent>:
  
      # ...
      $response = $ua->request($request);
      if ($response->is_success) {
          print $response->decoded_content;
      }
      else {
          print STDERR $response->status_line, "\n";
      }
  
  =head1 DESCRIPTION
  
  The C<HTTP::Response> class encapsulates HTTP style responses.  A
  response consists of a response line, some headers, and a content
  body. Note that the LWP library uses HTTP style responses even for
  non-HTTP protocol schemes.  Instances of this class are usually
  created and returned by the request() method of an C<LWP::UserAgent>
  object.
  
  C<HTTP::Response> is a subclass of C<HTTP::Message> and therefore
  inherits its methods.  The following additional methods are available:
  
  =over 4
  
  =item $r = HTTP::Response->new( $code )
  
  =item $r = HTTP::Response->new( $code, $msg )
  
  =item $r = HTTP::Response->new( $code, $msg, $header )
  
  =item $r = HTTP::Response->new( $code, $msg, $header, $content )
  
  Constructs a new C<HTTP::Response> object describing a response with
  response code $code and optional message $msg.  The optional $header
  argument should be a reference to an C<HTTP::Headers> object or a
  plain array reference of key/value pairs.  The optional $content
  argument should be a string of bytes.  The meanings of these arguments are
  described below.
  
  =item $r = HTTP::Response->parse( $str )
  
  This constructs a new response object by parsing the given string.
  
  =item $r->code
  
  =item $r->code( $code )
  
  This is used to get/set the code attribute.  The code is a 3 digit
  number that encode the overall outcome of an HTTP response.  The
  C<HTTP::Status> module provide constants that provide mnemonic names
  for the code attribute.
  
  =item $r->message
  
  =item $r->message( $message )
  
  This is used to get/set the message attribute.  The message is a short
  human readable single line string that explains the response code.
  
  =item $r->header( $field )
  
  =item $r->header( $field => $value )
  
  This is used to get/set header values and it is inherited from
  C<HTTP::Headers> via C<HTTP::Message>.  See L<HTTP::Headers> for
  details and other similar methods that can be used to access the
  headers.
  
  =item $r->content
  
  =item $r->content( $bytes )
  
  This is used to get/set the raw content and it is inherited from the
  C<HTTP::Message> base class.  See L<HTTP::Message> for details and
  other methods that can be used to access the content.
  
  =item $r->decoded_content( %options )
  
  This will return the content after any C<Content-Encoding> and
  charsets have been decoded.  See L<HTTP::Message> for details.
  
  =item $r->request
  
  =item $r->request( $request )
  
  This is used to get/set the request attribute.  The request attribute
  is a reference to the request that caused this response.  It does
  not have to be the same request passed to the $ua->request() method,
  because there might have been redirects and authorization retries in
  between.
  
  =item $r->previous
  
  =item $r->previous( $response )
  
  This is used to get/set the previous attribute.  The previous
  attribute is used to link together chains of responses.  You get
  chains of responses if the first response is redirect or unauthorized.
  The value is C<undef> if this is the first response in a chain.
  
  Note that the method $r->redirects is provided as a more convenient
  way to access the response chain.
  
  =item $r->status_line
  
  Returns the string "E<lt>code> E<lt>message>".  If the message attribute
  is not set then the official name of E<lt>code> (see L<HTTP::Status>)
  is substituted.
  
  =item $r->base
  
  Returns the base URI for this response.  The return value will be a
  reference to a URI object.
  
  The base URI is obtained from one the following sources (in priority
  order):
  
  =over 4
  
  =item 1.
  
  Embedded in the document content, for instance <BASE HREF="...">
  in HTML documents.
  
  =item 2.
  
  A "Content-Base:" header in the response.
  
  For backwards compatibility with older HTTP implementations we will
  also look for the "Base:" header.
  
  =item 3.
  
  The URI used to request this response. This might not be the original
  URI that was passed to $ua->request() method, because we might have
  received some redirect responses first.
  
  =back
  
  If none of these sources provide an absolute URI, undef is returned.
  
  B<Note>: previous versions of HTTP::Response would also consider
  a "Content-Location:" header,
  as L<RFC 2616|https://www.rfc-editor.org/rfc/rfc2616> said it should be.
  But this was never widely implemented by browsers,
  and now L<RFC 7231|https://www.rfc-editor.org/rfc/rfc7231>
  says it should no longer be considered.
  
  When the LWP protocol modules produce the HTTP::Response object, then any base
  URI embedded in the document (step 1) will already have initialized the
  "Content-Base:" header. (See L<LWP::UserAgent/parse_head>).  This means that
  this method only performs the last 2 steps (the content is not always available
  either).
  
  =item $r->filename
  
  Returns a filename for this response.  Note that doing sanity checks
  on the returned filename (eg. removing characters that cannot be used
  on the target filesystem where the filename would be used, and
  laundering it for security purposes) are the caller's responsibility;
  the only related thing done by this method is that it makes a simple
  attempt to return a plain filename with no preceding path segments.
  
  The filename is obtained from one the following sources (in priority
  order):
  
  =over 4
  
  =item 1.
  
  A "Content-Disposition:" header in the response.  Proper decoding of
  RFC 2047 encoded filenames requires the C<MIME::QuotedPrint> (for "Q"
  encoding), C<MIME::Base64> (for "B" encoding), and C<Encode> modules.
  
  =item 2.
  
  A "Content-Location:" header in the response.
  
  =item 3.
  
  The URI used to request this response. This might not be the original
  URI that was passed to $ua->request() method, because we might have
  received some redirect responses first.
  
  =back
  
  If a filename cannot be derived from any of these sources, undef is
  returned.
  
  =item $r->as_string
  
  =item $r->as_string( $eol )
  
  Returns a textual representation of the response.
  
  =item $r->is_info
  
  =item $r->is_success
  
  =item $r->is_redirect
  
  =item $r->is_error
  
  =item $r->is_client_error
  
  =item $r->is_server_error
  
  These methods indicate if the response was informational, successful, a
  redirection, or an error.  See L<HTTP::Status> for the meaning of these.
  
  =item $r->error_as_HTML
  
  Returns a string containing a complete HTML document indicating what
  error occurred.  This method should only be called when $r->is_error
  is TRUE.
  
  =item $r->redirects
  
  Returns the list of redirect responses that lead up to this response
  by following the $r->previous chain.  The list order is oldest first.
  
  In scalar context return the number of redirect responses leading up
  to this one.
  
  =item $r->current_age
  
  Calculates the "current age" of the response as specified by RFC 2616
  section 13.2.3.  The age of a response is the time since it was sent
  by the origin server.  The returned value is a number representing the
  age in seconds.
  
  =item $r->freshness_lifetime( %opt )
  
  Calculates the "freshness lifetime" of the response as specified by
  RFC 2616 section 13.2.4.  The "freshness lifetime" is the length of
  time between the generation of a response and its expiration time.
  The returned value is the number of seconds until expiry.
  
  If the response does not contain an "Expires" or a "Cache-Control"
  header, then this function will apply some simple heuristic based on
  the "Last-Modified" header to determine a suitable lifetime.  The
  following options might be passed to control the heuristics:
  
  =over
  
  =item heuristic_expiry => $bool
  
  If passed as a FALSE value, don't apply heuristics and just return
  C<undef> when "Expires" or "Cache-Control" is lacking.
  
  =item h_lastmod_fraction => $num
  
  This number represent the fraction of the difference since the
  "Last-Modified" timestamp to make the expiry time.  The default is
  C<0.10>, the suggested typical setting of 10% in RFC 2616.
  
  =item h_min => $sec
  
  This is the lower limit of the heuristic expiry age to use.  The
  default is C<60> (1 minute).
  
  =item h_max => $sec
  
  This is the upper limit of the heuristic expiry age to use.  The
  default is C<86400> (24 hours).
  
  =item h_default => $sec
  
  This is the expiry age to use when nothing else applies.  The default
  is C<3600> (1 hour) or "h_min" if greater.
  
  =back
  
  =item $r->is_fresh( %opt )
  
  Returns TRUE if the response is fresh, based on the values of
  freshness_lifetime() and current_age().  If the response is no longer
  fresh, then it has to be re-fetched or re-validated by the origin
  server.
  
  Options might be passed to control expiry heuristics, see the
  description of freshness_lifetime().
  
  =item $r->fresh_until( %opt )
  
  Returns the time (seconds since epoch) when this entity is no longer fresh.
  
  Options might be passed to control expiry heuristics, see the
  description of freshness_lifetime().
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>, L<HTTP::Message>, L<HTTP::Status>, L<HTTP::Request>
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  #ABSTRACT: HTTP style response message
  
HTTP_RESPONSE

    $fatpacked{"HTTP/Server/PSGI.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'HTTP_SERVER_PSGI';
  package HTTP::Server::PSGI;
  use strict;
  use warnings;
  
  use Carp ();
  use Plack;
  use Plack::HTTPParser qw( parse_http_request );
  use IO::Socket::INET;
  use HTTP::Date;
  use HTTP::Status;
  use List::Util qw(max sum);
  use Plack::Util;
  use Stream::Buffered;
  use Plack::Middleware::ContentLength;
  use POSIX qw(EINTR);
  use Socket qw(IPPROTO_TCP);
  
  use Try::Tiny;
  use Time::HiRes qw(time);
  
  use constant TCP_NODELAY => try { Socket::TCP_NODELAY };
  
  my $alarm_interval;
  BEGIN {
      if ($^O eq 'MSWin32') {
          $alarm_interval = 1;
      } else {
          Time::HiRes->import('alarm');
          $alarm_interval = 0.1;
      }
  }
  
  use constant MAX_REQUEST_SIZE => 131072;
  use constant MSWin32          => $^O eq 'MSWin32';
  
  sub new {
      my($class, %args) = @_;
  
      my $self = bless {
          ($args{listen_sock} ? (
              listen_sock    => $args{listen_sock},
              host           => $args{listen_sock}->sockhost,
              port           => $args{listen_sock}->sockport,
          ):(
              host           => $args{host} || 0,
              port           => $args{port} || 8080,
          )),
          timeout            => $args{timeout} || 300,
          server_software    => $args{server_software} || $class,
          server_ready       => $args{server_ready} || sub {},
          ssl                => $args{ssl},
          ipv6               => $args{ipv6},
          ssl_key_file       => $args{ssl_key_file},
          ssl_cert_file      => $args{ssl_cert_file},
      }, $class;
  
      $self;
  }
  
  sub run {
      my($self, $app) = @_;
      $self->setup_listener();
      $self->accept_loop($app);
  }
  
  sub prepare_socket_class {
      my($self, $args) = @_;
  
      if ($self->{ssl} && $self->{ipv6}) {
          Carp::croak("SSL and IPv6 are not supported at the same time (yet). Choose one.");
      }
  
      if ($self->{ssl}) {
          eval { require IO::Socket::SSL; 1 }
              or Carp::croak("SSL suport requires IO::Socket::SSL");
          $args->{SSL_key_file}  = $self->{ssl_key_file};
          $args->{SSL_cert_file} = $self->{ssl_cert_file};
          return "IO::Socket::SSL";
      } elsif ($self->{ipv6}) {
          eval { require IO::Socket::IP; 1 }
              or Carp::croak("IPv6 support requires IO::Socket::IP");
          $self->{host}      ||= '::';
          $args->{LocalAddr} ||= '::';
          return "IO::Socket::IP";
      }
  
      return "IO::Socket::INET";
  }
  
  sub setup_listener {
      my $self = shift;
  
      $self->{listen_sock} ||= do {
          my %args = (
              Listen    => SOMAXCONN,
              LocalPort => $self->{port},
              LocalAddr => $self->{host},
              Proto     => 'tcp',
              ReuseAddr => 1,
          );
  
          my $class = $self->prepare_socket_class(\%args);
          $class->new(%args)
              or die "failed to listen to port $self->{port}: $!";
      };
  
      $self->{server_ready}->({ %$self, proto => $self->{ssl} ? 'https' : 'http' });
  }
  
  sub accept_loop {
      my($self, $app) = @_;
  
      $app = Plack::Middleware::ContentLength->wrap($app);
  
      while (1) {
          local $SIG{PIPE} = 'IGNORE';
          if (my $conn = $self->{listen_sock}->accept) {
              if (defined TCP_NODELAY) {
                  $conn->setsockopt(IPPROTO_TCP, TCP_NODELAY, 1)
                      or die "setsockopt(TCP_NODELAY) failed:$!";
              }
              my $env = {
                  SERVER_PORT => $self->{port},
                  SERVER_NAME => $self->{host},
                  SCRIPT_NAME => '',
                  REMOTE_ADDR => $conn->peerhost,
                  REMOTE_PORT => $conn->peerport || 0,
                  'psgi.version' => [ 1, 1 ],
                  'psgi.errors'  => *STDERR,
                  'psgi.url_scheme' => $self->{ssl} ? 'https' : 'http',
                  'psgi.run_once'     => Plack::Util::FALSE,
                  'psgi.multithread'  => Plack::Util::FALSE,
                  'psgi.multiprocess' => Plack::Util::FALSE,
                  'psgi.streaming'    => Plack::Util::TRUE,
                  'psgi.nonblocking'  => Plack::Util::FALSE,
                  'psgix.harakiri'    => Plack::Util::TRUE,
                  'psgix.input.buffered' => Plack::Util::TRUE,
                  'psgix.io'          => $conn,
              };
  
              $self->handle_connection($env, $conn, $app);
              $conn->close;
              last if $env->{'psgix.harakiri.commit'};
          }
      }
  }
  
  sub handle_connection {
      my($self, $env, $conn, $app) = @_;
  
      my $buf = '';
      my $res = [ 400, [ 'Content-Type' => 'text/plain' ], [ 'Bad Request' ] ];
  
      while (1) {
          my $rlen = $self->read_timeout(
              $conn, \$buf, MAX_REQUEST_SIZE - length($buf), length($buf),
              $self->{timeout},
          ) or return;
          my $reqlen = parse_http_request($buf, $env);
          if ($reqlen >= 0) {
              $buf = substr $buf, $reqlen;
              if (my $cl = $env->{CONTENT_LENGTH}) {
                  my $buffer = Stream::Buffered->new($cl);
                  while ($cl > 0) {
                      my $chunk;
                      if (length $buf) {
                          $chunk = $buf;
                          $buf = '';
                      } else {
                          $self->read_timeout($conn, \$chunk, $cl, 0, $self->{timeout})
                              or return;
                      }
                      $buffer->print($chunk);
                      $cl -= length $chunk;
                  }
                  $env->{'psgi.input'} = $buffer->rewind;
              } else {
                  open my $input, "<", \$buf;
                  $env->{'psgi.input'} = $input;
              }
  
              $res = Plack::Util::run_app $app, $env;
              last;
          }
          if ($reqlen == -2) {
              # request is incomplete, do nothing
          } elsif ($reqlen == -1) {
              # error, close conn
              last;
          }
      }
  
      if (ref $res eq 'ARRAY') {
          $self->_handle_response($res, $conn);
      } elsif (ref $res eq 'CODE') {
          $res->(sub {
              $self->_handle_response($_[0], $conn);
          });
      } else {
          die "Bad response $res";
      }
  
      return;
  }
  
  sub _handle_response {
      my($self, $res, $conn) = @_;
  
      my @lines = (
          "Date: @{[HTTP::Date::time2str()]}\015\012",
          "Server: $self->{server_software}\015\012",
      );
  
      Plack::Util::header_iter($res->[1], sub {
          my ($k, $v) = @_;
          push @lines, "$k: $v\015\012";
      });
  
      unshift @lines, "HTTP/1.0 $res->[0] @{[ HTTP::Status::status_message($res->[0]) ]}\015\012";
      push @lines, "\015\012";
  
      $self->write_all($conn, join('', @lines), $self->{timeout})
          or return;
  
      if (defined $res->[2]) {
          my $err;
          my $done;
          {
              local $@;
              eval {
                  Plack::Util::foreach(
                      $res->[2],
                      sub {
                          $self->write_all($conn, $_[0], $self->{timeout})
                              or die "failed to send all data\n";
                      },
                  );
                  $done = 1;
              };
              $err = $@;
          };
          unless ($done) {
              if ($err =~ /^failed to send all data\n/) {
                  return;
              } else {
                  die $err;
              }
          }
      } else {
          return Plack::Util::inline_object
              write => sub { $self->write_all($conn, $_[0], $self->{timeout}) },
              close => sub { };
      }
  }
  
  # returns 1 if socket is ready, undef on timeout
  sub do_timeout {
      my ($self, $cb, $timeout) = @_;
      local $SIG{ALRM} = sub {};
      my $wait_until = time + $timeout;
      alarm($timeout);
      my $ret;
      while (1) {
          if ($ret = $cb->()) {
              last;
          } elsif (! (! defined($ret) && $! == EINTR)) {
              undef $ret;
              last;
          }
          # got EINTR
          my $left = $wait_until - time;
          last if $left <= 0;
          alarm($left + $alarm_interval);
      }
      alarm(0);
      $ret;
  }
  
  # returns (positive) number of bytes read, or undef if the socket is to be closed
  sub read_timeout {
      my ($self, $sock, $buf, $len, $off, $timeout) = @_;
      $self->do_timeout(sub { $sock->sysread($$buf, $len, $off) }, $timeout);
  }
  
  # returns (positive) number of bytes written, or undef if the socket is to be closed
  sub write_timeout {
      my ($self, $sock, $buf, $len, $off, $timeout) = @_;
      $self->do_timeout(sub { $sock->syswrite($buf, $len, $off) }, $timeout);
  }
  
  # writes all data in buf and returns number of bytes written or undef if failed
  sub write_all {
      my ($self, $sock, $buf, $timeout) = @_;
      return 0 unless defined $buf;
      _encode($buf);
      my $off = 0;
      while (my $len = length($buf) - $off) {
          my $ret = $self->write_timeout($sock, $buf, $len, $off, $timeout)
              or return;
          $off += $ret;
      }
      return length $buf;
  }
  
  # syswrite() will crash when given wide characters
  sub _encode {
      if ($_[0] =~ /[^\x00-\xff]/) {
          Carp::carp("Wide character outside byte range in response. Encoding data as UTF-8");
          utf8::encode($_[0]);
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Server::PSGI - Standalone PSGI compatible HTTP server
  
  =head1 SYNOPSIS
  
    use HTTP::Server::PSGI;
  
    my $server = HTTP::Server::PSGI->new(
        host => "127.0.0.1",
        port => 9091,
        timeout => 120,
    );
  
    $server->run($app);
  
  =head1 DESCRIPTION
  
  HTTP::Server::PSGI is a standalone, single-process and PSGI compatible
  HTTP server implementations.
  
  This server should be great for the development and testing, but might
  not be suitable for a production use.
  
  Some features in HTTP/1.1, notably chunked requests, responses and
  pipeline requests are B<NOT> supported, and it also does not support
  HTTP/0.9.
  
  See L<Starman> or uWSGI server if you want HTTP/1.1 and other features
  ready for a production use.
  
  =head1 PREFORKING
  
  L<HTTP::Server::PSGI> does B<NOT> support preforking. See L<Starman>
  or L<Starlet> if you want a multi-process prefork web servers.
  
  =head1 HARAKIRI SUPPORT
  
  This web server supports `psgix.harakiri` extension defined in the
  L<PSGI::Extensions>.
  
  This application is a non-forking single process web server
  (i.e. `psgi.multiprocess` is false), and if your application commits
  harakiri, the entire web server stops too. In case this behavior is
  not what you want, be sure to check `psgi.multiprocess` as well to
  enable harakiri only in the preforking servers such as L<Starman>.
  
  On the other hand, this behavior might be handy if you want to embed
  this module in your application and serve HTTP requests for only short
  period of time, then go back to your main program.
  
  =head1 AUTHOR
  
  Kazuho Oku
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Handler::Standalone> L<Starman> L<Starlet>
  
  =cut
HTTP_SERVER_PSGI

    $fatpacked{"HTTP/Status.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'HTTP_STATUS';
  package HTTP::Status;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.44';
  
  use Exporter 5.57 'import';
  
  our @EXPORT = qw(is_info is_success is_redirect is_error status_message);
  our @EXPORT_OK = qw(is_client_error is_server_error is_cacheable_by_default status_constant_name);
  
  # Note also addition of mnemonics to @EXPORT below
  
  # Unmarked codes are from RFC 7231 (2017-12-20)
  # See also:
  # https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
  
  my %StatusCode = (
      100 => 'Continue',
      101 => 'Switching Protocols',
      102 => 'Processing',                      # RFC 2518: WebDAV
      103 => 'Early Hints',                     # RFC 8297: Indicating Hints
  #   104 .. 199
      200 => 'OK',
      201 => 'Created',
      202 => 'Accepted',
      203 => 'Non-Authoritative Information',
      204 => 'No Content',
      205 => 'Reset Content',
      206 => 'Partial Content',                 # RFC 7233: Range Requests
      207 => 'Multi-Status',                    # RFC 4918: WebDAV
      208 => 'Already Reported',                # RFC 5842: WebDAV bindings
  #   209 .. 225
      226 => 'IM Used',                         # RFC 3229: Delta encoding
  #   227 .. 299
      300 => 'Multiple Choices',
      301 => 'Moved Permanently',
      302 => 'Found',
      303 => 'See Other',
      304 => 'Not Modified',                    # RFC 7232: Conditional Request
      305 => 'Use Proxy',
      307 => 'Temporary Redirect',
      308 => 'Permanent Redirect',              # RFC 7528: Permanent Redirect
  #   309 .. 399
      400 => 'Bad Request',
      401 => 'Unauthorized',                    # RFC 7235: Authentication
      402 => 'Payment Required',
      403 => 'Forbidden',
      404 => 'Not Found',
      405 => 'Method Not Allowed',
      406 => 'Not Acceptable',
      407 => 'Proxy Authentication Required',   # RFC 7235: Authentication
      408 => 'Request Timeout',
      409 => 'Conflict',
      410 => 'Gone',
      411 => 'Length Required',
      412 => 'Precondition Failed',             # RFC 7232: Conditional Request
      413 => 'Payload Too Large',
      414 => 'URI Too Long',
      415 => 'Unsupported Media Type',
      416 => 'Range Not Satisfiable',           # RFC 7233: Range Requests
      417 => 'Expectation Failed',
  #   418 .. 420
      421 => 'Misdirected Request',             # RFC 7540: HTTP/2
      422 => 'Unprocessable Entity',            # RFC 4918: WebDAV
      423 => 'Locked',                          # RFC 4918: WebDAV
      424 => 'Failed Dependency',               # RFC 4918: WebDAV
      425 => 'Too Early',                       # RFC 8470: Using Early Data in HTTP
      426 => 'Upgrade Required',
  #   427
      428 => 'Precondition Required',           # RFC 6585: Additional Codes
      429 => 'Too Many Requests',               # RFC 6585: Additional Codes
  #   430
      431 => 'Request Header Fields Too Large', # RFC 6585: Additional Codes
  #   432 .. 450
      451 => 'Unavailable For Legal Reasons',   # RFC 7725: Legal Obstacles
  #   452 .. 499
      500 => 'Internal Server Error',
      501 => 'Not Implemented',
      502 => 'Bad Gateway',
      503 => 'Service Unavailable',
      504 => 'Gateway Timeout',
      505 => 'HTTP Version Not Supported',
      506 => 'Variant Also Negotiates',         # RFC 2295: Transparant Ngttn
      507 => 'Insufficient Storage',            # RFC 4918: WebDAV
      508 => 'Loop Detected',                   # RFC 5842: WebDAV bindings
  #   509
      510 => 'Not Extended',                    # RFC 2774: Extension Framework
      511 => 'Network Authentication Required', # RFC 6585: Additional Codes
  );
  
  my %StatusCodeName;
  
  # keep some unofficial codes that used to be in this distribution
  %StatusCode = (
      %StatusCode,
      418 => 'I\'m a teapot',                   # RFC 2324: HTCPC/1.0  1-april
      449 => 'Retry with',                      #           microsoft
      509 => 'Bandwidth Limit Exceeded',        #           Apache / cPanel
  );
  
  my $mnemonicCode = '';
  my ($code, $message);
  while (($code, $message) = each %StatusCode) {
      # create mnemonic subroutines
      $message =~ s/I'm/I am/;
      $message =~ tr/a-z \-/A-Z__/;
      my $constant_name = "HTTP_".$message;
      $mnemonicCode .= "sub $constant_name () { $code }\n";
      $mnemonicCode .= "*RC_$message = \\&HTTP_$message;\n";  # legacy
      $mnemonicCode .= "push(\@EXPORT_OK, 'HTTP_$message');\n";
      $mnemonicCode .= "push(\@EXPORT, 'RC_$message');\n";
      $StatusCodeName{$code} = $constant_name
  }
  eval $mnemonicCode; # only one eval for speed
  die if $@;
  
  # backwards compatibility
  *RC_MOVED_TEMPORARILY = \&RC_FOUND;  # 302 was renamed in the standard
  push(@EXPORT, "RC_MOVED_TEMPORARILY");
  
  my %compat = (
      REQUEST_ENTITY_TOO_LARGE      => \&HTTP_PAYLOAD_TOO_LARGE,
      REQUEST_URI_TOO_LARGE         => \&HTTP_URI_TOO_LONG,
      REQUEST_RANGE_NOT_SATISFIABLE => \&HTTP_RANGE_NOT_SATISFIABLE,
      NO_CODE                       => \&HTTP_TOO_EARLY,
      UNORDERED_COLLECTION          => \&HTTP_TOO_EARLY,
  );
  
  foreach my $name (keys %compat) {
      push(@EXPORT, "RC_$name");
      push(@EXPORT_OK, "HTTP_$name");
      no strict 'refs';
      *{"RC_$name"} = $compat{$name};
      *{"HTTP_$name"} = $compat{$name};
  }
  
  our %EXPORT_TAGS = (
     constants => [grep /^HTTP_/, @EXPORT_OK],
     is => [grep /^is_/, @EXPORT, @EXPORT_OK],
  );
  
  
  sub status_message  ($) { $StatusCode{$_[0]}; }
  sub status_constant_name ($) {
      exists($StatusCodeName{$_[0]}) ? $StatusCodeName{$_[0]} : undef;
  }
  
  sub is_info                 ($) { $_[0] && $_[0] >= 100 && $_[0] < 200; }
  sub is_success              ($) { $_[0] && $_[0] >= 200 && $_[0] < 300; }
  sub is_redirect             ($) { $_[0] && $_[0] >= 300 && $_[0] < 400; }
  sub is_error                ($) { $_[0] && $_[0] >= 400 && $_[0] < 600; }
  sub is_client_error         ($) { $_[0] && $_[0] >= 400 && $_[0] < 500; }
  sub is_server_error         ($) { $_[0] && $_[0] >= 500 && $_[0] < 600; }
  sub is_cacheable_by_default ($) { $_[0] && ( $_[0] == 200 # OK
                                            || $_[0] == 203 # Non-Authoritative Information
                                            || $_[0] == 204 # No Content
                                            || $_[0] == 206 # Not Acceptable
                                            || $_[0] == 300 # Multiple Choices
                                            || $_[0] == 301 # Moved Permanently
                                            || $_[0] == 308 # Permanent Redirect
                                            || $_[0] == 404 # Not Found
                                            || $_[0] == 405 # Method Not Allowed
                                            || $_[0] == 410 # Gone
                                            || $_[0] == 414 # Request-URI Too Large
                                            || $_[0] == 451 # Unavailable For Legal Reasons
                                            || $_[0] == 501 # Not Implemented
                                              );
  }
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Status - HTTP Status code processing
  
  =head1 VERSION
  
  version 6.44
  
  =head1 SYNOPSIS
  
   use HTTP::Status qw(:constants :is status_message);
  
   if ($rc != HTTP_OK) {
       print status_message($rc), "\n";
   }
  
   if (is_success($rc)) { ... }
   if (is_error($rc)) { ... }
   if (is_redirect($rc)) { ... }
  
  =head1 DESCRIPTION
  
  I<HTTP::Status> is a library of routines for defining and
  classifying HTTP status codes for libwww-perl.  Status codes are
  used to encode the overall outcome of an HTTP response message.  Codes
  correspond to those defined in RFC 2616 and RFC 2518.
  
  =head1 CONSTANTS
  
  The following constant functions can be used as mnemonic status code
  names.  None of these are exported by default.  Use the C<:constants>
  tag to import them all.
  
     HTTP_CONTINUE                        (100)
     HTTP_SWITCHING_PROTOCOLS             (101)
     HTTP_PROCESSING                      (102)
     HTTP_EARLY_HINTS                     (103)
  
     HTTP_OK                              (200)
     HTTP_CREATED                         (201)
     HTTP_ACCEPTED                        (202)
     HTTP_NON_AUTHORITATIVE_INFORMATION   (203)
     HTTP_NO_CONTENT                      (204)
     HTTP_RESET_CONTENT                   (205)
     HTTP_PARTIAL_CONTENT                 (206)
     HTTP_MULTI_STATUS                    (207)
     HTTP_ALREADY_REPORTED                (208)
  
     HTTP_IM_USED                         (226)
  
     HTTP_MULTIPLE_CHOICES                (300)
     HTTP_MOVED_PERMANENTLY               (301)
     HTTP_FOUND                           (302)
     HTTP_SEE_OTHER                       (303)
     HTTP_NOT_MODIFIED                    (304)
     HTTP_USE_PROXY                       (305)
     HTTP_TEMPORARY_REDIRECT              (307)
     HTTP_PERMANENT_REDIRECT              (308)
  
     HTTP_BAD_REQUEST                     (400)
     HTTP_UNAUTHORIZED                    (401)
     HTTP_PAYMENT_REQUIRED                (402)
     HTTP_FORBIDDEN                       (403)
     HTTP_NOT_FOUND                       (404)
     HTTP_METHOD_NOT_ALLOWED              (405)
     HTTP_NOT_ACCEPTABLE                  (406)
     HTTP_PROXY_AUTHENTICATION_REQUIRED   (407)
     HTTP_REQUEST_TIMEOUT                 (408)
     HTTP_CONFLICT                        (409)
     HTTP_GONE                            (410)
     HTTP_LENGTH_REQUIRED                 (411)
     HTTP_PRECONDITION_FAILED             (412)
     HTTP_PAYLOAD_TOO_LARGE               (413)
     HTTP_URI_TOO_LONG                    (414)
     HTTP_UNSUPPORTED_MEDIA_TYPE          (415)
     HTTP_RANGE_NOT_SATISFIABLE           (416)
     HTTP_EXPECTATION_FAILED              (417)
     HTTP_MISDIRECTED REQUEST             (421)
     HTTP_UNPROCESSABLE_ENTITY            (422)
     HTTP_LOCKED                          (423)
     HTTP_FAILED_DEPENDENCY               (424)
     HTTP_TOO_EARLY                       (425)
     HTTP_UPGRADE_REQUIRED                (426)
     HTTP_PRECONDITION_REQUIRED           (428)
     HTTP_TOO_MANY_REQUESTS               (429)
     HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE (431)
     HTTP_UNAVAILABLE_FOR_LEGAL_REASONS   (451)
  
     HTTP_INTERNAL_SERVER_ERROR           (500)
     HTTP_NOT_IMPLEMENTED                 (501)
     HTTP_BAD_GATEWAY                     (502)
     HTTP_SERVICE_UNAVAILABLE             (503)
     HTTP_GATEWAY_TIMEOUT                 (504)
     HTTP_HTTP_VERSION_NOT_SUPPORTED      (505)
     HTTP_VARIANT_ALSO_NEGOTIATES         (506)
     HTTP_INSUFFICIENT_STORAGE            (507)
     HTTP_LOOP_DETECTED                   (508)
     HTTP_NOT_EXTENDED                    (510)
     HTTP_NETWORK_AUTHENTICATION_REQUIRED (511)
  
  =head1 FUNCTIONS
  
  The following additional functions are provided.  Most of them are
  exported by default.  The C<:is> import tag can be used to import all
  the classification functions.
  
  =over 4
  
  =item status_message( $code )
  
  The status_message() function will translate status codes to human
  readable strings. The string is the same as found in the constant
  names above.
  For example, C<status_message(303)> will return C<"Not Found">.
  
  If the $code is not registered in the L<list of IANA HTTP Status
  Codes|https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml>
  then C<undef> is returned.
  
  =item status_constant_name( $code )
  
  The status_constant_name() function will translate a status code
  to a string which has the name of the constant for that status code.
  For example, C<status_constant_name(404)> will return C<"HTTP_NOT_FOUND">.
  
  If the C<$code> is not registered in the L<list of IANA HTTP Status
  Codes|https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml>
  then C<undef> is returned.
  
  =item is_info( $code )
  
  Return TRUE if C<$code> is an I<Informational> status code (1xx).  This
  class of status code indicates a provisional response which can't have
  any content.
  
  =item is_success( $code )
  
  Return TRUE if C<$code> is a I<Successful> status code (2xx).
  
  =item is_redirect( $code )
  
  Return TRUE if C<$code> is a I<Redirection> status code (3xx). This class of
  status code indicates that further action needs to be taken by the
  user agent in order to fulfill the request.
  
  =item is_error( $code )
  
  Return TRUE if C<$code> is an I<Error> status code (4xx or 5xx).  The function
  returns TRUE for both client and server error status codes.
  
  =item is_client_error( $code )
  
  Return TRUE if C<$code> is a I<Client Error> status code (4xx). This class
  of status code is intended for cases in which the client seems to have
  erred.
  
  This function is B<not> exported by default.
  
  =item is_server_error( $code )
  
  Return TRUE if C<$code> is a I<Server Error> status code (5xx). This class
  of status codes is intended for cases in which the server is aware
  that it has erred or is incapable of performing the request.
  
  This function is B<not> exported by default.
  
  =item is_cacheable_by_default( $code )
  
  Return TRUE if C<$code> indicates that a response is cacheable by default, and
  it can be reused by a cache with heuristic expiration. All other status codes
  are not cacheable by default. See L<RFC 7231 - HTTP/1.1 Semantics and Content,
  Section 6.1. Overview of Status Codes|https://tools.ietf.org/html/rfc7231#section-6.1>.
  
  This function is B<not> exported by default.
  
  =back
  
  =head1 SEE ALSO
  
  L<IANA HTTP Status Codes|https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml>
  
  =head1 BUGS
  
  For legacy reasons all the C<HTTP_> constants are exported by default
  with the prefix C<RC_>.  It's recommended to use explicit imports and
  the C<:constants> tag instead of relying on this.
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  #ABSTRACT: HTTP Status code processing
HTTP_STATUS

    $fatpacked{"HTTP/Tiny.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'HTTP_TINY';
  # vim: ts=4 sts=4 sw=4 et:
  package HTTP::Tiny;
  use strict;
  use warnings;
  # ABSTRACT: A small, simple, correct HTTP/1.1 client
  
  our $VERSION = '0.084';
  
  sub _croak { require Carp; Carp::croak(@_) }
  
  #pod =method new
  #pod
  #pod     $http = HTTP::Tiny->new( %attributes );
  #pod
  #pod This constructor returns a new HTTP::Tiny object.  Valid attributes include:
  #pod
  #pod =for :list
  #pod * C<agent>  A user-agent string (defaults to 'HTTP-Tiny/$VERSION'). If
  #pod   C<agent>  ends in a space character, the default user-agent string is
  #pod   appended.
  #pod * C<cookie_jar>  An instance of L<HTTP::CookieJar>  or equivalent class
  #pod   that supports the C<add> and C<cookie_header> methods
  #pod * C<default_headers>  A hashref of default headers to apply to requests
  #pod * C<local_address>  The local IP address to bind to
  #pod * C<keep_alive>  Whether to reuse the last connection (if for the same
  #pod   scheme, host and port) (defaults to 1)
  #pod * C<max_redirect>  Maximum number of redirects allowed (defaults to 5)
  #pod * C<max_size>  Maximum response size in bytes (only when not using a data
  #pod   callback).  If defined, requests with responses larger than this will return
  #pod   a 599 status code.
  #pod * C<http_proxy>  URL of a proxy server to use for HTTP connections
  #pod   (default is C<$ENV{http_proxy}>  if set)
  #pod * C<https_proxy>  URL of a proxy server to use for HTTPS connections
  #pod   (default is C<$ENV{https_proxy}>  if set)
  #pod * C<proxy>  URL of a generic proxy server for both HTTP and HTTPS
  #pod   connections (default is C<$ENV{all_proxy}>  if set)
  #pod * C<no_proxy>  List of domain suffixes that should not be proxied.  Must
  #pod   be a comma-separated string or an array reference. (default is
  #pod   C<$ENV{no_proxy}> )
  #pod * C<timeout>  Request timeout in seconds (default is 60) If a socket open,
  #pod   read or write takes longer than the timeout, the request response status code
  #pod   will be 599.
  #pod * C<verify_SSL>  A boolean that indicates whether to validate the TLS/SSL
  #pod   certificate of an C<https>  connection (default is true). Changed from false
  #pod   to true in version 0.083.
  #pod * C<SSL_options>  A hashref of C<SSL_*>  options to pass through to
  #pod   L<IO::Socket::SSL>
  #pod * C<$ENV{PERL_HTTP_TINY_SSL_INSECURE_BY_DEFAULT}> - Changes the default
  #pod   certificate verification behavior to not check server identity if set to 1.
  #pod   Only effective if C<verify_SSL> is not set. Added in version 0.083.
  #pod
  #pod
  #pod An accessor/mutator method exists for each attribute.
  #pod
  #pod Passing an explicit C<undef> for C<proxy>, C<http_proxy> or C<https_proxy> will
  #pod prevent getting the corresponding proxies from the environment.
  #pod
  #pod Errors during request execution will result in a pseudo-HTTP status code of 599
  #pod and a reason of "Internal Exception". The content field in the response will
  #pod contain the text of the error.
  #pod
  #pod The C<keep_alive> parameter enables a persistent connection, but only to a
  #pod single destination scheme, host and port.  If any connection-relevant
  #pod attributes are modified via accessor, or if the process ID or thread ID change,
  #pod the persistent connection will be dropped.  If you want persistent connections
  #pod across multiple destinations, use multiple HTTP::Tiny objects.
  #pod
  #pod See L</SSL SUPPORT> for more on the C<verify_SSL> and C<SSL_options> attributes.
  #pod
  #pod =cut
  
  my @attributes;
  BEGIN {
      @attributes = qw(
          cookie_jar default_headers http_proxy https_proxy keep_alive
          local_address max_redirect max_size proxy no_proxy
          SSL_options verify_SSL
      );
      my %persist_ok = map {; $_ => 1 } qw(
          cookie_jar default_headers max_redirect max_size
      );
      no strict 'refs';
      no warnings 'uninitialized';
      for my $accessor ( @attributes ) {
          *{$accessor} = sub {
              @_ > 1
                  ? do {
                      delete $_[0]->{handle} if !$persist_ok{$accessor} && $_[1] ne $_[0]->{$accessor};
                      $_[0]->{$accessor} = $_[1]
                  }
                  : $_[0]->{$accessor};
          };
      }
  }
  
  sub agent {
      my($self, $agent) = @_;
      if( @_ > 1 ){
          $self->{agent} =
              (defined $agent && $agent =~ / $/) ? $agent . $self->_agent : $agent;
      }
      return $self->{agent};
  }
  
  sub timeout {
      my ($self, $timeout) = @_;
      if ( @_ > 1 ) {
          $self->{timeout} = $timeout;
          if ($self->{handle}) {
              $self->{handle}->timeout($timeout);
          }
      }
      return $self->{timeout};
  }
  
  sub new {
      my($class, %args) = @_;
  
      # Support lower case verify_ssl argument, but only if verify_SSL is not
      # true.
      if ( exists $args{verify_ssl} ) {
          $args{verify_SSL}  ||= $args{verify_ssl};
      }
  
      my $self = {
          max_redirect => 5,
          timeout      => defined $args{timeout} ? $args{timeout} : 60,
          keep_alive   => 1,
          verify_SSL   => defined $args{verify_SSL} ? $args{verify_SSL} : _verify_SSL_default(),
          no_proxy     => $ENV{no_proxy},
      };
  
      bless $self, $class;
  
      $class->_validate_cookie_jar( $args{cookie_jar} ) if $args{cookie_jar};
  
      for my $key ( @attributes ) {
          $self->{$key} = $args{$key} if exists $args{$key}
      }
  
      $self->agent( exists $args{agent} ? $args{agent} : $class->_agent );
  
      $self->_set_proxies;
  
      return $self;
  }
  
  sub _verify_SSL_default {
      my ($self) = @_;
      # Check if insecure default certificate verification behaviour has been
      # changed by the user by setting PERL_HTTP_TINY_SSL_INSECURE_BY_DEFAULT=1
      return (($ENV{PERL_HTTP_TINY_INSECURE_BY_DEFAULT} || '') eq '1') ? 0 : 1;
  }
  
  sub _set_proxies {
      my ($self) = @_;
  
      # get proxies from %ENV only if not provided; explicit undef will disable
      # getting proxies from the environment
  
      # generic proxy
      if (! exists $self->{proxy} ) {
          $self->{proxy} = $ENV{all_proxy} || $ENV{ALL_PROXY};
      }
  
      if ( defined $self->{proxy} ) {
          $self->_split_proxy( 'generic proxy' => $self->{proxy} ); # validate
      }
      else {
          delete $self->{proxy};
      }
  
      # http proxy
      if (! exists $self->{http_proxy} ) {
          # under CGI, bypass HTTP_PROXY as request sets it from Proxy header
          local $ENV{HTTP_PROXY} = ($ENV{CGI_HTTP_PROXY} || "") if $ENV{REQUEST_METHOD};
          $self->{http_proxy} = $ENV{http_proxy} || $ENV{HTTP_PROXY} || $self->{proxy};
      }
  
      if ( defined $self->{http_proxy} ) {
          $self->_split_proxy( http_proxy => $self->{http_proxy} ); # validate
          $self->{_has_proxy}{http} = 1;
      }
      else {
          delete $self->{http_proxy};
      }
  
      # https proxy
      if (! exists $self->{https_proxy} ) {
          $self->{https_proxy} = $ENV{https_proxy} || $ENV{HTTPS_PROXY} || $self->{proxy};
      }
  
      if ( $self->{https_proxy} ) {
          $self->_split_proxy( https_proxy => $self->{https_proxy} ); # validate
          $self->{_has_proxy}{https} = 1;
      }
      else {
          delete $self->{https_proxy};
      }
  
      # Split no_proxy to array reference if not provided as such
      unless ( ref $self->{no_proxy} eq 'ARRAY' ) {
          $self->{no_proxy} =
              (defined $self->{no_proxy}) ? [ split /\s*,\s*/, $self->{no_proxy} ] : [];
      }
  
      return;
  }
  
  #pod =method get|head|put|post|patch|delete
  #pod
  #pod     $response = $http->get($url);
  #pod     $response = $http->get($url, \%options);
  #pod     $response = $http->head($url);
  #pod
  #pod These methods are shorthand for calling C<request()> for the given method.  The
  #pod URL must have unsafe characters escaped and international domain names encoded.
  #pod See C<request()> for valid options and a description of the response.
  #pod
  #pod The C<success> field of the response will be true if the status code is 2XX.
  #pod
  #pod =cut
  
  for my $sub_name ( qw/get head put post patch delete/ ) {
      my $req_method = uc $sub_name;
      no strict 'refs';
      eval <<"HERE"; ## no critic
      sub $sub_name {
          my (\$self, \$url, \$args) = \@_;
          \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
          or _croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
          return \$self->request('$req_method', \$url, \$args || {});
      }
  HERE
  }
  
  #pod =method post_form
  #pod
  #pod     $response = $http->post_form($url, $form_data);
  #pod     $response = $http->post_form($url, $form_data, \%options);
  #pod
  #pod This method executes a C<POST> request and sends the key/value pairs from a
  #pod form data hash or array reference to the given URL with a C<content-type> of
  #pod C<application/x-www-form-urlencoded>.  If data is provided as an array
  #pod reference, the order is preserved; if provided as a hash reference, the terms
  #pod are sorted on key and value for consistency.  See documentation for the
  #pod C<www_form_urlencode> method for details on the encoding.
  #pod
  #pod The URL must have unsafe characters escaped and international domain names
  #pod encoded.  See C<request()> for valid options and a description of the response.
  #pod Any C<content-type> header or content in the options hashref will be ignored.
  #pod
  #pod The C<success> field of the response will be true if the status code is 2XX.
  #pod
  #pod =cut
  
  sub post_form {
      my ($self, $url, $data, $args) = @_;
      (@_ == 3 || @_ == 4 && ref $args eq 'HASH')
          or _croak(q/Usage: $http->post_form(URL, DATAREF, [HASHREF])/ . "\n");
  
      my $headers = {};
      while ( my ($key, $value) = each %{$args->{headers} || {}} ) {
          $headers->{lc $key} = $value;
      }
  
      return $self->request('POST', $url, {
              # Any existing 'headers' key in $args will be overridden with a
              # normalized version below.
              %$args,
              content => $self->www_form_urlencode($data),
              headers => {
                  %$headers,
                  'content-type' => 'application/x-www-form-urlencoded'
              },
          }
      );
  }
  
  #pod =method mirror
  #pod
  #pod     $response = $http->mirror($url, $file, \%options)
  #pod     if ( $response->{success} ) {
  #pod         print "$file is up to date\n";
  #pod     }
  #pod
  #pod Executes a C<GET> request for the URL and saves the response body to the file
  #pod name provided.  The URL must have unsafe characters escaped and international
  #pod domain names encoded.  If the file already exists, the request will include an
  #pod C<If-Modified-Since> header with the modification timestamp of the file.  You
  #pod may specify a different C<If-Modified-Since> header yourself in the C<<
  #pod $options->{headers} >> hash.
  #pod
  #pod The C<success> field of the response will be true if the status code is 2XX
  #pod or if the status code is 304 (unmodified).
  #pod
  #pod If the file was modified and the server response includes a properly
  #pod formatted C<Last-Modified> header, the file modification time will
  #pod be updated accordingly.
  #pod
  #pod =cut
  
  sub mirror {
      my ($self, $url, $file, $args) = @_;
      @_ == 3 || (@_ == 4 && ref $args eq 'HASH')
        or _croak(q/Usage: $http->mirror(URL, FILE, [HASHREF])/ . "\n");
  
      if ( exists $args->{headers} ) {
          my $headers = {};
          while ( my ($key, $value) = each %{$args->{headers} || {}} ) {
              $headers->{lc $key} = $value;
          }
          $args->{headers} = $headers;
      }
  
      if ( -e $file and my $mtime = (stat($file))[9] ) {
          $args->{headers}{'if-modified-since'} ||= $self->_http_date($mtime);
      }
      my $tempfile = $file . int(rand(2**31));
  
      require Fcntl;
      sysopen my $fh, $tempfile, Fcntl::O_CREAT()|Fcntl::O_EXCL()|Fcntl::O_WRONLY()
         or _croak(qq/Error: Could not create temporary file $tempfile for downloading: $!\n/);
      binmode $fh;
      $args->{data_callback} = sub { print {$fh} $_[0] };
      my $response = $self->request('GET', $url, $args);
      close $fh
          or _croak(qq/Error: Caught error closing temporary file $tempfile: $!\n/);
  
      if ( $response->{success} ) {
          rename $tempfile, $file
              or _croak(qq/Error replacing $file with $tempfile: $!\n/);
          my $lm = $response->{headers}{'last-modified'};
          if ( $lm and my $mtime = $self->_parse_http_date($lm) ) {
              utime $mtime, $mtime, $file;
          }
      }
      $response->{success} ||= $response->{status} eq '304';
      unlink $tempfile;
      return $response;
  }
  
  #pod =method request
  #pod
  #pod     $response = $http->request($method, $url);
  #pod     $response = $http->request($method, $url, \%options);
  #pod
  #pod Executes an HTTP request of the given method type ('GET', 'HEAD', 'POST',
  #pod 'PUT', etc.) on the given URL.  The URL must have unsafe characters escaped and
  #pod international domain names encoded.
  #pod
  #pod B<NOTE>: Method names are B<case-sensitive> per the HTTP/1.1 specification.
  #pod Don't use C<get> when you really want C<GET>.  See L<LIMITATIONS> for
  #pod how this applies to redirection.
  #pod
  #pod If the URL includes a "user:password" stanza, they will be used for Basic-style
  #pod authorization headers.  (Authorization headers will not be included in a
  #pod redirected request.) For example:
  #pod
  #pod     $http->request('GET', 'http://Aladdin:open sesame@example.com/');
  #pod
  #pod If the "user:password" stanza contains reserved characters, they must
  #pod be percent-escaped:
  #pod
  #pod     $http->request('GET', 'http://john%40example.com:password@example.com/');
  #pod
  #pod A hashref of options may be appended to modify the request.
  #pod
  #pod Valid options are:
  #pod
  #pod =for :list
  #pod * C<headers> 
  #pod     A hashref containing headers to include with the request.  If the value for
  #pod     a header is an array reference, the header will be output multiple times with
  #pod     each value in the array.  These headers over-write any default headers.
  #pod * C<content> 
  #pod     A scalar to include as the body of the request OR a code reference
  #pod     that will be called iteratively to produce the body of the request
  #pod * C<trailer_callback> 
  #pod     A code reference that will be called if it exists to provide a hashref
  #pod     of trailing headers (only used with chunked transfer-encoding)
  #pod * C<data_callback> 
  #pod     A code reference that will be called for each chunks of the response
  #pod     body received.
  #pod * C<peer> 
  #pod     Override host resolution and force all connections to go only to a
  #pod     specific peer address, regardless of the URL of the request.  This will
  #pod     include any redirections!  This options should be used with extreme
  #pod     caution (e.g. debugging or very special circumstances). It can be given as
  #pod     either a scalar or a code reference that will receive the hostname and
  #pod     whose response will be taken as the address.
  #pod
  #pod The C<Host> header is generated from the URL in accordance with RFC 2616.  It
  #pod is a fatal error to specify C<Host> in the C<headers> option.  Other headers
  #pod may be ignored or overwritten if necessary for transport compliance.
  #pod
  #pod If the C<content> option is a code reference, it will be called iteratively
  #pod to provide the content body of the request.  It should return the empty
  #pod string or undef when the iterator is exhausted.
  #pod
  #pod If the C<content> option is the empty string, no C<content-type> or
  #pod C<content-length> headers will be generated.
  #pod
  #pod If the C<data_callback> option is provided, it will be called iteratively until
  #pod the entire response body is received.  The first argument will be a string
  #pod containing a chunk of the response body, the second argument will be the
  #pod in-progress response hash reference, as described below.  (This allows
  #pod customizing the action of the callback based on the C<status> or C<headers>
  #pod received prior to the content body.)
  #pod
  #pod Content data in the request/response is handled as "raw bytes".  Any
  #pod encoding/decoding (with associated headers) are the responsibility of the
  #pod caller.
  #pod
  #pod The C<request> method returns a hashref containing the response.  The hashref
  #pod will have the following keys:
  #pod
  #pod =for :list
  #pod * C<success> 
  #pod     Boolean indicating whether the operation returned a 2XX status code
  #pod * C<url> 
  #pod     URL that provided the response. This is the URL of the request unless
  #pod     there were redirections, in which case it is the last URL queried
  #pod     in a redirection chain
  #pod * C<status> 
  #pod     The HTTP status code of the response
  #pod * C<reason> 
  #pod     The response phrase returned by the server
  #pod * C<content> 
  #pod     The body of the response.  If the response does not have any content
  #pod     or if a data callback is provided to consume the response body,
  #pod     this will be the empty string
  #pod * C<headers> 
  #pod     A hashref of header fields.  All header field names will be normalized
  #pod     to be lower case. If a header is repeated, the value will be an arrayref;
  #pod     it will otherwise be a scalar string containing the value
  #pod * C<protocol> -
  #pod     If this field exists, it is the protocol of the response
  #pod     such as HTTP/1.0 or HTTP/1.1
  #pod * C<redirects>
  #pod     If this field exists, it is an arrayref of response hash references from
  #pod     redirects in the same order that redirections occurred.  If it does
  #pod     not exist, then no redirections occurred.
  #pod
  #pod On an error during the execution of the request, the C<status> field will
  #pod contain 599, and the C<content> field will contain the text of the error.
  #pod
  #pod =cut
  
  my %idempotent = map { $_ => 1 } qw/GET HEAD PUT DELETE OPTIONS TRACE/;
  
  sub request {
      my ($self, $method, $url, $args) = @_;
      @_ == 3 || (@_ == 4 && ref $args eq 'HASH')
        or _croak(q/Usage: $http->request(METHOD, URL, [HASHREF])/ . "\n");
      $args ||= {}; # we keep some state in this during _request
  
      # RFC 2616 Section 8.1.4 mandates a single retry on broken socket
      my $response;
      for ( 0 .. 1 ) {
          $response = eval { $self->_request($method, $url, $args) };
          last unless $@ && $idempotent{$method}
              && $@ =~ m{^(?:Socket closed|Unexpected end|SSL read error)};
      }
  
      if (my $e = $@) {
          # maybe we got a response hash thrown from somewhere deep
          if ( ref $e eq 'HASH' && exists $e->{status} ) {
              $e->{redirects} = delete $args->{_redirects} if @{ $args->{_redirects} || []};
              return $e;
          }
  
          # otherwise, stringify it
          $e = "$e";
          $response = {
              url     => $url,
              success => q{},
              status  => 599,
              reason  => 'Internal Exception',
              content => $e,
              headers => {
                  'content-type'   => 'text/plain',
                  'content-length' => length $e,
              },
              ( @{$args->{_redirects} || []} ? (redirects => delete $args->{_redirects}) : () ),
          };
      }
      return $response;
  }
  
  #pod =method www_form_urlencode
  #pod
  #pod     $params = $http->www_form_urlencode( $data );
  #pod     $response = $http->get("http://example.com/query?$params");
  #pod
  #pod This method converts the key/value pairs from a data hash or array reference
  #pod into a C<x-www-form-urlencoded> string.  The keys and values from the data
  #pod reference will be UTF-8 encoded and escaped per RFC 3986.  If a value is an
  #pod array reference, the key will be repeated with each of the values of the array
  #pod reference.  If data is provided as a hash reference, the key/value pairs in the
  #pod resulting string will be sorted by key and value for consistent ordering.
  #pod
  #pod =cut
  
  sub www_form_urlencode {
      my ($self, $data) = @_;
      (@_ == 2 && ref $data)
          or _croak(q/Usage: $http->www_form_urlencode(DATAREF)/ . "\n");
      (ref $data eq 'HASH' || ref $data eq 'ARRAY')
          or _croak("form data must be a hash or array reference\n");
  
      my @params = ref $data eq 'HASH' ? %$data : @$data;
      @params % 2 == 0
          or _croak("form data reference must have an even number of terms\n");
  
      my @terms;
      while( @params ) {
          my ($key, $value) = splice(@params, 0, 2);
          _croak("form data keys must not be undef")
              if !defined($key);
          if ( ref $value eq 'ARRAY' ) {
              unshift @params, map { $key => $_ } @$value;
          }
          else {
              push @terms, join("=", map { $self->_uri_escape($_) } $key, $value);
          }
      }
  
      return join("&", (ref $data eq 'ARRAY') ? (@terms) : (sort @terms) );
  }
  
  #pod =method can_ssl
  #pod
  #pod     $ok         = HTTP::Tiny->can_ssl;
  #pod     ($ok, $why) = HTTP::Tiny->can_ssl;
  #pod     ($ok, $why) = $http->can_ssl;
  #pod
  #pod Indicates if SSL support is available.  When called as a class object, it
  #pod checks for the correct version of L<Net::SSLeay> and L<IO::Socket::SSL>.
  #pod When called as an object methods, if C<SSL_verify> is true or if C<SSL_verify_mode>
  #pod is set in C<SSL_options>, it checks that a CA file is available.
  #pod
  #pod In scalar context, returns a boolean indicating if SSL is available.
  #pod In list context, returns the boolean and a (possibly multi-line) string of
  #pod errors indicating why SSL isn't available.
  #pod
  #pod =cut
  
  sub can_ssl {
      my ($self) = @_;
  
      my($ok, $reason) = (1, '');
  
      # Need IO::Socket::SSL 1.42 for SSL_create_ctx_callback
      local @INC = @INC;
      pop @INC if $INC[-1] eq '.';
      unless (eval {require IO::Socket::SSL; IO::Socket::SSL->VERSION(1.42)}) {
          $ok = 0;
          $reason .= qq/IO::Socket::SSL 1.42 must be installed for https support\n/;
      }
  
      # Need Net::SSLeay 1.49 for MODE_AUTO_RETRY
      unless (eval {require Net::SSLeay; Net::SSLeay->VERSION(1.49)}) {
          $ok = 0;
          $reason .= qq/Net::SSLeay 1.49 must be installed for https support\n/;
      }
  
      # If an object, check that SSL config lets us get a CA if necessary
      if ( ref($self) && ( $self->{verify_SSL} || $self->{SSL_options}{SSL_verify_mode} ) ) {
          my $handle = HTTP::Tiny::Handle->new(
              SSL_options => $self->{SSL_options},
              verify_SSL  => $self->{verify_SSL},
          );
          unless ( eval { $handle->_find_CA_file; 1 } ) {
              $ok = 0;
              $reason .= "$@";
          }
      }
  
      wantarray ? ($ok, $reason) : $ok;
  }
  
  #pod =method connected
  #pod
  #pod     $host = $http->connected;
  #pod     ($host, $port) = $http->connected;
  #pod
  #pod Indicates if a connection to a peer is being kept alive, per the C<keep_alive>
  #pod option.
  #pod
  #pod In scalar context, returns the peer host and port, joined with a colon, or
  #pod C<undef> (if no peer is connected).
  #pod In list context, returns the peer host and port or an empty list (if no peer
  #pod is connected).
  #pod
  #pod B<Note>: This method cannot reliably be used to discover whether the remote
  #pod host has closed its end of the socket.
  #pod
  #pod =cut
  
  sub connected {
      my ($self) = @_;
  
      if ( $self->{handle} ) {
          return $self->{handle}->connected;
      }
      return;
  }
  
  #--------------------------------------------------------------------------#
  # private methods
  #--------------------------------------------------------------------------#
  
  my %DefaultPort = (
      http => 80,
      https => 443,
  );
  
  sub _agent {
      my $class = ref($_[0]) || $_[0];
      (my $default_agent = $class) =~ s{::}{-}g;
      my $version = $class->VERSION;
      $default_agent .= "/$version" if defined $version;
      return $default_agent;
  }
  
  sub _request {
      my ($self, $method, $url, $args) = @_;
  
      my ($scheme, $host, $port, $path_query, $auth) = $self->_split_url($url);
  
      if ($scheme ne 'http' && $scheme ne 'https') {
        die(qq/Unsupported URL scheme '$scheme'\n/);
      }
  
      my $request = {
          method    => $method,
          scheme    => $scheme,
          host      => $host,
          port      => $port,
          host_port => ($port == $DefaultPort{$scheme} ? $host : "$host:$port"),
          uri       => $path_query,
          headers   => {},
      };
  
      my $peer = $args->{peer} || $host;
  
      # Allow 'peer' to be a coderef.
      if ('CODE' eq ref $peer) {
          $peer = $peer->($host);
      }
  
      # We remove the cached handle so it is not reused in the case of redirect.
      # If all is well, it will be recached at the end of _request.  We only
      # reuse for the same scheme, host and port
      my $handle = delete $self->{handle};
      if ( $handle ) {
          unless ( $handle->can_reuse( $scheme, $host, $port, $peer ) ) {
              $handle->close;
              undef $handle;
          }
      }
      $handle ||= $self->_open_handle( $request, $scheme, $host, $port, $peer );
  
      $self->_prepare_headers_and_cb($request, $args, $url, $auth);
      $handle->write_request($request);
  
      my $response;
      do { $response = $handle->read_response_header }
          until (substr($response->{status},0,1) ne '1');
  
      $self->_update_cookie_jar( $url, $response ) if $self->{cookie_jar};
      my @redir_args = $self->_maybe_redirect($request, $response, $args);
  
      my $known_message_length;
      if ($method eq 'HEAD' || $response->{status} =~ /^[23]04/) {
          # response has no message body
          $known_message_length = 1;
      }
      else {
          # Ignore any data callbacks during redirection.
          my $cb_args = @redir_args ? +{} : $args;
          my $data_cb = $self->_prepare_data_cb($response, $cb_args);
          $known_message_length = $handle->read_body($data_cb, $response);
      }
  
      if ( $self->{keep_alive}
          && $handle->connected
          && $known_message_length
          && $response->{protocol} eq 'HTTP/1.1'
          && ($response->{headers}{connection} || '') ne 'close'
      ) {
          $self->{handle} = $handle;
      }
      else {
          $handle->close;
      }
  
      $response->{success} = substr( $response->{status}, 0, 1 ) eq '2';
      $response->{url} = $url;
  
      # Push the current response onto the stack of redirects if redirecting.
      if (@redir_args) {
          push @{$args->{_redirects}}, $response;
          return $self->_request(@redir_args, $args);
      }
  
      # Copy the stack of redirects into the response before returning.
      $response->{redirects} = delete $args->{_redirects}
        if @{$args->{_redirects}};
      return $response;
  }
  
  sub _open_handle {
      my ($self, $request, $scheme, $host, $port, $peer) = @_;
  
      my $handle  = HTTP::Tiny::Handle->new(
          timeout         => $self->{timeout},
          SSL_options     => $self->{SSL_options},
          verify_SSL      => $self->{verify_SSL},
          local_address   => $self->{local_address},
          keep_alive      => $self->{keep_alive}
      );
  
      if ($self->{_has_proxy}{$scheme} && ! grep { $host =~ /\Q$_\E$/ } @{$self->{no_proxy}}) {
          return $self->_proxy_connect( $request, $handle );
      }
      else {
          return $handle->connect($scheme, $host, $port, $peer);
      }
  }
  
  sub _proxy_connect {
      my ($self, $request, $handle) = @_;
  
      my @proxy_vars;
      if ( $request->{scheme} eq 'https' ) {
          _croak(qq{No https_proxy defined}) unless $self->{https_proxy};
          @proxy_vars = $self->_split_proxy( https_proxy => $self->{https_proxy} );
          if ( $proxy_vars[0] eq 'https' ) {
              _croak(qq{Can't proxy https over https: $request->{uri} via $self->{https_proxy}});
          }
      }
      else {
          _croak(qq{No http_proxy defined}) unless $self->{http_proxy};
          @proxy_vars = $self->_split_proxy( http_proxy => $self->{http_proxy} );
      }
  
      my ($p_scheme, $p_host, $p_port, $p_auth) = @proxy_vars;
  
      if ( length $p_auth && ! defined $request->{headers}{'proxy-authorization'} ) {
          $self->_add_basic_auth_header( $request, 'proxy-authorization' => $p_auth );
      }
  
      $handle->connect($p_scheme, $p_host, $p_port, $p_host);
  
      if ($request->{scheme} eq 'https') {
          $self->_create_proxy_tunnel( $request, $handle );
      }
      else {
          # non-tunneled proxy requires absolute URI
          $request->{uri} = "$request->{scheme}://$request->{host_port}$request->{uri}";
      }
  
      return $handle;
  }
  
  sub _split_proxy {
      my ($self, $type, $proxy) = @_;
  
      my ($scheme, $host, $port, $path_query, $auth) = eval { $self->_split_url($proxy) };
  
      unless(
          defined($scheme) && length($scheme) && length($host) && length($port)
          && $path_query eq '/'
      ) {
          _croak(qq{$type URL must be in format http[s]://[auth@]<host>:<port>/\n});
      }
  
      return ($scheme, $host, $port, $auth);
  }
  
  sub _create_proxy_tunnel {
      my ($self, $request, $handle) = @_;
  
      $handle->_assert_ssl;
  
      my $agent = exists($request->{headers}{'user-agent'})
          ? $request->{headers}{'user-agent'} : $self->{agent};
  
      my $connect_request = {
          method    => 'CONNECT',
          uri       => "$request->{host}:$request->{port}",
          headers   => {
              host => "$request->{host}:$request->{port}",
              'user-agent' => $agent,
          }
      };
  
      if ( $request->{headers}{'proxy-authorization'} ) {
          $connect_request->{headers}{'proxy-authorization'} =
              delete $request->{headers}{'proxy-authorization'};
      }
  
      $handle->write_request($connect_request);
      my $response;
      do { $response = $handle->read_response_header }
          until (substr($response->{status},0,1) ne '1');
  
      # if CONNECT failed, throw the response so it will be
      # returned from the original request() method;
      unless (substr($response->{status},0,1) eq '2') {
          die $response;
      }
  
      # tunnel established, so start SSL handshake
      $handle->start_ssl( $request->{host} );
  
      return;
  }
  
  sub _prepare_headers_and_cb {
      my ($self, $request, $args, $url, $auth) = @_;
  
      for ($self->{default_headers}, $args->{headers}) {
          next unless defined;
          while (my ($k, $v) = each %$_) {
              $request->{headers}{lc $k} = $v;
              $request->{header_case}{lc $k} = $k;
          }
      }
  
      if (exists $request->{headers}{'host'}) {
          die(qq/The 'Host' header must not be provided as header option\n/);
      }
  
      $request->{headers}{'host'}         = $request->{host_port};
      $request->{headers}{'user-agent'} ||= $self->{agent};
      $request->{headers}{'connection'}   = "close"
          unless $self->{keep_alive};
  
      # Some servers error on an empty-body PUT/POST without a content-length
      if ( $request->{method} eq 'PUT' || $request->{method} eq 'POST' ) {
          if (!defined($args->{content}) || !length($args->{content}) ) {
              $request->{headers}{'content-length'} = 0;
          }
      }
  
      if ( defined $args->{content} ) {
          if ( ref $args->{content} eq 'CODE' ) {
              if ( exists $request->{'content-length'} && $request->{'content-length'} == 0 ) {
                  $request->{cb} = sub { "" };
              }
              else {
                  $request->{headers}{'content-type'} ||= "application/octet-stream";
                  $request->{headers}{'transfer-encoding'} = 'chunked'
                    unless exists $request->{headers}{'content-length'}
                    || $request->{headers}{'transfer-encoding'};
                  $request->{cb} = $args->{content};
              }
          }
          elsif ( length $args->{content} ) {
              my $content = $args->{content};
              if ( $] ge '5.008' ) {
                  utf8::downgrade($content, 1)
                      or die(qq/Wide character in request message body\n/);
              }
              $request->{headers}{'content-type'} ||= "application/octet-stream";
              $request->{headers}{'content-length'} = length $content
                unless $request->{headers}{'content-length'}
                    || $request->{headers}{'transfer-encoding'};
              $request->{cb} = sub { substr $content, 0, length $content, '' };
          }
          $request->{trailer_cb} = $args->{trailer_callback}
              if ref $args->{trailer_callback} eq 'CODE';
      }
  
      ### If we have a cookie jar, then maybe add relevant cookies
      if ( $self->{cookie_jar} ) {
          my $cookies = $self->cookie_jar->cookie_header( $url );
          $request->{headers}{cookie} = $cookies if length $cookies;
      }
  
      # if we have Basic auth parameters, add them
      if ( length $auth && ! defined $request->{headers}{authorization} ) {
          $self->_add_basic_auth_header( $request, 'authorization' => $auth );
      }
  
      return;
  }
  
  sub _add_basic_auth_header {
      my ($self, $request, $header, $auth) = @_;
      require MIME::Base64;
      $request->{headers}{$header} =
          "Basic " . MIME::Base64::encode_base64($auth, "");
      return;
  }
  
  sub _prepare_data_cb {
      my ($self, $response, $args) = @_;
      my $data_cb = $args->{data_callback};
      $response->{content} = '';
  
      if (!$data_cb || $response->{status} !~ /^2/) {
          if (defined $self->{max_size}) {
              $data_cb = sub {
                  $_[1]->{content} .= $_[0];
                  die(qq/Size of response body exceeds the maximum allowed of $self->{max_size}\n/)
                    if length $_[1]->{content} > $self->{max_size};
              };
          }
          else {
              $data_cb = sub { $_[1]->{content} .= $_[0] };
          }
      }
      return $data_cb;
  }
  
  sub _update_cookie_jar {
      my ($self, $url, $response) = @_;
  
      my $cookies = $response->{headers}->{'set-cookie'};
      return unless defined $cookies;
  
      my @cookies = ref $cookies ? @$cookies : $cookies;
  
      $self->cookie_jar->add( $url, $_ ) for @cookies;
  
      return;
  }
  
  sub _validate_cookie_jar {
      my ($class, $jar) = @_;
  
      # duck typing
      for my $method ( qw/add cookie_header/ ) {
          _croak(qq/Cookie jar must provide the '$method' method\n/)
              unless ref($jar) && ref($jar)->can($method);
      }
  
      return;
  }
  
  sub _maybe_redirect {
      my ($self, $request, $response, $args) = @_;
      my $headers = $response->{headers};
      my ($status, $method) = ($response->{status}, $request->{method});
      $args->{_redirects} ||= [];
  
      if (($status eq '303' or ($status =~ /^30[1278]/ && $method =~ /^GET|HEAD$/))
          and $headers->{location}
          and @{$args->{_redirects}} < $self->{max_redirect}
      ) {
          my $location = ($headers->{location} =~ /^\//)
              ? "$request->{scheme}://$request->{host_port}$headers->{location}"
              : $headers->{location} ;
          return (($status eq '303' ? 'GET' : $method), $location);
      }
      return;
  }
  
  sub _split_url {
      my $url = pop;
  
      # URI regex adapted from the URI module
      my ($scheme, $host, $path_query) = $url =~ m<\A([^:/?#]+)://([^/?#]*)([^#]*)>
        or die(qq/Cannot parse URL: '$url'\n/);
  
      $scheme     = lc $scheme;
      $path_query = "/$path_query" unless $path_query =~ m<\A/>;
  
      my $auth = '';
      if ( (my $i = index $host, '@') != -1 ) {
          # user:pass@host
          $auth = substr $host, 0, $i, ''; # take up to the @ for auth
          substr $host, 0, 1, '';          # knock the @ off the host
  
          # userinfo might be percent escaped, so recover real auth info
          $auth =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
      }
      my $port = $host =~ s/:(\d*)\z// && length $1 ? $1
               : $scheme eq 'http'                  ? 80
               : $scheme eq 'https'                 ? 443
               : undef;
  
      return ($scheme, (length $host ? lc $host : "localhost") , $port, $path_query, $auth);
  }
  
  # Date conversions adapted from HTTP::Date
  my $DoW = "Sun|Mon|Tue|Wed|Thu|Fri|Sat";
  my $MoY = "Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec";
  sub _http_date {
      my ($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($_[1]);
      return sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",
          substr($DoW,$wday*4,3),
          $mday, substr($MoY,$mon*4,3), $year+1900,
          $hour, $min, $sec
      );
  }
  
  sub _parse_http_date {
      my ($self, $str) = @_;
      require Time::Local;
      my @tl_parts;
      if ($str =~ /^[SMTWF][a-z]+, +(\d{1,2}) ($MoY) +(\d\d\d\d) +(\d\d):(\d\d):(\d\d) +GMT$/) {
          @tl_parts = ($6, $5, $4, $1, (index($MoY,$2)/4), $3);
      }
      elsif ($str =~ /^[SMTWF][a-z]+, +(\d\d)-($MoY)-(\d{2,4}) +(\d\d):(\d\d):(\d\d) +GMT$/ ) {
          @tl_parts = ($6, $5, $4, $1, (index($MoY,$2)/4), $3);
      }
      elsif ($str =~ /^[SMTWF][a-z]+ +($MoY) +(\d{1,2}) +(\d\d):(\d\d):(\d\d) +(?:[^0-9]+ +)?(\d\d\d\d)$/ ) {
          @tl_parts = ($5, $4, $3, $2, (index($MoY,$1)/4), $6);
      }
      return eval {
          my $t = @tl_parts ? Time::Local::timegm(@tl_parts) : -1;
          $t < 0 ? undef : $t;
      };
  }
  
  # URI escaping adapted from URI::Escape
  # c.f. http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
  # perl 5.6 ready UTF-8 encoding adapted from JSON::PP
  my %escapes = map { chr($_) => sprintf("%%%02X", $_) } 0..255;
  $escapes{' '}="+";
  my $unsafe_char = qr/[^A-Za-z0-9\-\._~]/;
  
  sub _uri_escape {
      my ($self, $str) = @_;
      return "" if !defined $str;
      if ( $] ge '5.008' ) {
          utf8::encode($str);
      }
      else {
          $str = pack("U*", unpack("C*", $str)) # UTF-8 encode a byte string
              if ( length $str == do { use bytes; length $str } );
          $str = pack("C*", unpack("C*", $str)); # clear UTF-8 flag
      }
      $str =~ s/($unsafe_char)/$escapes{$1}/g;
      return $str;
  }
  
  package
      HTTP::Tiny::Handle; # hide from PAUSE/indexers
  use strict;
  use warnings;
  
  use Errno      qw[EINTR EPIPE];
  use IO::Socket qw[SOCK_STREAM];
  use Socket     qw[SOL_SOCKET SO_KEEPALIVE];
  
  # PERL_HTTP_TINY_IPV4_ONLY is a private environment variable to force old
  # behavior if someone is unable to boostrap CPAN from a new perl install; it is
  # not intended for general, per-client use and may be removed in the future
  my $SOCKET_CLASS =
      $ENV{PERL_HTTP_TINY_IPV4_ONLY} ? 'IO::Socket::INET' :
      eval { require IO::Socket::IP; IO::Socket::IP->VERSION(0.32) } ? 'IO::Socket::IP' :
      'IO::Socket::INET';
  
  sub BUFSIZE () { 32768 } ## no critic
  
  my $Printable = sub {
      local $_ = shift;
      s/\r/\\r/g;
      s/\n/\\n/g;
      s/\t/\\t/g;
      s/([^\x20-\x7E])/sprintf('\\x%.2X', ord($1))/ge;
      $_;
  };
  
  my $Token = qr/[\x21\x23-\x27\x2A\x2B\x2D\x2E\x30-\x39\x41-\x5A\x5E-\x7A\x7C\x7E]/;
  my $Field_Content = qr/[[:print:]]+ (?: [\x20\x09]+ [[:print:]]+ )*/x;
  
  sub new {
      my ($class, %args) = @_;
      return bless {
          rbuf             => '',
          timeout          => 60,
          max_line_size    => 16384,
          max_header_lines => 64,
          verify_SSL       => HTTP::Tiny::_verify_SSL_default(),
          SSL_options      => {},
          %args
      }, $class;
  }
  
  sub timeout {
      my ($self, $timeout) = @_;
      if ( @_ > 1 ) {
          $self->{timeout} = $timeout;
          if ( $self->{fh} && $self->{fh}->can('timeout') ) {
              $self->{fh}->timeout($timeout);
          }
      }
      return $self->{timeout};
  }
  
  sub connect {
      @_ == 5 || die(q/Usage: $handle->connect(scheme, host, port, peer)/ . "\n");
      my ($self, $scheme, $host, $port, $peer) = @_;
  
      if ( $scheme eq 'https' ) {
          $self->_assert_ssl;
      }
  
      $self->{fh} = $SOCKET_CLASS->new(
          PeerHost  => $peer,
          PeerPort  => $port,
          $self->{local_address} ?
              ( LocalAddr => $self->{local_address} ) : (),
          Proto     => 'tcp',
          Type      => SOCK_STREAM,
          Timeout   => $self->{timeout},
      ) or die(qq/Could not connect to '$host:$port': $@\n/);
  
      binmode($self->{fh})
        or die(qq/Could not binmode() socket: '$!'\n/);
  
      if ( $self->{keep_alive} ) {
          unless ( defined( $self->{fh}->setsockopt( SOL_SOCKET, SO_KEEPALIVE, 1 ) ) ) {
              CORE::close($self->{fh});
              die(qq/Could not set SO_KEEPALIVE on socket: '$!'\n/);
          }
      }
  
      $self->start_ssl($host) if $scheme eq 'https';
  
      $self->{scheme} = $scheme;
      $self->{host} = $host;
      $self->{peer} = $peer;
      $self->{port} = $port;
      $self->{pid} = $$;
      $self->{tid} = _get_tid();
  
      return $self;
  }
  
  sub connected {
      my ($self) = @_;
      if ( $self->{fh} && $self->{fh}->connected ) {
          return wantarray
            ? ( $self->{fh}->peerhost, $self->{fh}->peerport )
            : join( ':', $self->{fh}->peerhost, $self->{fh}->peerport );
      }
      return;
  }
  
  sub start_ssl {
      my ($self, $host) = @_;
  
      # As this might be used via CONNECT after an SSL session
      # to a proxy, we shut down any existing SSL before attempting
      # the handshake
      if ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
          unless ( $self->{fh}->stop_SSL ) {
              my $ssl_err = IO::Socket::SSL->errstr;
              die(qq/Error halting prior SSL connection: $ssl_err/);
          }
      }
  
      my $ssl_args = $self->_ssl_args($host);
      IO::Socket::SSL->start_SSL(
          $self->{fh},
          %$ssl_args,
          SSL_create_ctx_callback => sub {
              my $ctx = shift;
              Net::SSLeay::CTX_set_mode($ctx, Net::SSLeay::MODE_AUTO_RETRY());
          },
      );
  
      unless ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
          my $ssl_err = IO::Socket::SSL->errstr;
          die(qq/SSL connection failed for $host: $ssl_err\n/);
      }
  }
  
  sub close {
      @_ == 1 || die(q/Usage: $handle->close()/ . "\n");
      my ($self) = @_;
      CORE::close($self->{fh})
        or die(qq/Could not close socket: '$!'\n/);
  }
  
  sub write {
      @_ == 2 || die(q/Usage: $handle->write(buf)/ . "\n");
      my ($self, $buf) = @_;
  
      if ( $] ge '5.008' ) {
          utf8::downgrade($buf, 1)
              or die(qq/Wide character in write()\n/);
      }
  
      my $len = length $buf;
      my $off = 0;
  
      local $SIG{PIPE} = 'IGNORE';
  
      while () {
          $self->can_write
            or die(qq/Timed out while waiting for socket to become ready for writing\n/);
          my $r = syswrite($self->{fh}, $buf, $len, $off);
          if (defined $r) {
              $len -= $r;
              $off += $r;
              last unless $len > 0;
          }
          elsif ($! == EPIPE) {
              die(qq/Socket closed by remote server: $!\n/);
          }
          elsif ($! != EINTR) {
              if ($self->{fh}->can('errstr')){
                  my $err = $self->{fh}->errstr();
                  die (qq/Could not write to SSL socket: '$err'\n /);
              }
              else {
                  die(qq/Could not write to socket: '$!'\n/);
              }
  
          }
      }
      return $off;
  }
  
  sub read {
      @_ == 2 || @_ == 3 || die(q/Usage: $handle->read(len [, allow_partial])/ . "\n");
      my ($self, $len, $allow_partial) = @_;
  
      my $buf  = '';
      my $got = length $self->{rbuf};
  
      if ($got) {
          my $take = ($got < $len) ? $got : $len;
          $buf  = substr($self->{rbuf}, 0, $take, '');
          $len -= $take;
      }
  
      # Ignore SIGPIPE because SSL reads can result in writes that might error.
      # See "Expecting exactly the same behavior as plain sockets" in
      # https://metacpan.org/dist/IO-Socket-SSL/view/lib/IO/Socket/SSL.pod#Common-Usage-Errors
      local $SIG{PIPE} = 'IGNORE';
  
      while ($len > 0) {
          $self->can_read
            or die(q/Timed out while waiting for socket to become ready for reading/ . "\n");
          my $r = sysread($self->{fh}, $buf, $len, length $buf);
          if (defined $r) {
              last unless $r;
              $len -= $r;
          }
          elsif ($! != EINTR) {
              if ($self->{fh}->can('errstr')){
                  my $err = $self->{fh}->errstr();
                  die (qq/Could not read from SSL socket: '$err'\n /);
              }
              else {
                  die(qq/Could not read from socket: '$!'\n/);
              }
          }
      }
      if ($len && !$allow_partial) {
          die(qq/Unexpected end of stream\n/);
      }
      return $buf;
  }
  
  sub readline {
      @_ == 1 || die(q/Usage: $handle->readline()/ . "\n");
      my ($self) = @_;
  
      while () {
          if ($self->{rbuf} =~ s/\A ([^\x0D\x0A]* \x0D?\x0A)//x) {
              return $1;
          }
          if (length $self->{rbuf} >= $self->{max_line_size}) {
              die(qq/Line size exceeds the maximum allowed size of $self->{max_line_size}\n/);
          }
          $self->can_read
            or die(qq/Timed out while waiting for socket to become ready for reading\n/);
          my $r = sysread($self->{fh}, $self->{rbuf}, BUFSIZE, length $self->{rbuf});
          if (defined $r) {
              last unless $r;
          }
          elsif ($! != EINTR) {
              if ($self->{fh}->can('errstr')){
                  my $err = $self->{fh}->errstr();
                  die (qq/Could not read from SSL socket: '$err'\n /);
              }
              else {
                  die(qq/Could not read from socket: '$!'\n/);
              }
          }
      }
      die(qq/Unexpected end of stream while looking for line\n/);
  }
  
  sub read_header_lines {
      @_ == 1 || @_ == 2 || die(q/Usage: $handle->read_header_lines([headers])/ . "\n");
      my ($self, $headers) = @_;
      $headers ||= {};
      my $lines   = 0;
      my $val;
  
      while () {
           my $line = $self->readline;
  
           if (++$lines >= $self->{max_header_lines}) {
               die(qq/Header lines exceeds maximum number allowed of $self->{max_header_lines}\n/);
           }
           elsif ($line =~ /\A ([^\x00-\x1F\x7F:]+) : [\x09\x20]* ([^\x0D\x0A]*)/x) {
               my ($field_name) = lc $1;
               if (exists $headers->{$field_name}) {
                   for ($headers->{$field_name}) {
                       $_ = [$_] unless ref $_ eq "ARRAY";
                       push @$_, $2;
                       $val = \$_->[-1];
                   }
               }
               else {
                   $val = \($headers->{$field_name} = $2);
               }
           }
           elsif ($line =~ /\A [\x09\x20]+ ([^\x0D\x0A]*)/x) {
               $val
                 or die(qq/Unexpected header continuation line\n/);
               next unless length $1;
               $$val .= ' ' if length $$val;
               $$val .= $1;
           }
           elsif ($line =~ /\A \x0D?\x0A \z/x) {
              last;
           }
           else {
              die(q/Malformed header line: / . $Printable->($line) . "\n");
           }
      }
      return $headers;
  }
  
  sub write_request {
      @_ == 2 || die(q/Usage: $handle->write_request(request)/ . "\n");
      my($self, $request) = @_;
      $self->write_request_header(@{$request}{qw/method uri headers header_case/});
      $self->write_body($request) if $request->{cb};
      return;
  }
  
  # Standard request header names/case from HTTP/1.1 RFCs
  my @rfc_request_headers = qw(
    Accept Accept-Charset Accept-Encoding Accept-Language Authorization
    Cache-Control Connection Content-Length Expect From Host
    If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since
    Max-Forwards Pragma Proxy-Authorization Range Referer TE Trailer
    Transfer-Encoding Upgrade User-Agent Via
  );
  
  my @other_request_headers = qw(
    Content-Encoding Content-MD5 Content-Type Cookie DNT Date Origin
    X-XSS-Protection
  );
  
  my %HeaderCase = map { lc($_) => $_ } @rfc_request_headers, @other_request_headers;
  
  # to avoid multiple small writes and hence nagle, you can pass the method line or anything else to
  # combine writes.
  sub write_header_lines {
      (@_ >= 2 && @_ <= 4 && ref $_[1] eq 'HASH') || die(q/Usage: $handle->write_header_lines(headers, [header_case, prefix])/ . "\n");
      my($self, $headers, $header_case, $prefix_data) = @_;
      $header_case ||= {};
  
      my $buf = (defined $prefix_data ? $prefix_data : '');
  
      # Per RFC, control fields should be listed first
      my %seen;
      for my $k ( qw/host cache-control expect max-forwards pragma range te/ ) {
          next unless exists $headers->{$k};
          $seen{$k}++;
          my $field_name = $HeaderCase{$k};
          my $v = $headers->{$k};
          for (ref $v eq 'ARRAY' ? @$v : $v) {
              $_ = '' unless defined $_;
              $buf .= "$field_name: $_\x0D\x0A";
          }
      }
  
      # Other headers sent in arbitrary order
      while (my ($k, $v) = each %$headers) {
          my $field_name = lc $k;
          next if $seen{$field_name};
          if (exists $HeaderCase{$field_name}) {
              $field_name = $HeaderCase{$field_name};
          }
          else {
              if (exists $header_case->{$field_name}) {
                  $field_name = $header_case->{$field_name};
              }
              else {
                  $field_name =~ s/\b(\w)/\u$1/g;
              }
              $field_name =~ /\A $Token+ \z/xo
                or die(q/Invalid HTTP header field name: / . $Printable->($field_name) . "\n");
              $HeaderCase{lc $field_name} = $field_name;
          }
          for (ref $v eq 'ARRAY' ? @$v : $v) {
              # unwrap a field value if pre-wrapped by user
              s/\x0D?\x0A\s+/ /g;
              die(qq/Invalid HTTP header field value ($field_name): / . $Printable->($_). "\n")
                unless $_ eq '' || /\A $Field_Content \z/xo;
              $_ = '' unless defined $_;
              $buf .= "$field_name: $_\x0D\x0A";
          }
      }
      $buf .= "\x0D\x0A";
      return $self->write($buf);
  }
  
  # return value indicates whether message length was defined; this is generally
  # true unless there was no content-length header and we just read until EOF.
  # Other message length errors are thrown as exceptions
  sub read_body {
      @_ == 3 || die(q/Usage: $handle->read_body(callback, response)/ . "\n");
      my ($self, $cb, $response) = @_;
      my $te = $response->{headers}{'transfer-encoding'} || '';
      my $chunked = grep { /chunked/i } ( ref $te eq 'ARRAY' ? @$te : $te ) ;
      return $chunked
          ? $self->read_chunked_body($cb, $response)
          : $self->read_content_body($cb, $response);
  }
  
  sub write_body {
      @_ == 2 || die(q/Usage: $handle->write_body(request)/ . "\n");
      my ($self, $request) = @_;
      if (exists $request->{headers}{'content-length'}) {
          return unless $request->{headers}{'content-length'};
          return $self->write_content_body($request);
      }
      else {
          return $self->write_chunked_body($request);
      }
  }
  
  sub read_content_body {
      @_ == 3 || @_ == 4 || die(q/Usage: $handle->read_content_body(callback, response, [read_length])/ . "\n");
      my ($self, $cb, $response, $content_length) = @_;
      $content_length ||= $response->{headers}{'content-length'};
  
      if ( defined $content_length ) {
          my $len = $content_length;
          while ($len > 0) {
              my $read = ($len > BUFSIZE) ? BUFSIZE : $len;
              $cb->($self->read($read, 0), $response);
              $len -= $read;
          }
          return length($self->{rbuf}) == 0;
      }
  
      my $chunk;
      $cb->($chunk, $response) while length( $chunk = $self->read(BUFSIZE, 1) );
  
      return;
  }
  
  sub write_content_body {
      @_ == 2 || die(q/Usage: $handle->write_content_body(request)/ . "\n");
      my ($self, $request) = @_;
  
      my ($len, $content_length) = (0, $request->{headers}{'content-length'});
      while () {
          my $data = $request->{cb}->();
  
          defined $data && length $data
            or last;
  
          if ( $] ge '5.008' ) {
              utf8::downgrade($data, 1)
                  or die(qq/Wide character in write_content()\n/);
          }
  
          $len += $self->write($data);
      }
  
      $len == $content_length
        or die(qq/Content-Length mismatch (got: $len expected: $content_length)\n/);
  
      return $len;
  }
  
  sub read_chunked_body {
      @_ == 3 || die(q/Usage: $handle->read_chunked_body(callback, $response)/ . "\n");
      my ($self, $cb, $response) = @_;
  
      while () {
          my $head = $self->readline;
  
          $head =~ /\A ([A-Fa-f0-9]+)/x
            or die(q/Malformed chunk head: / . $Printable->($head) . "\n");
  
          my $len = hex($1)
            or last;
  
          $self->read_content_body($cb, $response, $len);
  
          $self->read(2) eq "\x0D\x0A"
            or die(qq/Malformed chunk: missing CRLF after chunk data\n/);
      }
      $self->read_header_lines($response->{headers});
      return 1;
  }
  
  sub write_chunked_body {
      @_ == 2 || die(q/Usage: $handle->write_chunked_body(request)/ . "\n");
      my ($self, $request) = @_;
  
      my $len = 0;
      while () {
          my $data = $request->{cb}->();
  
          defined $data && length $data
            or last;
  
          if ( $] ge '5.008' ) {
              utf8::downgrade($data, 1)
                  or die(qq/Wide character in write_chunked_body()\n/);
          }
  
          $len += length $data;
  
          my $chunk  = sprintf '%X', length $data;
             $chunk .= "\x0D\x0A";
             $chunk .= $data;
             $chunk .= "\x0D\x0A";
  
          $self->write($chunk);
      }
      $self->write("0\x0D\x0A");
      if ( ref $request->{trailer_cb} eq 'CODE' ) {
          $self->write_header_lines($request->{trailer_cb}->())
      }
      else {
          $self->write("\x0D\x0A");
      }
      return $len;
  }
  
  sub read_response_header {
      @_ == 1 || die(q/Usage: $handle->read_response_header()/ . "\n");
      my ($self) = @_;
  
      my $line = $self->readline;
  
      $line =~ /\A (HTTP\/(0*\d+\.0*\d+)) [\x09\x20]+ ([0-9]{3}) (?: [\x09\x20]+ ([^\x0D\x0A]*) )? \x0D?\x0A/x
        or die(q/Malformed Status-Line: / . $Printable->($line). "\n");
  
      my ($protocol, $version, $status, $reason) = ($1, $2, $3, $4);
      $reason = "" unless defined $reason;
  
      die (qq/Unsupported HTTP protocol: $protocol\n/)
          unless $version =~ /0*1\.0*[01]/;
  
      return {
          status       => $status,
          reason       => $reason,
          headers      => $self->read_header_lines,
          protocol     => $protocol,
      };
  }
  
  sub write_request_header {
      @_ == 5 || die(q/Usage: $handle->write_request_header(method, request_uri, headers, header_case)/ . "\n");
      my ($self, $method, $request_uri, $headers, $header_case) = @_;
  
      return $self->write_header_lines($headers, $header_case, "$method $request_uri HTTP/1.1\x0D\x0A");
  }
  
  sub _do_timeout {
      my ($self, $type, $timeout) = @_;
      $timeout = $self->{timeout}
          unless defined $timeout && $timeout >= 0;
  
      my $fd = fileno $self->{fh};
      defined $fd && $fd >= 0
        or die(qq/select(2): 'Bad file descriptor'\n/);
  
      my $initial = time;
      my $pending = $timeout;
      my $nfound;
  
      vec(my $fdset = '', $fd, 1) = 1;
  
      while () {
          $nfound = ($type eq 'read')
              ? select($fdset, undef, undef, $pending)
              : select(undef, $fdset, undef, $pending) ;
          if ($nfound == -1) {
              $! == EINTR
                or die(qq/select(2): '$!'\n/);
              redo if !$timeout || ($pending = $timeout - (time - $initial)) > 0;
              $nfound = 0;
          }
          last;
      }
      $! = 0;
      return $nfound;
  }
  
  sub can_read {
      @_ == 1 || @_ == 2 || die(q/Usage: $handle->can_read([timeout])/ . "\n");
      my $self = shift;
      if ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
          return 1 if $self->{fh}->pending;
      }
      return $self->_do_timeout('read', @_)
  }
  
  sub can_write {
      @_ == 1 || @_ == 2 || die(q/Usage: $handle->can_write([timeout])/ . "\n");
      my $self = shift;
      return $self->_do_timeout('write', @_)
  }
  
  sub _assert_ssl {
      my($ok, $reason) = HTTP::Tiny->can_ssl();
      die $reason unless $ok;
  }
  
  sub can_reuse {
      my ($self,$scheme,$host,$port,$peer) = @_;
      return 0 if
          $self->{pid} != $$
          || $self->{tid} != _get_tid()
          || length($self->{rbuf})
          || $scheme ne $self->{scheme}
          || $host ne $self->{host}
          || $port ne $self->{port}
          || $peer ne $self->{peer}
          || eval { $self->can_read(0) }
          || $@ ;
          return 1;
  }
  
  # Try to find a CA bundle to validate the SSL cert,
  # prefer Mozilla::CA or fallback to a system file
  sub _find_CA_file {
      my $self = shift();
  
      my $ca_file =
        defined( $self->{SSL_options}->{SSL_ca_file} )
        ? $self->{SSL_options}->{SSL_ca_file}
        : $ENV{SSL_CERT_FILE};
  
      if ( defined $ca_file ) {
          unless ( -r $ca_file ) {
              die qq/SSL_ca_file '$ca_file' not found or not readable\n/;
          }
          return $ca_file;
      }
  
      local @INC = @INC;
      pop @INC if $INC[-1] eq '.';
      return Mozilla::CA::SSL_ca_file()
          if eval { require Mozilla::CA; 1 };
  
      # cert list copied from golang src/crypto/x509/root_unix.go
      foreach my $ca_bundle (
          "/etc/ssl/certs/ca-certificates.crt",     # Debian/Ubuntu/Gentoo etc.
          "/etc/pki/tls/certs/ca-bundle.crt",       # Fedora/RHEL
          "/etc/ssl/ca-bundle.pem",                 # OpenSUSE
          "/etc/openssl/certs/ca-certificates.crt", # NetBSD
          "/etc/ssl/cert.pem",                      # OpenBSD
          "/usr/local/share/certs/ca-root-nss.crt", # FreeBSD/DragonFly
          "/etc/pki/tls/cacert.pem",                # OpenELEC
          "/etc/certs/ca-certificates.crt",         # Solaris 11.2+
      ) {
          return $ca_bundle if -e $ca_bundle;
      }
  
      die qq/Couldn't find a CA bundle with which to verify the SSL certificate.\n/
        . qq/Try installing Mozilla::CA from CPAN\n/;
  }
  
  # for thread safety, we need to know thread id if threads are loaded
  sub _get_tid {
      no warnings 'reserved'; # for 'threads'
      return threads->can("tid") ? threads->tid : 0;
  }
  
  sub _ssl_args {
      my ($self, $host) = @_;
  
      my %ssl_args;
  
      # This test reimplements IO::Socket::SSL::can_client_sni(), which wasn't
      # added until IO::Socket::SSL 1.84
      if ( Net::SSLeay::OPENSSL_VERSION_NUMBER() >= 0x01000000 ) {
          $ssl_args{SSL_hostname} = $host,          # Sane SNI support
      }
  
      if ($self->{verify_SSL}) {
          $ssl_args{SSL_verifycn_scheme}  = 'http'; # enable CN validation
          $ssl_args{SSL_verifycn_name}    = $host;  # set validation hostname
          $ssl_args{SSL_verify_mode}      = 0x01;   # enable cert validation
          $ssl_args{SSL_ca_file}          = $self->_find_CA_file;
      }
      else {
          $ssl_args{SSL_verifycn_scheme}  = 'none'; # disable CN validation
          $ssl_args{SSL_verify_mode}      = 0x00;   # disable cert validation
      }
  
      # user options override settings from verify_SSL
      for my $k ( keys %{$self->{SSL_options}} ) {
          $ssl_args{$k} = $self->{SSL_options}{$k} if $k =~ m/^SSL_/;
      }
  
      return \%ssl_args;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Tiny - A small, simple, correct HTTP/1.1 client
  
  =head1 VERSION
  
  version 0.084
  
  =head1 SYNOPSIS
  
      use HTTP::Tiny;
  
      my $response = HTTP::Tiny->new->get('http://example.com/');
  
      die "Failed!\n" unless $response->{success};
  
      print "$response->{status} $response->{reason}\n";
  
      while (my ($k, $v) = each %{$response->{headers}}) {
          for (ref $v eq 'ARRAY' ? @$v : $v) {
              print "$k: $_\n";
          }
      }
  
      print $response->{content} if length $response->{content};
  
  =head1 DESCRIPTION
  
  This is a very simple HTTP/1.1 client, designed for doing simple
  requests without the overhead of a large framework like L<LWP::UserAgent>.
  
  It is more correct and more complete than L<HTTP::Lite>.  It supports
  proxies and redirection.  It also correctly resumes after EINTR.
  
  If L<IO::Socket::IP> 0.25 or later is installed, HTTP::Tiny will use it instead
  of L<IO::Socket::INET> for transparent support for both IPv4 and IPv6.
  
  Cookie support requires L<HTTP::CookieJar> or an equivalent class.
  
  =head1 METHODS
  
  =head2 new
  
      $http = HTTP::Tiny->new( %attributes );
  
  This constructor returns a new HTTP::Tiny object.  Valid attributes include:
  
  =over 4
  
  =item *
  
  C<agent>  A user-agent string (defaults to 'HTTP-Tiny/$VERSION'). If C<agent>  ends in a space character, the default user-agent string is appended.
  
  =item *
  
  C<cookie_jar>  An instance of L<HTTP::CookieJar>  or equivalent class that supports the C<add> and C<cookie_header> methods
  
  =item *
  
  C<default_headers>  A hashref of default headers to apply to requests
  
  =item *
  
  C<local_address>  The local IP address to bind to
  
  =item *
  
  C<keep_alive>  Whether to reuse the last connection (if for the same scheme, host and port) (defaults to 1)
  
  =item *
  
  C<max_redirect>  Maximum number of redirects allowed (defaults to 5)
  
  =item *
  
  C<max_size>  Maximum response size in bytes (only when not using a data callback).  If defined, requests with responses larger than this will return a 599 status code.
  
  =item *
  
  C<http_proxy>  URL of a proxy server to use for HTTP connections (default is C<$ENV{http_proxy}>  if set)
  
  =item *
  
  C<https_proxy>  URL of a proxy server to use for HTTPS connections (default is C<$ENV{https_proxy}>  if set)
  
  =item *
  
  C<proxy>  URL of a generic proxy server for both HTTP and HTTPS connections (default is C<$ENV{all_proxy}>  if set)
  
  =item *
  
  C<no_proxy>  List of domain suffixes that should not be proxied.  Must be a comma-separated string or an array reference. (default is C<$ENV{no_proxy}> )
  
  =item *
  
  C<timeout>  Request timeout in seconds (default is 60) If a socket open, read or write takes longer than the timeout, the request response status code will be 599.
  
  =item *
  
  C<verify_SSL>  A boolean that indicates whether to validate the TLS/SSL certificate of an C<https>  connection (default is true). Changed from false to true in version 0.083.
  
  =item *
  
  C<SSL_options>  A hashref of C<SSL_*>  options to pass through to L<IO::Socket::SSL>
  
  =item *
  
  C<$ENV{PERL_HTTP_TINY_SSL_INSECURE_BY_DEFAULT}> - Changes the default certificate verification behavior to not check server identity if set to 1. Only effective if C<verify_SSL> is not set. Added in version 0.083.
  
  =back
  
  An accessor/mutator method exists for each attribute.
  
  Passing an explicit C<undef> for C<proxy>, C<http_proxy> or C<https_proxy> will
  prevent getting the corresponding proxies from the environment.
  
  Errors during request execution will result in a pseudo-HTTP status code of 599
  and a reason of "Internal Exception". The content field in the response will
  contain the text of the error.
  
  The C<keep_alive> parameter enables a persistent connection, but only to a
  single destination scheme, host and port.  If any connection-relevant
  attributes are modified via accessor, or if the process ID or thread ID change,
  the persistent connection will be dropped.  If you want persistent connections
  across multiple destinations, use multiple HTTP::Tiny objects.
  
  See L</SSL SUPPORT> for more on the C<verify_SSL> and C<SSL_options> attributes.
  
  =head2 get|head|put|post|patch|delete
  
      $response = $http->get($url);
      $response = $http->get($url, \%options);
      $response = $http->head($url);
  
  These methods are shorthand for calling C<request()> for the given method.  The
  URL must have unsafe characters escaped and international domain names encoded.
  See C<request()> for valid options and a description of the response.
  
  The C<success> field of the response will be true if the status code is 2XX.
  
  =head2 post_form
  
      $response = $http->post_form($url, $form_data);
      $response = $http->post_form($url, $form_data, \%options);
  
  This method executes a C<POST> request and sends the key/value pairs from a
  form data hash or array reference to the given URL with a C<content-type> of
  C<application/x-www-form-urlencoded>.  If data is provided as an array
  reference, the order is preserved; if provided as a hash reference, the terms
  are sorted on key and value for consistency.  See documentation for the
  C<www_form_urlencode> method for details on the encoding.
  
  The URL must have unsafe characters escaped and international domain names
  encoded.  See C<request()> for valid options and a description of the response.
  Any C<content-type> header or content in the options hashref will be ignored.
  
  The C<success> field of the response will be true if the status code is 2XX.
  
  =head2 mirror
  
      $response = $http->mirror($url, $file, \%options)
      if ( $response->{success} ) {
          print "$file is up to date\n";
      }
  
  Executes a C<GET> request for the URL and saves the response body to the file
  name provided.  The URL must have unsafe characters escaped and international
  domain names encoded.  If the file already exists, the request will include an
  C<If-Modified-Since> header with the modification timestamp of the file.  You
  may specify a different C<If-Modified-Since> header yourself in the C<<
  $options->{headers} >> hash.
  
  The C<success> field of the response will be true if the status code is 2XX
  or if the status code is 304 (unmodified).
  
  If the file was modified and the server response includes a properly
  formatted C<Last-Modified> header, the file modification time will
  be updated accordingly.
  
  =head2 request
  
      $response = $http->request($method, $url);
      $response = $http->request($method, $url, \%options);
  
  Executes an HTTP request of the given method type ('GET', 'HEAD', 'POST',
  'PUT', etc.) on the given URL.  The URL must have unsafe characters escaped and
  international domain names encoded.
  
  B<NOTE>: Method names are B<case-sensitive> per the HTTP/1.1 specification.
  Don't use C<get> when you really want C<GET>.  See L<LIMITATIONS> for
  how this applies to redirection.
  
  If the URL includes a "user:password" stanza, they will be used for Basic-style
  authorization headers.  (Authorization headers will not be included in a
  redirected request.) For example:
  
      $http->request('GET', 'http://Aladdin:open sesame@example.com/');
  
  If the "user:password" stanza contains reserved characters, they must
  be percent-escaped:
  
      $http->request('GET', 'http://john%40example.com:password@example.com/');
  
  A hashref of options may be appended to modify the request.
  
  Valid options are:
  
  =over 4
  
  =item *
  
  C<headers>  A hashref containing headers to include with the request.  If the value for a header is an array reference, the header will be output multiple times with each value in the array.  These headers over-write any default headers.
  
  =item *
  
  C<content>  A scalar to include as the body of the request OR a code reference that will be called iteratively to produce the body of the request
  
  =item *
  
  C<trailer_callback>  A code reference that will be called if it exists to provide a hashref of trailing headers (only used with chunked transfer-encoding)
  
  =item *
  
  C<data_callback>  A code reference that will be called for each chunks of the response body received.
  
  =item *
  
  C<peer>  Override host resolution and force all connections to go only to a specific peer address, regardless of the URL of the request.  This will include any redirections!  This options should be used with extreme caution (e.g. debugging or very special circumstances). It can be given as either a scalar or a code reference that will receive the hostname and whose response will be taken as the address.
  
  =back
  
  The C<Host> header is generated from the URL in accordance with RFC 2616.  It
  is a fatal error to specify C<Host> in the C<headers> option.  Other headers
  may be ignored or overwritten if necessary for transport compliance.
  
  If the C<content> option is a code reference, it will be called iteratively
  to provide the content body of the request.  It should return the empty
  string or undef when the iterator is exhausted.
  
  If the C<content> option is the empty string, no C<content-type> or
  C<content-length> headers will be generated.
  
  If the C<data_callback> option is provided, it will be called iteratively until
  the entire response body is received.  The first argument will be a string
  containing a chunk of the response body, the second argument will be the
  in-progress response hash reference, as described below.  (This allows
  customizing the action of the callback based on the C<status> or C<headers>
  received prior to the content body.)
  
  Content data in the request/response is handled as "raw bytes".  Any
  encoding/decoding (with associated headers) are the responsibility of the
  caller.
  
  The C<request> method returns a hashref containing the response.  The hashref
  will have the following keys:
  
  =over 4
  
  =item *
  
  C<success>  Boolean indicating whether the operation returned a 2XX status code
  
  =item *
  
  C<url>  URL that provided the response. This is the URL of the request unless there were redirections, in which case it is the last URL queried in a redirection chain
  
  =item *
  
  C<status>  The HTTP status code of the response
  
  =item *
  
  C<reason>  The response phrase returned by the server
  
  =item *
  
  C<content>  The body of the response.  If the response does not have any content or if a data callback is provided to consume the response body, this will be the empty string
  
  =item *
  
  C<headers>  A hashref of header fields.  All header field names will be normalized to be lower case. If a header is repeated, the value will be an arrayref; it will otherwise be a scalar string containing the value
  
  =item *
  
  C<protocol> - If this field exists, it is the protocol of the response such as HTTP/1.0 or HTTP/1.1
  
  =item *
  
  C<redirects> If this field exists, it is an arrayref of response hash references from redirects in the same order that redirections occurred.  If it does not exist, then no redirections occurred.
  
  =back
  
  On an error during the execution of the request, the C<status> field will
  contain 599, and the C<content> field will contain the text of the error.
  
  =head2 www_form_urlencode
  
      $params = $http->www_form_urlencode( $data );
      $response = $http->get("http://example.com/query?$params");
  
  This method converts the key/value pairs from a data hash or array reference
  into a C<x-www-form-urlencoded> string.  The keys and values from the data
  reference will be UTF-8 encoded and escaped per RFC 3986.  If a value is an
  array reference, the key will be repeated with each of the values of the array
  reference.  If data is provided as a hash reference, the key/value pairs in the
  resulting string will be sorted by key and value for consistent ordering.
  
  =head2 can_ssl
  
      $ok         = HTTP::Tiny->can_ssl;
      ($ok, $why) = HTTP::Tiny->can_ssl;
      ($ok, $why) = $http->can_ssl;
  
  Indicates if SSL support is available.  When called as a class object, it
  checks for the correct version of L<Net::SSLeay> and L<IO::Socket::SSL>.
  When called as an object methods, if C<SSL_verify> is true or if C<SSL_verify_mode>
  is set in C<SSL_options>, it checks that a CA file is available.
  
  In scalar context, returns a boolean indicating if SSL is available.
  In list context, returns the boolean and a (possibly multi-line) string of
  errors indicating why SSL isn't available.
  
  =head2 connected
  
      $host = $http->connected;
      ($host, $port) = $http->connected;
  
  Indicates if a connection to a peer is being kept alive, per the C<keep_alive>
  option.
  
  In scalar context, returns the peer host and port, joined with a colon, or
  C<undef> (if no peer is connected).
  In list context, returns the peer host and port or an empty list (if no peer
  is connected).
  
  B<Note>: This method cannot reliably be used to discover whether the remote
  host has closed its end of the socket.
  
  =for Pod::Coverage SSL_options
  agent
  cookie_jar
  default_headers
  http_proxy
  https_proxy
  keep_alive
  local_address
  max_redirect
  max_size
  no_proxy
  proxy
  timeout
  verify_SSL
  
  =head1 TLS/SSL SUPPORT
  
  Direct C<https> connections are supported only if L<IO::Socket::SSL> 1.56 or
  greater and L<Net::SSLeay> 1.49 or greater are installed. An error will occur
  if new enough versions of these modules are not installed or if the TLS
  encryption fails. You can also use C<HTTP::Tiny::can_ssl()> utility function
  that returns boolean to see if the required modules are installed.
  
  An C<https> connection may be made via an C<http> proxy that supports the CONNECT
  command (i.e. RFC 2817).  You may not proxy C<https> via a proxy that itself
  requires C<https> to communicate.
  
  TLS/SSL provides two distinct capabilities:
  
  =over 4
  
  =item *
  
  Encrypted communication channel
  
  =item *
  
  Verification of server identity
  
  =back
  
  B<By default, HTTP::Tiny verifies server identity>.
  
  This was changed in version 0.083 due to security concerns. The previous default
  behavior can be enabled by setting C<$ENV{PERL_HTTP_TINY_SSL_INSECURE_BY_DEFAULT}>
  to 1.
  
  Verification is done by checking that that the TLS/SSL connection has a valid
  certificate corresponding to the host name of the connection and that the
  certificate has been verified by a CA. Assuming you trust the CA, this will
  protect against L<machine-in-the-middle
  attacks|http://en.wikipedia.org/wiki/Machine-in-the-middle_attack>.
  
  Certificate verification requires a file containing trusted CA certificates.
  
  If the environment variable C<SSL_CERT_FILE> is present, HTTP::Tiny
  will try to find a CA certificate file in that location.
  
  If the L<Mozilla::CA> module is installed, HTTP::Tiny will use the CA file
  included with it as a source of trusted CA's.
  
  If that module is not available, then HTTP::Tiny will search several
  system-specific default locations for a CA certificate file:
  
  =over 4
  
  =item *
  
  /etc/ssl/certs/ca-certificates.crt
  
  =item *
  
  /etc/pki/tls/certs/ca-bundle.crt
  
  =item *
  
  /etc/ssl/ca-bundle.pem
  
  =item *
  
  /etc/openssl/certs/ca-certificates.crt
  
  =item *
  
  /etc/ssl/cert.pem
  
  =item *
  
  /usr/local/share/certs/ca-root-nss.crt
  
  =item *
  
  /etc/pki/tls/cacert.pem
  
  =item *
  
  /etc/certs/ca-certificates.crt
  
  =back
  
  An error will be occur if C<verify_SSL> is true and no CA certificate file
  is available.
  
  If you desire complete control over TLS/SSL connections, the C<SSL_options>
  attribute lets you provide a hash reference that will be passed through to
  C<IO::Socket::SSL::start_SSL()>, overriding any options set by HTTP::Tiny. For
  example, to provide your own trusted CA file:
  
      SSL_options => {
          SSL_ca_file => $file_path,
      }
  
  The C<SSL_options> attribute could also be used for such things as providing a
  client certificate for authentication to a server or controlling the choice of
  cipher used for the TLS/SSL connection. See L<IO::Socket::SSL> documentation for
  details.
  
  =head1 PROXY SUPPORT
  
  HTTP::Tiny can proxy both C<http> and C<https> requests.  Only Basic proxy
  authorization is supported and it must be provided as part of the proxy URL:
  C<http://user:pass@proxy.example.com/>.
  
  HTTP::Tiny supports the following proxy environment variables:
  
  =over 4
  
  =item *
  
  http_proxy or HTTP_PROXY
  
  =item *
  
  https_proxy or HTTPS_PROXY
  
  =item *
  
  all_proxy or ALL_PROXY
  
  =back
  
  If the C<REQUEST_METHOD> environment variable is set, then this might be a CGI
  process and C<HTTP_PROXY> would be set from the C<Proxy:> header, which is a
  security risk.  If C<REQUEST_METHOD> is set, C<HTTP_PROXY> (the upper case
  variant only) is ignored, but C<CGI_HTTP_PROXY> is considered instead.
  
  Tunnelling C<https> over an C<http> proxy using the CONNECT method is
  supported.  If your proxy uses C<https> itself, you can not tunnel C<https>
  over it.
  
  Be warned that proxying an C<https> connection opens you to the risk of a
  man-in-the-middle attack by the proxy server.
  
  The C<no_proxy> environment variable is supported in the format of a
  comma-separated list of domain extensions proxy should not be used for.
  
  Proxy arguments passed to C<new> will override their corresponding
  environment variables.
  
  =head1 LIMITATIONS
  
  HTTP::Tiny is I<conditionally compliant> with the
  L<HTTP/1.1 specifications|http://www.w3.org/Protocols/>:
  
  =over 4
  
  =item *
  
  "Message Syntax and Routing" [RFC7230]
  
  =item *
  
  "Semantics and Content" [RFC7231]
  
  =item *
  
  "Conditional Requests" [RFC7232]
  
  =item *
  
  "Range Requests" [RFC7233]
  
  =item *
  
  "Caching" [RFC7234]
  
  =item *
  
  "Authentication" [RFC7235]
  
  =back
  
  It attempts to meet all "MUST" requirements of the specification, but does not
  implement all "SHOULD" requirements.  (Note: it was developed against the
  earlier RFC 2616 specification and may not yet meet the revised RFC 7230-7235
  spec.) Additionally, HTTP::Tiny supports the C<PATCH> method of RFC 5789.
  
  Some particular limitations of note include:
  
  =over
  
  =item *
  
  HTTP::Tiny focuses on correct transport.  Users are responsible for ensuring
  that user-defined headers and content are compliant with the HTTP/1.1
  specification.
  
  =item *
  
  Users must ensure that URLs are properly escaped for unsafe characters and that
  international domain names are properly encoded to ASCII. See L<URI::Escape>,
  L<URI::_punycode> and L<Net::IDN::Encode>.
  
  =item *
  
  Redirection is very strict against the specification.  Redirection is only
  automatic for response codes 301, 302, 307 and 308 if the request method is
  'GET' or 'HEAD'.  Response code 303 is always converted into a 'GET'
  redirection, as mandated by the specification.  There is no automatic support
  for status 305 ("Use proxy") redirections.
  
  =item *
  
  There is no provision for delaying a request body using an C<Expect> header.
  Unexpected C<1XX> responses are silently ignored as per the specification.
  
  =item *
  
  Only 'chunked' C<Transfer-Encoding> is supported.
  
  =item *
  
  There is no support for a Request-URI of '*' for the 'OPTIONS' request.
  
  =item *
  
  Headers mentioned in the RFCs and some other, well-known headers are
  generated with their canonical case.  Other headers are sent in the
  case provided by the user.  Except for control headers (which are sent first),
  headers are sent in arbitrary order.
  
  =back
  
  Despite the limitations listed above, HTTP::Tiny is considered
  feature-complete.  New feature requests should be directed to
  L<HTTP::Tiny::UA>.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<HTTP::Tiny::UA> - Higher level UA features for HTTP::Tiny
  
  =item *
  
  L<HTTP::Thin> - HTTP::Tiny wrapper with L<HTTP::Request>/L<HTTP::Response> compatibility
  
  =item *
  
  L<HTTP::Tiny::Mech> - Wrap L<WWW::Mechanize> instance in HTTP::Tiny compatible interface
  
  =item *
  
  L<IO::Socket::IP> - Required for IPv6 support
  
  =item *
  
  L<IO::Socket::SSL> - Required for SSL support
  
  =item *
  
  L<LWP::UserAgent> - If HTTP::Tiny isn't enough for you, this is the "standard" way to do things
  
  =item *
  
  L<Mozilla::CA> - Required if you want to validate SSL certificates
  
  =item *
  
  L<Net::SSLeay> - Required for SSL support
  
  =back
  
  =for :stopwords cpan testmatrix url bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/chansen/p5-http-tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/chansen/p5-http-tiny>
  
    git clone https://github.com/chansen/p5-http-tiny.git
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Christian Hansen <chansen@cpan.org>
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Alan Gardner Alessandro Ghedini A. Sinan Unur Brad Gilbert brian m. carlson Chris Nehren Weyl Claes Jakobsson Clinton Gormley Craig Berry David Golden Mitchell Dean Pearce Edward Zborowski Felipe Gasper Graham Knop Greg Kennedy James E Keenan Raspass Jeremy Mates Jess Robinson Karen Etheridge Lukas Eklund Martin J. Evans Martin-Louis Bright Matthew Horsfall Michael R. Davis Mike Doherty Nicolas Rochelemagne Olaf Alders Olivier Mengu Petr Psa sanjay-cpu Serguei Trouchelle Shoichi Kaji SkyMarshal Sren Kornetzki Steve Grazzini Stig Palmquist Syohei YOSHIDA Tatsuhiko Miyagawa Tom Hukins Tony Cook Xavier Guimard
  
  =over 4
  
  =item *
  
  Alan Gardner <gardner@pythian.com>
  
  =item *
  
  Alessandro Ghedini <al3xbio@gmail.com>
  
  =item *
  
  A. Sinan Unur <nanis@cpan.org>
  
  =item *
  
  Brad Gilbert <bgills@cpan.org>
  
  =item *
  
  brian m. carlson <sandals@crustytoothpaste.net>
  
  =item *
  
  Chris Nehren <apeiron@cpan.org>
  
  =item *
  
  Chris Weyl <cweyl@alumni.drew.edu>
  
  =item *
  
  Claes Jakobsson <claes@surfar.nu>
  
  =item *
  
  Clinton Gormley <clint@traveljury.com>
  
  =item *
  
  Craig A. Berry <craigberry@mac.com>
  
  =item *
  
  Craig Berry <cberry@cpan.org>
  
  =item *
  
  David Golden <xdg@xdg.me>
  
  =item *
  
  David Mitchell <davem@iabyn.com>
  
  =item *
  
  Dean Pearce <pearce@pythian.com>
  
  =item *
  
  Edward Zborowski <ed@rubensteintech.com>
  
  =item *
  
  Felipe Gasper <felipe@felipegasper.com>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Greg Kennedy <kennedy.greg@gmail.com>
  
  =item *
  
  James E Keenan <jkeenan@cpan.org>
  
  =item *
  
  James Raspass <jraspass@gmail.com>
  
  =item *
  
  Jeremy Mates <jmates@cpan.org>
  
  =item *
  
  Jess Robinson <castaway@desert-island.me.uk>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Lukas Eklund <leklund@gmail.com>
  
  =item *
  
  Martin J. Evans <mjegh@ntlworld.com>
  
  =item *
  
  Martin-Louis Bright <mlbright@gmail.com>
  
  =item *
  
  Matthew Horsfall <wolfsage@gmail.com>
  
  =item *
  
  Michael R. Davis <mrdvt92@users.noreply.github.com>
  
  =item *
  
  Mike Doherty <doherty@cpan.org>
  
  =item *
  
  Nicolas Rochelemagne <rochelemagne@cpanel.net>
  
  =item *
  
  Olaf Alders <olaf@wundersolutions.com>
  
  =item *
  
  Olivier Mengu <dolmen@cpan.org>
  
  =item *
  
  Petr Psa <ppisar@redhat.com>
  
  =item *
  
  sanjay-cpu <snjkmr32@gmail.com>
  
  =item *
  
  Serguei Trouchelle <stro@cpan.org>
  
  =item *
  
  Shoichi Kaji <skaji@cpan.org>
  
  =item *
  
  SkyMarshal <skymarshal1729@gmail.com>
  
  =item *
  
  Sren Kornetzki <soeren.kornetzki@delti.com>
  
  =item *
  
  Steve Grazzini <steve.grazzini@grantstreet.com>
  
  =item *
  
  Stig Palmquist <git@stig.io>
  
  =item *
  
  Syohei YOSHIDA <syohex@gmail.com>
  
  =item *
  
  Tatsuhiko Miyagawa <miyagawa@bulknews.net>
  
  =item *
  
  Tom Hukins <tom@eborcom.com>
  
  =item *
  
  Tony Cook <tony@develop-help.com>
  
  =item *
  
  Xavier Guimard <yadd@debian.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2023 by Christian Hansen.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
HTTP_TINY

    $fatpacked{"HTTP/Tiny/PreserveHostHeader.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'HTTP_TINY_PRESERVEHOSTHEADER';
  package HTTP::Tiny::PreserveHostHeader;
  
  =head1 NAME
  
  HTTP::Tiny::PreserveHostHeader - preserve Host header on requests
  
  =head1 SYNOPSIS
  
  =for markdown ```perl
  
      use HTTP::Tiny::PreserveHostHeader;
  
      my $response = HTTP::Tiny::PreserveHostHeader->new->get(
          'http://example.com', {
              headers => {
                  Host => 'example.net',
              }
          }
      );
  
  =for markdown ```
  
  =head1 DESCRIPTION
  
  This module extends L<HTTP::Tiny> and allows to preserve original C<Host>
  header from HTTP request.
  
  The L<HTTP::Tiny> is strictly compatible with HTTP 1.1 spec, section 14.23:
  
  =over
  
  The Host field value MUST represent the naming authority of the origin
  server or gateway given by the original URL.
  
  =back
  
  It means that L<HTTP::Tiny> always rewrite C<Host> header to the value
  taken from URL.
  
  Some non-standard HTTP clients, such as reverse HTTP proxy, need to override
  C<Host> header to other value.
  
  =for readme stop
  
  =cut
  
  use 5.006;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.0200';
  
  use parent qw(HTTP::Tiny);
  
  ## no critic(Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _prepare_headers_and_cb {
      my ($self, $request, $args, $url, $auth) = @_;
  
      my $host;
  
      while (my ($k, $v) = each %{ $args->{headers} }) {
          if (lc $k eq 'host') {
              $host = $v;
              delete $args->{headers}{$k};
          }
      }
  
      $self->SUPER::_prepare_headers_and_cb($request, $args, $url, $auth);
  
      $request->{headers}{host} = $host if $host;
  
      return;
  }
  
  ## no critic(Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _agent {
      my ($self) = @_;
      my $class = ref $self ? ref $self : $self;
      (my $default_agent = $class) =~ s{::}{-}g;
      ## no critic(Subroutines::ProtectPrivateSubs)
      return $default_agent . "/" . ($class->VERSION || 0) . " " . HTTP::Tiny->_agent;
  }
  
  1;
  
  =for readme continue
  
  =head1 SEE ALSO
  
  L<HTTP::Tiny>, L<https://github.com/chansen/p5-http-tiny/pull/34>.
  
  =head1 BUGS
  
  If you find the bug or want to implement new features, please report it at
  L<https://github.com/dex4er/perl-HTTP-Tiny-PreserveHostHeader/issues>
  
  The code repository is available at
  L<http://github.com/dex4er/perl-HTTP-Tiny-PreserveHostHeader>
  
  =head1 AUTHOR
  
  Piotr Roszatycki <dexter@cpan.org>
  
  =head1 LICENSE
  
  Copyright (c) 2014-2016, 2023 Piotr Roszatycki <dexter@cpan.org>.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as perl itself.
  
  See L<http://dev.perl.org/licenses/artistic.html>
HTTP_TINY_PRESERVEHOSTHEADER

    $fatpacked{"Hash/MultiValue.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'HASH_MULTIVALUE';
  package Hash::MultiValue;
  
  use strict;
  no warnings 'void';
  use 5.006_002;
  our $VERSION = '0.16';
  
  use Carp ();
  use Scalar::Util qw(refaddr);
  
  # there does not seem to be a relevant RT or perldelta entry for this
  use constant _SPLICE_SAME_ARRAY_SEGFAULT => $] < '5.008007';
  
  my %keys;
  my %values;
  my %registry;
  
  BEGIN {
      require Config;
      my $needs_registry = ($^O eq 'Win32' || $Config::Config{useithreads});
      if ($needs_registry) {
          *CLONE = sub {
              foreach my $oldaddr (keys %registry) {
                  my $this = refaddr $registry{$oldaddr};
                  $keys{$this}   = delete $keys{$oldaddr};
                  $values{$this} = delete $values{$oldaddr};
                  Scalar::Util::weaken($registry{$this} = delete $registry{$oldaddr});
              }
          };
      }
      *NEEDS_REGISTRY = sub () { $needs_registry };
  }
  
  if (defined &UNIVERSAL::ref::import) {
      UNIVERSAL::ref->import;
  }
  
  sub ref { 'HASH' }
  
  sub create {
      my $class = shift;
      my $self = bless {}, $class;
      my $this = refaddr $self;
      $keys{$this} = [];
      $values{$this} = [];
      Scalar::Util::weaken($registry{$this} = $self) if NEEDS_REGISTRY;
      $self;
  }
  
  sub new {
      my $class = shift;
      my $self = $class->create;
      unshift @_, $self;
      &{ $self->can('merge_flat') };
  }
  
  sub from_mixed {
      my $class = shift;
      my $self = $class->create;
      unshift @_, $self;
      &{ $self->can('merge_mixed') };
  }
  
  sub DESTROY {
      my $this = refaddr shift;
      delete $keys{$this};
      delete $values{$this};
      delete $registry{$this} if NEEDS_REGISTRY;
  }
  
  sub get {
      my($self, $key) = @_;
      $self->{$key};
  }
  
  sub get_all {
      my($self, $key) = @_;
      my $this = refaddr $self;
      my $k = $keys{$this};
      (@{$values{$this}}[grep { $key eq $k->[$_] } 0 .. $#$k]);
  }
  
  sub get_one {
      my ($self, $key) = @_;
      my @v = $self->get_all($key);
      return $v[0] if @v == 1;
      Carp::croak "Key not found: $key" if not @v;
      Carp::croak "Multiple values match: $key";
  }
  
  sub set {
      my $self = shift;
      my $key = shift;
  
      my $this = refaddr $self;
      my $k = $keys{$this};
      my $v = $values{$this};
  
      my @idx = grep { $key eq $k->[$_] } 0 .. $#$k;
  
      my $added = @_ - @idx;
      if ($added > 0) {
          my $start = $#$k + 1;
          push @$k, ($key) x $added;
          push @idx, $start .. $#$k;
      }
      elsif ($added < 0) {
          my ($start, @drop, @keep) = splice @idx, $added;
          for my $i ($start+1 .. $#$k) {
              if (@drop and $i == $drop[0]) {
                  shift @drop;
                  next;
              }
              push @keep, $i;
          }
  
          splice @$_, $start, 0+@$_, ( _SPLICE_SAME_ARRAY_SEGFAULT
              ? @{[ @$_[@keep] ]} # force different source array
              :     @$_[@keep]
          ) for $k, $v;
      }
  
      if (@_) {
          @$v[@idx] = @_;
          $self->{$key} = $_[-1];
      }
      else {
          delete $self->{$key};
      }
  
      $self;
  }
  
  sub add {
      my $self = shift;
      my $key = shift;
      $self->merge_mixed( $key => \@_ );
      $self;
  }
  
  sub merge_flat {
      my $self = shift;
      my $this = refaddr $self;
      my $k = $keys{$this};
      my $v = $values{$this};
      push @{ $_ & 1 ? $v : $k }, $_[$_] for 0 .. $#_;
      @{$self}{@$k} = @$v;
      $self;
  }
  
  sub merge_mixed {
      my $self = shift;
      my $this = refaddr $self;
      my $k = $keys{$this};
      my $v = $values{$this};
  
      my $hash;
      $hash = shift if @_ == 1;
  
      while ( my ($key, $value) = @_ ? splice @_, 0, 2 : each %$hash ) {
          if ( CORE::ref($value) eq 'ARRAY' ) {
              next if not @$value;
              push @$k, ($key) x @$value;
              push @$v, @$value;
          }
          else {
              push @$k, $key;
              push @$v, $value;
          }
          $self->{$key} = $v->[-1];
      }
  
      $self;
  }
  
  sub remove {
      my ($self, $key) = @_;
      $self->set($key);
      $self;
  }
  
  sub clear {
      my $self = shift;
      %$self = ();
      my $this = refaddr $self;
      $keys{$this} = [];
      $values{$this} = [];
      $self;
  }
  
  sub clone {
      my $self = shift;
      CORE::ref($self)->new($self->flatten);
  }
  
  sub keys {
      my $self = shift;
      return @{$keys{refaddr $self}};
  }
  
  sub values {
      my $self = shift;
      return @{$values{refaddr $self}};
  }
  
  sub flatten {
      my $self = shift;
      my $this = refaddr $self;
      my $k = $keys{$this};
      my $v = $values{$this};
      map { $k->[$_], $v->[$_] } 0 .. $#$k;
  }
  
  sub each {
      my ($self, $code) = @_;
      my $this = refaddr $self;
      my $k = $keys{$this};
      my $v = $values{$this};
      for (0 .. $#$k) {
          $code->($k->[$_], $v->[$_]);
      }
      return $self;
  }
  
  sub as_hashref {
      my $self = shift;
      my %hash = %$self;
      \%hash;
  }
  
  sub as_hashref_mixed {
      my $self = shift;
      my $this = refaddr $self;
      my $k = $keys{$this};
      my $v = $values{$this};
  
      my %hash;
      push @{$hash{$k->[$_]}}, $v->[$_] for 0 .. $#$k;
      for (CORE::values %hash) {
          $_ = $_->[0] if 1 == @$_;
      }
  
      \%hash;
  }
  
  *mixed = \&as_hashref_mixed;
  
  sub as_hashref_multi {
      my $self = shift;
      my $this = refaddr $self;
      my $k = $keys{$this};
      my $v = $values{$this};
  
      my %hash;
      push @{$hash{$k->[$_]}}, $v->[$_] for 0 .. $#$k;
  
      \%hash;
  }
  
  *multi = \&as_hashref_multi;
  
  sub STORABLE_freeze {
      my $self = shift;
      my $this = refaddr $self;
      return '', $keys{$this}, $values{$this};
  }
  
  sub STORABLE_thaw {
      my $self = shift;
      my ($is_cloning, $serialised, $k, $v) = @_;
      my $this = refaddr $self;
      $keys  {$this} = $k;
      $values{$this} = $v;
      @{$self}{@$k} = @$v;
      return $self;
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =for stopwords
  
  =head1 NAME
  
  Hash::MultiValue - Store multiple values per key
  
  =head1 SYNOPSIS
  
    use Hash::MultiValue;
  
    my $hash = Hash::MultiValue->new(
        foo => 'a',
        foo => 'b',
        bar => 'baz',
    );
  
    # $hash is an object, but can be used as a hashref and DWIMs!
    my $foo = $hash->{foo};         # 'b' (the last entry)
    my $foo = $hash->get('foo');    # 'b' (always, regardless of context)
    my @foo = $hash->get_all('foo'); # ('a', 'b')
  
    keys %$hash; # ('foo', 'bar')    not guaranteed to be ordered
    $hash->keys; # ('foo', 'foo', 'bar') guaranteed to be ordered
  
  =head1 DESCRIPTION
  
  Hash::MultiValue is an object (and a plain hash reference) that may
  contain multiple values per key, inspired by MultiDict of WebOb.
  
  =head1 RATIONALE
  
  In a typical web application, the request parameters (a.k.a CGI
  parameters) can be single value or multi values. Using CGI.pm style
  C<param> is one way to deal with this problem (and it is good, as long
  as you're aware of its list context gotcha), but there's another
  approach to convert parameters into a hash reference, like Catalyst's
  C<< $c->req->parameters >> does, and it B<sucks>.
  
  Why? Because the value could be just a scalar if there is one value
  and an array ref if there are multiple, depending on I<user input>
  rather than I<how you code it>. So your code should always be like
  this to be defensive:
  
    my $p = $c->req->parameters;
    my @maybe_multi = ref $p->{m} eq 'ARRAY' ? @{$p->{m}} : ($p->{m});
    my $must_single = ref $p->{m} eq 'ARRAY' ? $p->{m}->[0] : $p->{m};
  
  Otherwise you'll get a random runtime exception of I<Can't use string
  as an ARRAY ref> or get stringified array I<ARRAY(0xXXXXXXXXX)> as a
  string, I<depending on user input> and that is miserable and
  insecure.
  
  This module provides a solution to this by making it behave like a
  single value hash reference, but also has an API to get multiple
  values on demand, explicitly.
  
  =head1 HOW THIS WORKS
  
  The object returned by C<new> is a blessed hash reference that
  contains the last entry of the same key if there are multiple values,
  but it also keeps the original pair state in the object tracker (a.k.a
  inside out objects) and allows you to access the original pairs and
  multiple values via the method calls, such as C<get_all> or C<flatten>.
  
  This module does not use C<tie> or L<overload> and is quite fast.
  
  Yes, there is L<Tie::Hash::MultiValue> and this module tries to solve
  exactly the same problem, but using a different implementation.
  
  =head1 UPDATING CONTENTS
  
  When you update the content of the hash, B<DO NOT UPDATE> using the
  hash reference interface: this won't write through to the tracking
  object.
  
    my $hash = Hash::MultiValue->new(...);
  
    # WRONG
    $hash->{foo} = 'bar';
    delete $hash->{foo};
  
    # Correct
    $hash->add(foo => 'bar');
    $hash->remove('foo');
  
  See below for the list of updating methods.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $hash = Hash::MultiValue->new(@pairs);
  
  Creates a new object that can be treated as a plain hash reference as well.
  
  =item get
  
    $value = $hash->get($key);
    $value = $hash->{$key};
  
  Returns a single value for the given C<$key>. If there are multiple
  values, the last one (not first one) is returned. See below for why.
  
  Note that this B<always> returns the single element as a scalar,
  regardless of its context, unlike CGI.pm's C<param> method etc.
  
  =item get_one
  
    $value = $hash->get_one($key);
  
  Returns a single value for the given C<$key>. This method B<croaks> if
  there is no value or multiple values associated with the key, so you
  should wrap it with eval or modules like L<Try::Tiny>.
  
  =item get_all
  
    @values = $hash->get_all($key);
  
  Returns a list of values for the given C<$key>. This method B<always>
  returns a list regardless of its context. If there is no value
  attached, the result will be an empty list.
  
  =item keys
  
    @keys = $hash->keys;
  
  Returns a list of all keys, including duplicates (see the example in the
  L</SYNOPSIS>).
  
  If you want only unique keys, use C<< keys %$hash >>, as normal.
  
  =item values
  
    @values = $hash->values;
  
  Returns a list of all values, in the same order as C<< $hash->keys >>.
  
  =item set
  
    $hash->set($key [, $value ... ]);
  
  Changes the stored value(s) of the given C<$key>. This removes or adds
  pairs as necessary to store the new list but otherwise preserves order
  of existing pairs. C<< $hash->{$key} >> is updated to point to the last
  value.
  
  =item add
  
    $hash->add($key, $value [, $value ... ]);
  
  Appends a new value to the given C<$key>. This updates the value of
  C<< $hash->{$key} >> as well so it always points to the last value.
  
  =item remove
  
    $hash->remove($key);
  
  Removes a key and associated values for the given C<$key>.
  
  =item clear
  
    $hash->clear;
  
  Clears the hash to be an empty hash reference.
  
  =item flatten
  
    @pairs = $hash->flatten;
  
  Gets pairs of keys and values. This should be exactly the same pairs
  which are given to C<new> method unless you updated the data.
  
  =item each
  
    $hash->each($code);
  
    # e.g.
    $hash->each(sub { print "$_[0] = $_[1]\n" });
  
  Calls C<$code> once for each C<($key, $value)> pair.  This is a more convenient
  alternative to calling C<flatten> and then iterating over it two items at a
  time.
  
  Inside C<$code>, C<$_> contains the current iteration through the loop,
  starting at 0.  For example:
  
    $hash = Hash::MultiValue->new(a => 1, b => 2, c => 3, a => 4);
  
    $hash->each(sub { print "$_: $_[0] = $_[1]\n" });
    # 0: a = 1
    # 1: b = 2
    # 2: c = 3
    # 3: a = 4
  
  Be careful B<not> to change C<@_> inside your coderef!  It will update
  the tracking object but not the plain hash.  In the future, this
  limitation I<may> be removed.
  
  =item clone
  
    $new = $hash->clone;
  
  Creates a new Hash::MultiValue object that represents the same data,
  but obviously not sharing the reference. It's identical to:
  
    $new = Hash::MultiValue->new($hash->flatten);
  
  =item as_hashref
  
    $copy = $hash->as_hashref;
  
  Creates a new plain (unblessed) hash reference where a value is a
  single scalar. It's identical to:
  
    $copy = +{%$hash};
  
  =item as_hashref_mixed, mixed
  
    $mixed = $hash->as_hashref_mixed;
    $mixed = $hash->mixed;
  
  Creates a new plain (unblessed) hash reference where the value is a
  single scalar, or an array ref when there are multiple values for a
  same key. Handy to create a hash reference that is often used in web
  application frameworks request objects such as L<Catalyst>. Ths method
  does exactly the opposite of C<from_mixed>.
  
  =item as_hashref_multi, multi
  
    $multi = $hash->as_hashref_multi;
    $multi = $hash->multi;
  
  Creates a new plain (unblessed) hash reference where values are all
  array references, regardless of there are single or multiple values
  for a same key.
  
  =item from_mixed
  
    $hash = Hash::MultiValue->from_mixed({
        foo => [ 'a', 'b' ],
        bar => 'c',
    });
  
  Creates a new object out of a hash reference where the value is single
  or an array ref depending on the number of elements. Handy to convert
  from those request objects used in web frameworks such as L<Catalyst>.
  This method does exactly the opposite of C<as_hashref_mixed>.
  
  =back
  
  =head1 WHY LAST NOT FIRST?
  
  You might wonder why this module uses the I<last> value of the same
  key instead of I<first>. There's no strong reasoning on this decision
  since one is as arbitrary as the other, but this is more consistent to
  what Perl does:
  
    sub x {
        return ('a', 'b', 'c');
    }
  
    my $x = x(); # $x = 'c'
  
    my %a = ( a => 1 );
    my %b = ( a => 2 );
  
    my %m = (%a, %b); # $m{a} = 2
  
  When perl gets a list in a scalar context it gets the last entry. Also
  if you merge hashes having a same key, the last one wins.
  
  =head1 NOTES ON ref
  
  If you pass this MultiValue hash object to some upstream functions
  that you can't control and does things like:
  
    if (ref $args eq 'HASH') {
        ...
    }
  
  because this is a blessed hash reference it doesn't match and would
  fail. To avoid that you should call C<as_hashref> to get a
  I<finalized> (= non-blessed) hash reference.
  
  You can also use UNIVERSAL::ref to make it work magically:
  
    use UNIVERSAL::ref;    # before loading Hash::MultiValue
    use Hash::MultiValue;
  
  and then all C<ref> calls to Hash::MultiValue objects will return I<HASH>.
  
  =head1 THREAD SAFETY
  
  Prior to version 0.09, this module wasn't safe in a threaded
  environment, including win32 fork() emulation. Versions newer than
  0.09 is considered thread safe.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa E<lt>miyagawa@bulknews.netE<gt>
  
  Aristotle Pagaltzis
  
  Hans Dieter Pearcey
  
  Thanks to Michael Peters for the suggestion to use inside-out objects
  instead of tie.
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<http://pythonpaste.org/webob/#multidict>
  
  =item * L<Tie::Hash::MultiValue>
  
  =back
  
  =cut
HASH_MULTIVALUE

    $fatpacked{"IO/Socket/IP.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'IO_SOCKET_IP';
  #  You may distribute under the terms of either the GNU General Public License
  #  or the Artistic License (the same terms as Perl itself)
  #
  #  (C) Paul Evans, 2010-2020 -- leonerd@leonerd.org.uk
  
  package IO::Socket::IP;
  
  use v5;
  use strict;
  use warnings;
  
  # $VERSION needs to be set before  use base 'IO::Socket'
  #  - https://rt.cpan.org/Ticket/Display.html?id=92107
  BEGIN {
     our $VERSION = '0.41';
  }
  
  use base qw( IO::Socket );
  
  use Carp;
  
  use Socket 1.97 qw(
     getaddrinfo getnameinfo
     sockaddr_family
     AF_INET
     AI_PASSIVE
     IPPROTO_TCP IPPROTO_UDP
     IPPROTO_IPV6 IPV6_V6ONLY
     NI_DGRAM NI_NUMERICHOST NI_NUMERICSERV NIx_NOHOST NIx_NOSERV
     SO_REUSEADDR SO_REUSEPORT SO_BROADCAST SO_ERROR
     SOCK_DGRAM SOCK_STREAM
     SOL_SOCKET
  );
  my $AF_INET6 = eval { Socket::AF_INET6() }; # may not be defined
  my $AI_ADDRCONFIG = eval { Socket::AI_ADDRCONFIG() } || 0;
  use POSIX qw( dup2 );
  use Errno qw( EINVAL EINPROGRESS EISCONN ENOTCONN ETIMEDOUT EWOULDBLOCK EOPNOTSUPP );
  
  use constant HAVE_MSWIN32 => ( $^O eq "MSWin32" );
  
  # At least one OS (Android) is known not to have getprotobyname()
  use constant HAVE_GETPROTOBYNAME => defined eval { getprotobyname( "tcp" ) };
  
  my $IPv6_re = do {
     # translation of RFC 3986 3.2.2 ABNF to re
     my $IPv4address = do {
        my $dec_octet = q<(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])>;
        qq<$dec_octet(?: \\. $dec_octet){3}>;
     };
     my $IPv6address = do {
        my $h16  = qq<[0-9A-Fa-f]{1,4}>;
        my $ls32 = qq<(?: $h16 : $h16 | $IPv4address)>;
        qq<(?:
                                              (?: $h16 : ){6} $ls32
           |                               :: (?: $h16 : ){5} $ls32
           | (?:                   $h16 )? :: (?: $h16 : ){4} $ls32
           | (?: (?: $h16 : ){0,1} $h16 )? :: (?: $h16 : ){3} $ls32
           | (?: (?: $h16 : ){0,2} $h16 )? :: (?: $h16 : ){2} $ls32
           | (?: (?: $h16 : ){0,3} $h16 )? ::     $h16 :      $ls32
           | (?: (?: $h16 : ){0,4} $h16 )? ::                 $ls32
           | (?: (?: $h16 : ){0,5} $h16 )? ::                 $h16
           | (?: (?: $h16 : ){0,6} $h16 )? ::
        )>
     };
     qr<$IPv6address>xo;
  };
  
  =head1 NAME
  
  C<IO::Socket::IP> - Family-neutral IP socket supporting both IPv4 and IPv6
  
  =head1 SYNOPSIS
  
   use IO::Socket::IP;
  
   my $sock = IO::Socket::IP->new(
      PeerHost => "www.google.com",
      PeerPort => "http",
      Type     => SOCK_STREAM,
   ) or die "Cannot construct socket - $@";
  
   my $familyname = ( $sock->sockdomain == PF_INET6 ) ? "IPv6" :
                    ( $sock->sockdomain == PF_INET  ) ? "IPv4" :
                                                        "unknown";
  
   printf "Connected to google via %s\n", $familyname;
  
  =head1 DESCRIPTION
  
  This module provides a protocol-independent way to use IPv4 and IPv6 sockets,
  intended as a replacement for L<IO::Socket::INET>. Most constructor arguments
  and methods are provided in a backward-compatible way. For a list of known
  differences, see the C<IO::Socket::INET> INCOMPATIBILITES section below.
  
  It uses the C<getaddrinfo(3)> function to convert hostnames and service names
  or port numbers into sets of possible addresses to connect to or listen on.
  This allows it to work for IPv6 where the system supports it, while still
  falling back to IPv4-only on systems which don't.
  
  =head1 REPLACING C<IO::Socket> DEFAULT BEHAVIOUR
  
  By placing C<-register> in the import list to C<IO::Socket::IP>, it will
  register itself with L<IO::Socket> as the class that handles C<PF_INET>. It
  will also ask to handle C<PF_INET6> as well, provided that constant is
  available.
  
  Changing C<IO::Socket>'s default behaviour means that calling the
  C<IO::Socket> constructor with either C<PF_INET> or C<PF_INET6> as the
  C<Domain> parameter will yield an C<IO::Socket::IP> object.
  
   use IO::Socket::IP -register;
  
   my $sock = IO::Socket->new(
      Domain    => PF_INET6,
      LocalHost => "::1",
      Listen    => 1,
   ) or die "Cannot create socket - $@\n";
  
   print "Created a socket of type " . ref($sock) . "\n";
  
  Note that C<-register> is a global setting that applies to the entire program;
  it cannot be applied only for certain callers, removed, or limited by lexical
  scope.
  
  =cut
  
  sub import
  {
     my $pkg = shift;
     my @symbols;
  
     foreach ( @_ ) {
        if( $_ eq "-register" ) {
           IO::Socket::IP::_ForINET->register_domain( AF_INET );
           IO::Socket::IP::_ForINET6->register_domain( $AF_INET6 ) if defined $AF_INET6;
        }
        else {
           push @symbols, $_;
        }
     }
  
     @_ = ( $pkg, @symbols );
     goto &IO::Socket::import;
  }
  
  # Convenient capability test function
  {
     my $can_disable_v6only;
     sub CAN_DISABLE_V6ONLY
     {
        return $can_disable_v6only if defined $can_disable_v6only;
  
        socket my $testsock, Socket::PF_INET6(), SOCK_STREAM, 0 or
           die "Cannot socket(PF_INET6) - $!";
  
        if( setsockopt $testsock, IPPROTO_IPV6, IPV6_V6ONLY, 0 ) {
           return $can_disable_v6only = 1;
        }
        elsif( $! == EINVAL || $! == EOPNOTSUPP ) {
           return $can_disable_v6only = 0;
        }
        else {
           die "Cannot setsockopt() - $!";
        }
     }
  }
  
  =head1 CONSTRUCTORS
  
  =cut
  
  =head2 new
  
     $sock = IO::Socket::IP->new( %args )
  
  Creates a new C<IO::Socket::IP> object, containing a newly created socket
  handle according to the named arguments passed. The recognised arguments are:
  
  =over 8
  
  =item PeerHost => STRING
  
  =item PeerService => STRING
  
  Hostname and service name for the peer to C<connect()> to. The service name
  may be given as a port number, as a decimal string.
  
  =item PeerAddr => STRING
  
  =item PeerPort => STRING
  
  For symmetry with the accessor methods and compatibility with
  C<IO::Socket::INET>, these are accepted as synonyms for C<PeerHost> and
  C<PeerService> respectively.
  
  =item PeerAddrInfo => ARRAY
  
  Alternate form of specifying the peer to C<connect()> to. This should be an
  array of the form returned by C<Socket::getaddrinfo>.
  
  This parameter takes precedence over the C<Peer*>, C<Family>, C<Type> and
  C<Proto> arguments.
  
  =item LocalHost => STRING
  
  =item LocalService => STRING
  
  Hostname and service name for the local address to C<bind()> to.
  
  =item LocalAddr => STRING
  
  =item LocalPort => STRING
  
  For symmetry with the accessor methods and compatibility with
  C<IO::Socket::INET>, these are accepted as synonyms for C<LocalHost> and
  C<LocalService> respectively.
  
  =item LocalAddrInfo => ARRAY
  
  Alternate form of specifying the local address to C<bind()> to. This should be
  an array of the form returned by C<Socket::getaddrinfo>.
  
  This parameter takes precedence over the C<Local*>, C<Family>, C<Type> and
  C<Proto> arguments.
  
  =item Family => INT
  
  The address family to pass to C<getaddrinfo> (e.g. C<AF_INET>, C<AF_INET6>).
  Normally this will be left undefined, and C<getaddrinfo> will search using any
  address family supported by the system.
  
  =item Type => INT
  
  The socket type to pass to C<getaddrinfo> (e.g. C<SOCK_STREAM>,
  C<SOCK_DGRAM>). Normally defined by the caller; if left undefined
  C<getaddrinfo> may attempt to infer the type from the service name.
  
  =item Proto => STRING or INT
  
  The IP protocol to use for the socket (e.g. C<'tcp'>, C<IPPROTO_TCP>,
  C<'udp'>,C<IPPROTO_UDP>). Normally this will be left undefined, and either
  C<getaddrinfo> or the kernel will choose an appropriate value. May be given
  either in string name or numeric form.
  
  =item GetAddrInfoFlags => INT
  
  More flags to pass to the C<getaddrinfo()> function. If not supplied, a
  default of C<AI_ADDRCONFIG> will be used.
  
  These flags will be combined with C<AI_PASSIVE> if the C<Listen> argument is
  given. For more information see the documentation about C<getaddrinfo()> in
  the L<Socket> module.
  
  =item Listen => INT
  
  If defined, puts the socket into listening mode where new connections can be
  accepted using the C<accept> method. The value given is used as the
  C<listen(2)> queue size.
  
  =item ReuseAddr => BOOL
  
  If true, set the C<SO_REUSEADDR> sockopt
  
  =item ReusePort => BOOL
  
  If true, set the C<SO_REUSEPORT> sockopt (not all OSes implement this sockopt)
  
  =item Broadcast => BOOL
  
  If true, set the C<SO_BROADCAST> sockopt
  
  =item Sockopts => ARRAY
  
  An optional array of other socket options to apply after the three listed
  above. The value is an ARRAY containing 2- or 3-element ARRAYrefs. Each inner
  array relates to a single option, giving the level and option name, and an
  optional value. If the value element is missing, it will be given the value of
  a platform-sized integer 1 constant (i.e. suitable to enable most of the
  common boolean options).
  
  For example, both options given below are equivalent to setting C<ReuseAddr>.
  
   Sockopts => [
      [ SOL_SOCKET, SO_REUSEADDR ],
      [ SOL_SOCKET, SO_REUSEADDR, pack( "i", 1 ) ],
   ]
  
  =item V6Only => BOOL
  
  If defined, set the C<IPV6_V6ONLY> sockopt when creating C<PF_INET6> sockets
  to the given value. If true, a listening-mode socket will only listen on the
  C<AF_INET6> addresses; if false it will also accept connections from
  C<AF_INET> addresses.
  
  If not defined, the socket option will not be changed, and default value set
  by the operating system will apply. For repeatable behaviour across platforms
  it is recommended this value always be defined for listening-mode sockets.
  
  Note that not all platforms support disabling this option. Some, at least
  OpenBSD and MirBSD, will fail with C<EINVAL> if you attempt to disable it.
  To determine whether it is possible to disable, you may use the class method
  
   if( IO::Socket::IP->CAN_DISABLE_V6ONLY ) {
      ...
   }
   else {
      ...
   }
  
  If your platform does not support disabling this option but you still want to
  listen for both C<AF_INET> and C<AF_INET6> connections you will have to create
  two listening sockets, one bound to each protocol.
  
  =item MultiHomed
  
  This C<IO::Socket::INET>-style argument is ignored, except if it is defined
  but false. See the C<IO::Socket::INET> INCOMPATIBILITES section below.
  
  However, the behaviour it enables is always performed by C<IO::Socket::IP>.
  
  =item Blocking => BOOL
  
  If defined but false, the socket will be set to non-blocking mode. Otherwise
  it will default to blocking mode. See the NON-BLOCKING section below for more
  detail.
  
  =item Timeout => NUM
  
  If defined, gives a maximum time in seconds to block per C<connect()> call
  when in blocking mode. If missing, no timeout is applied other than that
  provided by the underlying operating system. When in non-blocking mode this
  parameter is ignored.
  
  Note that if the hostname resolves to multiple address candidates, the same
  timeout will apply to each connection attempt individually, rather than to the
  operation as a whole. Further note that the timeout does not apply to the
  initial hostname resolve operation, if connecting by hostname.
  
  This behviour is copied inspired by C<IO::Socket::INET>; for more fine grained
  control over connection timeouts, consider performing a nonblocking connect
  directly.
  
  =back
  
  If neither C<Type> nor C<Proto> hints are provided, a default of
  C<SOCK_STREAM> and C<IPPROTO_TCP> respectively will be set, to maintain
  compatibility with C<IO::Socket::INET>. Other named arguments that are not
  recognised are ignored.
  
  If neither C<Family> nor any hosts or addresses are passed, nor any
  C<*AddrInfo>, then the constructor has no information on which to decide a
  socket family to create. In this case, it performs a C<getaddinfo> call with
  the C<AI_ADDRCONFIG> flag, no host name, and a service name of C<"0">, and
  uses the family of the first returned result.
  
  If the constructor fails, it will set C<$@> to an appropriate error message;
  this may be from C<$!> or it may be some other string; not every failure
  necessarily has an associated C<errno> value.
  
  =head2 new (one arg)
  
     $sock = IO::Socket::IP->new( $peeraddr )
  
  As a special case, if the constructor is passed a single argument (as
  opposed to an even-sized list of key/value pairs), it is taken to be the value
  of the C<PeerAddr> parameter. This is parsed in the same way, according to the
  behaviour given in the C<PeerHost> AND C<LocalHost> PARSING section below.
  
  =cut
  
  sub new
  {
     my $class = shift;
     my %arg = (@_ == 1) ? (PeerHost => $_[0]) : @_;
     return $class->SUPER::new(%arg);
  }
  
  # IO::Socket may call this one; neaten up the arguments from IO::Socket::INET
  # before calling our real _configure method
  sub configure
  {
     my $self = shift;
     my ( $arg ) = @_;
  
     $arg->{PeerHost} = delete $arg->{PeerAddr}
        if exists $arg->{PeerAddr} && !exists $arg->{PeerHost};
  
     $arg->{PeerService} = delete $arg->{PeerPort}
        if exists $arg->{PeerPort} && !exists $arg->{PeerService};
  
     $arg->{LocalHost} = delete $arg->{LocalAddr}
        if exists $arg->{LocalAddr} && !exists $arg->{LocalHost};
  
     $arg->{LocalService} = delete $arg->{LocalPort}
        if exists $arg->{LocalPort} && !exists $arg->{LocalService};
  
     for my $type (qw(Peer Local)) {
        my $host    = $type . 'Host';
        my $service = $type . 'Service';
  
        if( defined $arg->{$host} ) {
           ( $arg->{$host}, my $s ) = $self->split_addr( $arg->{$host} );
           # IO::Socket::INET compat - *Host parsed port always takes precedence
           $arg->{$service} = $s if defined $s;
        }
     }
  
     $self->_io_socket_ip__configure( $arg );
  }
  
  # Avoid simply calling it _configure, as some subclasses of IO::Socket::INET on CPAN already take that
  sub _io_socket_ip__configure
  {
     my $self = shift;
     my ( $arg ) = @_;
  
     my %hints;
     my @localinfos;
     my @peerinfos;
  
     my $listenqueue = $arg->{Listen};
     if( defined $listenqueue and
         ( defined $arg->{PeerHost} || defined $arg->{PeerService} || defined $arg->{PeerAddrInfo} ) ) {
        croak "Cannot Listen with a peer address";
     }
  
     if( defined $arg->{GetAddrInfoFlags} ) {
        $hints{flags} = $arg->{GetAddrInfoFlags};
     }
     else {
        $hints{flags} = $AI_ADDRCONFIG;
     }
  
     if( defined( my $family = $arg->{Family} ) ) {
        $hints{family} = $family;
     }
  
     if( defined( my $type = $arg->{Type} ) ) {
        $hints{socktype} = $type;
     }
  
     if( defined( my $proto = $arg->{Proto} ) ) {
        unless( $proto =~ m/^\d+$/ ) {
           my $protonum = HAVE_GETPROTOBYNAME
              ? getprotobyname( $proto )
              : eval { Socket->${\"IPPROTO_\U$proto"}() };
           defined $protonum or croak "Unrecognised protocol $proto";
           $proto = $protonum;
        }
  
        $hints{protocol} = $proto;
     }
  
     # To maintain compatibility with IO::Socket::INET, imply a default of
     # SOCK_STREAM + IPPROTO_TCP if neither hint is given
     if( !defined $hints{socktype} and !defined $hints{protocol} ) {
        $hints{socktype} = SOCK_STREAM;
        $hints{protocol} = IPPROTO_TCP;
     }
  
     # Some OSes (NetBSD) don't seem to like just a protocol hint without a
     # socktype hint as well. We'll set a couple of common ones
     if( !defined $hints{socktype} and defined $hints{protocol} ) {
        $hints{socktype} = SOCK_STREAM if $hints{protocol} == IPPROTO_TCP;
        $hints{socktype} = SOCK_DGRAM  if $hints{protocol} == IPPROTO_UDP;
     }
  
     if( my $info = $arg->{LocalAddrInfo} ) {
        ref $info eq "ARRAY" or croak "Expected 'LocalAddrInfo' to be an ARRAY ref";
        @localinfos = @$info;
     }
     elsif( defined $arg->{LocalHost} or
            defined $arg->{LocalService} or
            HAVE_MSWIN32 and $arg->{Listen} ) {
        # Either may be undef
        my $host = $arg->{LocalHost};
        my $service = $arg->{LocalService};
  
        unless ( defined $host or defined $service ) {
           $service = 0;
        }
  
        local $1; # Placate a taint-related bug; [perl #67962]
        defined $service and $service =~ s/\((\d+)\)$// and
           my $fallback_port = $1;
  
        my %localhints = %hints;
        $localhints{flags} |= AI_PASSIVE;
        ( my $err, @localinfos ) = getaddrinfo( $host, $service, \%localhints );
  
        if( $err and defined $fallback_port ) {
           ( $err, @localinfos ) = getaddrinfo( $host, $fallback_port, \%localhints );
        }
  
        if( $err ) {
           $@ = "$err";
           $! = EINVAL;
           return;
        }
     }
  
     if( my $info = $arg->{PeerAddrInfo} ) {
        ref $info eq "ARRAY" or croak "Expected 'PeerAddrInfo' to be an ARRAY ref";
        @peerinfos = @$info;
     }
     elsif( defined $arg->{PeerHost} or defined $arg->{PeerService} ) {
        defined( my $host = $arg->{PeerHost} ) or
           croak "Expected 'PeerHost'";
        defined( my $service = $arg->{PeerService} ) or
           croak "Expected 'PeerService'";
  
        local $1; # Placate a taint-related bug; [perl #67962]
        defined $service and $service =~ s/\((\d+)\)$// and
           my $fallback_port = $1;
  
        ( my $err, @peerinfos ) = getaddrinfo( $host, $service, \%hints );
  
        if( $err and defined $fallback_port ) {
           ( $err, @peerinfos ) = getaddrinfo( $host, $fallback_port, \%hints );
        }
  
        if( $err ) {
           $@ = "$err";
           $! = EINVAL;
           return;
        }
     }
  
     my $INT_1 = pack "i", 1;
  
     my @sockopts_enabled;
     push @sockopts_enabled, [ SOL_SOCKET, SO_REUSEADDR, $INT_1 ] if $arg->{ReuseAddr};
     push @sockopts_enabled, [ SOL_SOCKET, SO_REUSEPORT, $INT_1 ] if $arg->{ReusePort};
     push @sockopts_enabled, [ SOL_SOCKET, SO_BROADCAST, $INT_1 ] if $arg->{Broadcast};
  
     if( my $sockopts = $arg->{Sockopts} ) {
        ref $sockopts eq "ARRAY" or croak "Expected 'Sockopts' to be an ARRAY ref";
        foreach ( @$sockopts ) {
           ref $_ eq "ARRAY" or croak "Bad Sockopts item - expected ARRAYref";
           @$_ >= 2 and @$_ <= 3 or
              croak "Bad Sockopts item - expected 2 or 3 elements";
  
           my ( $level, $optname, $value ) = @$_;
           # TODO: consider more sanity checking on argument values
  
           defined $value or $value = $INT_1;
           push @sockopts_enabled, [ $level, $optname, $value ];
        }
     }
  
     my $blocking = $arg->{Blocking};
     defined $blocking or $blocking = 1;
  
     my $v6only = $arg->{V6Only};
  
     # IO::Socket::INET defines this key. IO::Socket::IP always implements the
     # behaviour it requests, so we can ignore it, unless the caller is for some
     # reason asking to disable it.
     if( defined $arg->{MultiHomed} and !$arg->{MultiHomed} ) {
        croak "Cannot disable the MultiHomed parameter";
     }
  
     my @infos;
     foreach my $local ( @localinfos ? @localinfos : {} ) {
        foreach my $peer ( @peerinfos ? @peerinfos : {} ) {
           next if defined $local->{family}   and defined $peer->{family}   and
              $local->{family} != $peer->{family};
           next if defined $local->{socktype} and defined $peer->{socktype} and
              $local->{socktype} != $peer->{socktype};
           next if defined $local->{protocol} and defined $peer->{protocol} and
              $local->{protocol} != $peer->{protocol};
  
           my $family   = $local->{family}   || $peer->{family}   or next;
           my $socktype = $local->{socktype} || $peer->{socktype} or next;
           my $protocol = $local->{protocol} || $peer->{protocol} || 0;
  
           push @infos, {
              family    => $family,
              socktype  => $socktype,
              protocol  => $protocol,
              localaddr => $local->{addr},
              peeraddr  => $peer->{addr},
           };
        }
     }
  
     if( !@infos ) {
        # If there was a Family hint then create a plain unbound, unconnected socket
        if( defined $hints{family} ) {
           @infos = ( {
              family   => $hints{family},
              socktype => $hints{socktype},
              protocol => $hints{protocol},
           } );
        }
        # If there wasn't, use getaddrinfo()'s AI_ADDRCONFIG side-effect to guess a
        # suitable family first.
        else {
           ( my $err, @infos ) = getaddrinfo( "", "0", \%hints );
           if( $err ) {
              $@ = "$err";
              $! = EINVAL;
              return;
           }
  
           # We'll take all the @infos anyway, because some OSes (HPUX) are known to
           # ignore the AI_ADDRCONFIG hint and return AF_INET6 even if they don't
           # support them
        }
     }
  
     # In the nonblocking case, caller will be calling ->setup multiple times.
     # Store configuration in the object for the ->setup method
     # Yes, these are messy. Sorry, I can't help that...
  
     ${*$self}{io_socket_ip_infos} = \@infos;
  
     ${*$self}{io_socket_ip_idx} = -1;
  
     ${*$self}{io_socket_ip_sockopts} = \@sockopts_enabled;
     ${*$self}{io_socket_ip_v6only} = $v6only;
     ${*$self}{io_socket_ip_listenqueue} = $listenqueue;
     ${*$self}{io_socket_ip_blocking} = $blocking;
  
     ${*$self}{io_socket_ip_errors} = [ undef, undef, undef ];
  
     # ->setup is allowed to return false in nonblocking mode
     $self->setup or !$blocking or return undef;
  
     return $self;
  }
  
  sub setup
  {
     my $self = shift;
  
     while(1) {
        ${*$self}{io_socket_ip_idx}++;
        last if ${*$self}{io_socket_ip_idx} >= @{ ${*$self}{io_socket_ip_infos} };
  
        my $info = ${*$self}{io_socket_ip_infos}->[${*$self}{io_socket_ip_idx}];
  
        $self->socket( @{$info}{qw( family socktype protocol )} ) or
           ( ${*$self}{io_socket_ip_errors}[2] = $!, next );
  
        $self->blocking( 0 ) unless ${*$self}{io_socket_ip_blocking};
  
        foreach my $sockopt ( @{ ${*$self}{io_socket_ip_sockopts} } ) {
           my ( $level, $optname, $value ) = @$sockopt;
           $self->setsockopt( $level, $optname, $value ) or ( $@ = "$!", return undef );
        }
  
        if( defined ${*$self}{io_socket_ip_v6only} and defined $AF_INET6 and $info->{family} == $AF_INET6 ) {
           my $v6only = ${*$self}{io_socket_ip_v6only};
           $self->setsockopt( IPPROTO_IPV6, IPV6_V6ONLY, pack "i", $v6only ) or ( $@ = "$!", return undef );
        }
  
        if( defined( my $addr = $info->{localaddr} ) ) {
           $self->bind( $addr ) or
              ( ${*$self}{io_socket_ip_errors}[1] = $!, next );
        }
  
        if( defined( my $listenqueue = ${*$self}{io_socket_ip_listenqueue} ) ) {
           $self->listen( $listenqueue ) or ( $@ = "$!", return undef );
        }
  
        if( defined( my $addr = $info->{peeraddr} ) ) {
           if( $self->connect( $addr ) ) {
              $! = 0;
              return 1;
           }
  
           if( $! == EINPROGRESS or $! == EWOULDBLOCK ) {
              ${*$self}{io_socket_ip_connect_in_progress} = 1;
              return 0;
           }
  
           # If connect failed but we have no system error there must be an error
           # at the application layer, like a bad certificate with
           # IO::Socket::SSL.
           # In this case don't continue IP based multi-homing because the problem
           # cannot be solved at the IP layer.
           return 0 if ! $!;
  
           ${*$self}{io_socket_ip_errors}[0] = $!;
           next;
        }
  
        return 1;
     }
  
     # Pick the most appropriate error, stringified
     $! = ( grep defined, @{ ${*$self}{io_socket_ip_errors}} )[0];
     $@ = "$!";
     return undef;
  }
  
  sub connect :method
  {
     my $self = shift;
  
     # It seems that IO::Socket hides EINPROGRESS errors, making them look like
     # a success. This is annoying here.
     # Instead of putting up with its frankly-irritating intentional breakage of
     # useful APIs I'm just going to end-run around it and call core's connect()
     # directly
  
     if( @_ ) {
        my ( $addr ) = @_;
  
        # Annoyingly IO::Socket's connect() is where the timeout logic is
        # implemented, so we'll have to reinvent it here
        my $timeout = ${*$self}{'io_socket_timeout'};
  
        return connect( $self, $addr ) unless defined $timeout;
  
        my $was_blocking = $self->blocking( 0 );
  
        my $err = defined connect( $self, $addr ) ? 0 : $!+0;
  
        if( !$err ) {
           # All happy
           $self->blocking( $was_blocking );
           return 1;
        }
        elsif( not( $err == EINPROGRESS or $err == EWOULDBLOCK ) ) {
           # Failed for some other reason
           $self->blocking( $was_blocking );
           return undef;
        }
        elsif( !$was_blocking ) {
           # We shouldn't block anyway
           return undef;
        }
  
        my $vec = ''; vec( $vec, $self->fileno, 1 ) = 1;
        if( !select( undef, $vec, $vec, $timeout ) ) {
           $self->blocking( $was_blocking );
           $! = ETIMEDOUT;
           return undef;
        }
  
        # Hoist the error by connect()ing a second time
        $err = $self->getsockopt( SOL_SOCKET, SO_ERROR );
        $err = 0 if $err == EISCONN; # Some OSes give EISCONN
  
        $self->blocking( $was_blocking );
  
        $! = $err, return undef if $err;
        return 1;
     }
  
     return 1 if !${*$self}{io_socket_ip_connect_in_progress};
  
     # See if a connect attempt has just failed with an error
     if( my $errno = $self->getsockopt( SOL_SOCKET, SO_ERROR ) ) {
        delete ${*$self}{io_socket_ip_connect_in_progress};
        ${*$self}{io_socket_ip_errors}[0] = $! = $errno;
        return $self->setup;
     }
  
     # No error, so either connect is still in progress, or has completed
     # successfully. We can tell by trying to connect() again; either it will
     # succeed or we'll get EISCONN (connected successfully), or EALREADY
     # (still in progress). This even works on MSWin32.
     my $addr = ${*$self}{io_socket_ip_infos}[${*$self}{io_socket_ip_idx}]{peeraddr};
  
     if( connect( $self, $addr ) or $! == EISCONN ) {
        delete ${*$self}{io_socket_ip_connect_in_progress};
        $! = 0;
        return 1;
     }
     else {
        $! = EINPROGRESS;
        return 0;
     }
  }
  
  sub connected
  {
     my $self = shift;
     return defined $self->fileno &&
            !${*$self}{io_socket_ip_connect_in_progress} &&
            defined getpeername( $self ); # ->peername caches, we need to detect disconnection
  }
  
  =head1 METHODS
  
  As well as the following methods, this class inherits all the methods in
  L<IO::Socket> and L<IO::Handle>.
  
  =cut
  
  sub _get_host_service
  {
     my $self = shift;
     my ( $addr, $flags, $xflags ) = @_;
  
     defined $addr or
        $! = ENOTCONN, return;
  
     $flags |= NI_DGRAM if $self->socktype == SOCK_DGRAM;
  
     my ( $err, $host, $service ) = getnameinfo( $addr, $flags, $xflags || 0 );
     croak "getnameinfo - $err" if $err;
  
     return ( $host, $service );
  }
  
  sub _unpack_sockaddr
  {
     my ( $addr ) = @_;
     my $family = sockaddr_family $addr;
  
     if( $family == AF_INET ) {
        return ( Socket::unpack_sockaddr_in( $addr ) )[1];
     }
     elsif( defined $AF_INET6 and $family == $AF_INET6 ) {
        return ( Socket::unpack_sockaddr_in6( $addr ) )[1];
     }
     else {
        croak "Unrecognised address family $family";
     }
  }
  
  =head2 sockhost_service
  
     ( $host, $service ) = $sock->sockhost_service( $numeric )
  
  Returns the hostname and service name of the local address (that is, the
  socket address given by the C<sockname> method).
  
  If C<$numeric> is true, these will be given in numeric form rather than being
  resolved into names.
  
  The following four convenience wrappers may be used to obtain one of the two
  values returned here. If both host and service names are required, this method
  is preferable to the following wrappers, because it will call
  C<getnameinfo(3)> only once.
  
  =cut
  
  sub sockhost_service
  {
     my $self = shift;
     my ( $numeric ) = @_;
  
     $self->_get_host_service( $self->sockname, $numeric ? NI_NUMERICHOST|NI_NUMERICSERV : 0 );
  }
  
  =head2 sockhost
  
     $addr = $sock->sockhost
  
  Return the numeric form of the local address as a textual representation
  
  =head2 sockport
  
     $port = $sock->sockport
  
  Return the numeric form of the local port number
  
  =head2 sockhostname
  
     $host = $sock->sockhostname
  
  Return the resolved name of the local address
  
  =head2 sockservice
  
     $service = $sock->sockservice
  
  Return the resolved name of the local port number
  
  =cut
  
  sub sockhost { my $self = shift; scalar +( $self->_get_host_service( $self->sockname, NI_NUMERICHOST, NIx_NOSERV ) )[0] }
  sub sockport { my $self = shift; scalar +( $self->_get_host_service( $self->sockname, NI_NUMERICSERV, NIx_NOHOST ) )[1] }
  
  sub sockhostname { my $self = shift; scalar +( $self->_get_host_service( $self->sockname, 0, NIx_NOSERV ) )[0] }
  sub sockservice  { my $self = shift; scalar +( $self->_get_host_service( $self->sockname, 0, NIx_NOHOST ) )[1] }
  
  =head2 sockaddr
  
     $addr = $sock->sockaddr
  
  Return the local address as a binary octet string
  
  =cut
  
  sub sockaddr { my $self = shift; _unpack_sockaddr $self->sockname }
  
  =head2 peerhost_service
  
     ( $host, $service ) = $sock->peerhost_service( $numeric )
  
  Returns the hostname and service name of the peer address (that is, the
  socket address given by the C<peername> method), similar to the
  C<sockhost_service> method.
  
  The following four convenience wrappers may be used to obtain one of the two
  values returned here. If both host and service names are required, this method
  is preferable to the following wrappers, because it will call
  C<getnameinfo(3)> only once.
  
  =cut
  
  sub peerhost_service
  {
     my $self = shift;
     my ( $numeric ) = @_;
  
     $self->_get_host_service( $self->peername, $numeric ? NI_NUMERICHOST|NI_NUMERICSERV : 0 );
  }
  
  =head2 peerhost
  
     $addr = $sock->peerhost
  
  Return the numeric form of the peer address as a textual representation
  
  =head2 peerport
  
     $port = $sock->peerport
  
  Return the numeric form of the peer port number
  
  =head2 peerhostname
  
     $host = $sock->peerhostname
  
  Return the resolved name of the peer address
  
  =head2 peerservice
  
     $service = $sock->peerservice
  
  Return the resolved name of the peer port number
  
  =cut
  
  sub peerhost { my $self = shift; scalar +( $self->_get_host_service( $self->peername, NI_NUMERICHOST, NIx_NOSERV ) )[0] }
  sub peerport { my $self = shift; scalar +( $self->_get_host_service( $self->peername, NI_NUMERICSERV, NIx_NOHOST ) )[1] }
  
  sub peerhostname { my $self = shift; scalar +( $self->_get_host_service( $self->peername, 0, NIx_NOSERV ) )[0] }
  sub peerservice  { my $self = shift; scalar +( $self->_get_host_service( $self->peername, 0, NIx_NOHOST ) )[1] }
  
  =head2 peeraddr
  
     $addr = $peer->peeraddr
  
  Return the peer address as a binary octet string
  
  =cut
  
  sub peeraddr { my $self = shift; _unpack_sockaddr $self->peername }
  
  # This unbelievably dodgy hack works around the bug that IO::Socket doesn't do
  # it
  #    https://rt.cpan.org/Ticket/Display.html?id=61577
  sub accept
  {
     my $self = shift;
     my ( $new, $peer ) = $self->SUPER::accept( @_ ) or return;
  
     ${*$new}{$_} = ${*$self}{$_} for qw( io_socket_domain io_socket_type io_socket_proto );
  
     return wantarray ? ( $new, $peer )
                      : $new;
  }
  
  # This second unbelievably dodgy hack guarantees that $self->fileno doesn't
  # change, which is useful during nonblocking connect
  sub socket :method
  {
     my $self = shift;
     return $self->SUPER::socket(@_) if not defined $self->fileno;
  
     # I hate core prototypes sometimes...
     socket( my $tmph, $_[0], $_[1], $_[2] ) or return undef;
  
     dup2( $tmph->fileno, $self->fileno ) or die "Unable to dup2 $tmph onto $self - $!";
  }
  
  # Versions of IO::Socket before 1.35 may leave socktype undef if from, say, an
  #   ->fdopen call. In this case we'll apply a fix
  BEGIN {
     if( eval($IO::Socket::VERSION) < 1.35 ) {
        *socktype = sub {
           my $self = shift;
           my $type = $self->SUPER::socktype;
           if( !defined $type ) {
              $type = $self->sockopt( Socket::SO_TYPE() );
           }
           return $type;
        };
     }
  }
  
  =head2 as_inet
  
     $inet = $sock->as_inet
  
  Returns a new L<IO::Socket::INET> instance wrapping the same filehandle. This
  may be useful in cases where it is required, for backward-compatibility, to
  have a real object of C<IO::Socket::INET> type instead of C<IO::Socket::IP>.
  The new object will wrap the same underlying socket filehandle as the
  original, so care should be taken not to continue to use both objects
  concurrently. Ideally the original C<$sock> should be discarded after this
  method is called.
  
  This method checks that the socket domain is C<PF_INET> and will throw an
  exception if it isn't.
  
  =cut
  
  sub as_inet
  {
     my $self = shift;
     croak "Cannot downgrade a non-PF_INET socket to IO::Socket::INET" unless $self->sockdomain == AF_INET;
     return IO::Socket::INET->new_from_fd( $self->fileno, "r+" );
  }
  
  =head1 NON-BLOCKING
  
  If the constructor is passed a defined but false value for the C<Blocking>
  argument then the socket is put into non-blocking mode. When in non-blocking
  mode, the socket will not be set up by the time the constructor returns,
  because the underlying C<connect(2)> syscall would otherwise have to block.
  
  The non-blocking behaviour is an extension of the C<IO::Socket::INET> API,
  unique to C<IO::Socket::IP>, because the former does not support multi-homed
  non-blocking connect.
  
  When using non-blocking mode, the caller must repeatedly check for
  writeability on the filehandle (for instance using C<select> or C<IO::Poll>).
  Each time the filehandle is ready to write, the C<connect> method must be
  called, with no arguments. Note that some operating systems, most notably
  C<MSWin32> do not report a C<connect()> failure using write-ready; so you must
  also C<select()> for exceptional status.
  
  While C<connect> returns false, the value of C<$!> indicates whether it should
  be tried again (by being set to the value C<EINPROGRESS>, or C<EWOULDBLOCK> on
  MSWin32), or whether a permanent error has occurred (e.g. C<ECONNREFUSED>).
  
  Once the socket has been connected to the peer, C<connect> will return true
  and the socket will now be ready to use.
  
  Note that calls to the platform's underlying C<getaddrinfo(3)> function may
  block. If C<IO::Socket::IP> has to perform this lookup, the constructor will
  block even when in non-blocking mode.
  
  To avoid this blocking behaviour, the caller should pass in the result of such
  a lookup using the C<PeerAddrInfo> or C<LocalAddrInfo> arguments. This can be
  achieved by using L<Net::LibAsyncNS>, or the C<getaddrinfo(3)> function can be
  called in a child process.
  
   use IO::Socket::IP;
   use Errno qw( EINPROGRESS EWOULDBLOCK );
  
   my @peeraddrinfo = ... # Caller must obtain the getaddinfo result here
  
   my $socket = IO::Socket::IP->new(
      PeerAddrInfo => \@peeraddrinfo,
      Blocking     => 0,
   ) or die "Cannot construct socket - $@";
  
   while( !$socket->connect and ( $! == EINPROGRESS || $! == EWOULDBLOCK ) ) {
      my $wvec = '';
      vec( $wvec, fileno $socket, 1 ) = 1;
      my $evec = '';
      vec( $evec, fileno $socket, 1 ) = 1;
  
      select( undef, $wvec, $evec, undef ) or die "Cannot select - $!";
   }
  
   die "Cannot connect - $!" if $!;
  
   ...
  
  The example above uses C<select()>, but any similar mechanism should work
  analogously. C<IO::Socket::IP> takes care when creating new socket filehandles
  to preserve the actual file descriptor number, so such techniques as C<poll>
  or C<epoll> should be transparent to its reallocation of a different socket
  underneath, perhaps in order to switch protocol family between C<PF_INET> and
  C<PF_INET6>.
  
  For another example using C<IO::Poll> and C<Net::LibAsyncNS>, see the
  F<examples/nonblocking_libasyncns.pl> file in the module distribution.
  
  =cut
  
  =head1 C<PeerHost> AND C<LocalHost> PARSING
  
  To support the C<IO::Socket::INET> API, the host and port information may be
  passed in a single string rather than as two separate arguments.
  
  If either C<LocalHost> or C<PeerHost> (or their C<...Addr> synonyms) have any
  of the following special forms then special parsing is applied.
  
  The value of the C<...Host> argument will be split to give both the hostname
  and port (or service name):
  
   hostname.example.org:http    # Host name
   192.0.2.1:80                 # IPv4 address
   [2001:db8::1]:80             # IPv6 address
  
  In each case, the port or service name (e.g. C<80>) is passed as the
  C<LocalService> or C<PeerService> argument.
  
  Either of C<LocalService> or C<PeerService> (or their C<...Port> synonyms) can
  be either a service name, a decimal number, or a string containing both a
  service name and number, in a form such as
  
   http(80)
  
  In this case, the name (C<http>) will be tried first, but if the resolver does
  not understand it then the port number (C<80>) will be used instead.
  
  If the C<...Host> argument is in this special form and the corresponding
  C<...Service> or C<...Port> argument is also defined, the one parsed from
  the C<...Host> argument will take precedence and the other will be ignored.
  
  =head2 split_addr
  
     ( $host, $port ) = IO::Socket::IP->split_addr( $addr )
  
  Utility method that provides the parsing functionality described above.
  Returns a 2-element list, containing either the split hostname and port
  description if it could be parsed, or the given address and C<undef> if it was
  not recognised.
  
   IO::Socket::IP->split_addr( "hostname:http" )
                                # ( "hostname",  "http" )
  
   IO::Socket::IP->split_addr( "192.0.2.1:80" )
                                # ( "192.0.2.1", "80"   )
  
   IO::Socket::IP->split_addr( "[2001:db8::1]:80" )
                                # ( "2001:db8::1", "80" )
  
   IO::Socket::IP->split_addr( "something.else" )
                                # ( "something.else", undef )
  
  =cut
  
  sub split_addr
  {
     shift;
     my ( $addr ) = @_;
  
     local ( $1, $2 ); # Placate a taint-related bug; [perl #67962]
     if( $addr =~ m/\A\[($IPv6_re)\](?::([^\s:]*))?\z/ or
         $addr =~ m/\A([^\s:]*):([^\s:]*)\z/ ) {
        return ( $1, $2 ) if defined $2 and length $2;
        return ( $1, undef );
     }
  
     return ( $addr, undef );
  }
  
  =head2 join_addr
  
     $addr = IO::Socket::IP->join_addr( $host, $port )
  
  Utility method that performs the reverse of C<split_addr>, returning a string
  formed by joining the specified host address and port number. The host address
  will be wrapped in C<[]> brackets if required (because it is a raw IPv6
  numeric address).
  
  This can be especially useful when combined with the C<sockhost_service> or
  C<peerhost_service> methods.
  
   say "Connected to ", IO::Socket::IP->join_addr( $sock->peerhost_service );
  
  =cut
  
  sub join_addr
  {
     shift;
     my ( $host, $port ) = @_;
  
     $host = "[$host]" if $host =~ m/:/;
  
     return join ":", $host, $port if defined $port;
     return $host;
  }
  
  # Since IO::Socket->new( Domain => ... ) will delete the Domain parameter
  # before calling ->configure, we need to keep track of which it was
  
  package # hide from indexer
     IO::Socket::IP::_ForINET;
  use base qw( IO::Socket::IP );
  
  sub configure
  {
     # This is evil
     my $self = shift;
     my ( $arg ) = @_;
  
     bless $self, "IO::Socket::IP";
     $self->configure( { %$arg, Family => Socket::AF_INET() } );
  }
  
  package # hide from indexer
     IO::Socket::IP::_ForINET6;
  use base qw( IO::Socket::IP );
  
  sub configure
  {
     # This is evil
     my $self = shift;
     my ( $arg ) = @_;
  
     bless $self, "IO::Socket::IP";
     $self->configure( { %$arg, Family => Socket::AF_INET6() } );
  }
  
  =head1 C<IO::Socket::INET> INCOMPATIBILITES
  
  =over 4
  
  =item *
  
  The behaviour enabled by C<MultiHomed> is in fact implemented by
  C<IO::Socket::IP> as it is required to correctly support searching for a
  useable address from the results of the C<getaddrinfo(3)> call. The
  constructor will ignore the value of this argument, except if it is defined
  but false. An exception is thrown in this case, because that would request it
  disable the C<getaddrinfo(3)> search behaviour in the first place.
  
  =item *
  
  C<IO::Socket::IP> implements both the C<Blocking> and C<Timeout> parameters,
  but it implements the interaction of both in a different way.
  
  In C<::INET>, supplying a timeout overrides the non-blocking behaviour,
  meaning that the C<connect()> operation will still block despite that the
  caller asked for a non-blocking socket. This is not explicitly specified in
  its documentation, nor does this author believe that is a useful behaviour -
  it appears to come from a quirk of implementation.
  
  In C<::IP> therefore, the C<Blocking> parameter takes precedence - if a
  non-blocking socket is requested, no operation will block. The C<Timeout>
  parameter here simply defines the maximum time that a blocking C<connect()>
  call will wait, if it blocks at all.
  
  In order to specifically obtain the "blocking connect then non-blocking send
  and receive" behaviour of specifying this combination of options to C<::INET>
  when using C<::IP>, perform first a blocking connect, then afterwards turn the
  socket into nonblocking mode.
  
   my $sock = IO::Socket::IP->new(
      PeerHost => $peer,
      Timeout => 20,
   ) or die "Cannot connect - $@";
  
   $sock->blocking( 0 );
  
  This code will behave identically under both C<IO::Socket::INET> and
  C<IO::Socket::IP>.
  
  =back
  
  =cut
  
  =head1 TODO
  
  =over 4
  
  =item *
  
  Investigate whether C<POSIX::dup2> upsets BSD's C<kqueue> watchers, and if so,
  consider what possible workarounds might be applied.
  
  =back
  
  =head1 AUTHOR
  
  Paul Evans <leonerd@leonerd.org.uk>
  
  =cut
  
  0x55AA;
IO_SOCKET_IP

    $fatpacked{"JSON/MaybeXS.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'JSON_MAYBEXS';
  package JSON::MaybeXS;
  
  use strict;
  use warnings FATAL => 'all';
  use base qw(Exporter);
  
  our $VERSION = '1.004005';
  $VERSION =~ tr/_//d;
  
  sub _choose_json_module {
      return 'Cpanel::JSON::XS' if $INC{'Cpanel/JSON/XS.pm'};
      return 'JSON::XS'         if $INC{'JSON/XS.pm'} && eval { JSON::XS->VERSION(3.0); 1 };
  
      my @err;
  
      return 'Cpanel::JSON::XS' if eval { require Cpanel::JSON::XS; 1; };
      push @err, "Error loading Cpanel::JSON::XS: $@";
  
      return 'JSON::XS' if eval { require JSON::XS; JSON::XS->VERSION(3.0); 1; };
      push @err, "Error loading JSON::XS: $@";
  
      return 'JSON::PP' if eval { require JSON::PP; 1 };
      push @err, "Error loading JSON::PP: $@";
  
      die join( "\n", "Couldn't load a JSON module:", @err );
  
  }
  
  BEGIN {
      our $JSON_Class = _choose_json_module();
      $JSON_Class->import(qw(encode_json decode_json));
      no strict 'refs';
      *$_ = $JSON_Class->can($_)
        for qw(true false);
  }
  
  our @EXPORT = qw(encode_json decode_json JSON);
  my @EXPORT_ALL = qw(is_bool);
  our @EXPORT_OK = qw(is_bool to_json from_json);
  our %EXPORT_TAGS = ( all => [ @EXPORT, @EXPORT_ALL ],
                       legacy => [ @EXPORT, @EXPORT_OK ],
                     );
  
  sub JSON () { our $JSON_Class }
  
  sub new {
    shift;
    my %args = @_ == 1 ? %{$_[0]} : @_;
    my $new = (our $JSON_Class)->new;
    $new->$_($args{$_}) for keys %args;
    return $new;
  }
  
  use Scalar::Util ();
  
  sub is_bool {
    die 'is_bool is not a method' if $_[1];
  
    Scalar::Util::blessed($_[0])
      and ($_[0]->isa('JSON::PP::Boolean')
        or $_[0]->isa('Cpanel::JSON::XS::Boolean')
        or $_[0]->isa('JSON::XS::Boolean'));
  }
  
  # (mostly) CopyPasta from JSON.pm version 2.90
  use Carp ();
  
  sub from_json ($@) {
      if ( ref($_[0]) =~ /^JSON/ or $_[0] =~ /^JSON/ ) {
          Carp::croak "from_json should not be called as a method.";
      }
      my $json = JSON()->new;
  
      if (@_ == 2 and ref $_[1] eq 'HASH') {
          my $opt  = $_[1];
          for my $method (keys %$opt) {
              $json->$method( $opt->{$method} );
          }
      }
  
      return $json->decode( $_[0] );
  }
  
  sub to_json ($@) {
      if (
          ref($_[0]) =~ /^JSON/
          or (@_ > 2 and $_[0] =~ /^JSON/)
            ) {
                 Carp::croak "to_json should not be called as a method.";
      }
      my $json = JSON()->new;
  
      if (@_ == 2 and ref $_[1] eq 'HASH') {
          my $opt  = $_[1];
          for my $method (keys %$opt) {
              $json->$method( $opt->{$method} );
          }
      }
  
      $json->encode($_[0]);
  }
  
  1;
  
  =head1 NAME
  
  JSON::MaybeXS - Use L<Cpanel::JSON::XS> with a fallback to L<JSON::XS> and L<JSON::PP>
  
  =head1 SYNOPSIS
  
    use JSON::MaybeXS;
  
    my $data_structure = decode_json($json_input);
  
    my $json_output = encode_json($data_structure);
  
    my $json = JSON()->new;
  
    my $json_with_args = JSON::MaybeXS->new(utf8 => 1); # or { utf8 => 1 }
  
  =head1 DESCRIPTION
  
  This module first checks to see if either L<Cpanel::JSON::XS> or
  L<JSON::XS> (at at least version 3.0)
  is already loaded, in which case it uses that module. Otherwise
  it tries to load L<Cpanel::JSON::XS>, then L<JSON::XS>, then L<JSON::PP>
  in order, and either uses the first module it finds or throws an error.
  
  It then exports the C<encode_json> and C<decode_json> functions from the
  loaded module, along with a C<JSON> constant that returns the class name
  for calling C<new> on.
  
  If you're writing fresh code rather than replacing L<JSON.pm|JSON> usage, you might
  want to pass options as constructor args rather than calling mutators, so
  we provide our own C<new> method that supports that.
  
  =head1 EXPORTS
  
  C<encode_json>, C<decode_json> and C<JSON> are exported by default; C<is_bool>
  is exported on request.
  
  To import only some symbols, specify them on the C<use> line:
  
    use JSON::MaybeXS qw(encode_json decode_json is_bool); # functions only
  
    use JSON::MaybeXS qw(JSON); # JSON constant only
  
  To import all available sensible symbols (C<encode_json>, C<decode_json>, and
  C<is_bool>), use C<:all>:
  
    use JSON::MaybeXS ':all';
  
  To import all symbols including those needed by legacy apps that use L<JSON::PP>:
  
    use JSON::MaybeXS ':legacy';
  
  This imports the C<to_json> and C<from_json> symbols as well as everything in
  C<:all>.  NOTE: This is to support legacy code that makes extensive
  use of C<to_json> and C<from_json> which you are not yet in a position to
  refactor.  DO NOT use this import tag in new code, in order to avoid
  the crawling horrors of getting UTF-8 support subtly wrong.  See the
  documentation for L<JSON> for further details.
  
  =head2 encode_json
  
  This is the C<encode_json> function provided by the selected implementation
  module, and takes a perl data structure which is serialised to JSON text.
  
    my $json_text = encode_json($data_structure);
  
  =head2 decode_json
  
  This is the C<decode_json> function provided by the selected implementation
  module, and takes a string of JSON text to deserialise to a perl data structure.
  
    my $data_structure = decode_json($json_text);
  
  =head2 to_json
  
  This function is equivalent to calling C<< JSON()->new->encode($data_structure) >>.
  It takes a perl data structure which is serialised to JSON text without encoding
  it to UTF-8. You should only use this function if you expect another layer to
  handle the UTF-8 encoding of the resulting JSON text.
  
    my $json_text = to_json($data_structure);
  
  Additional arguments can be passed and will be handled as in L<JSON/to_json>,
  this is included to support legacy code B<only>.
  
  =head2 from_json
  
  This function is equivalent to calling C<< JSON()->new->decode($json_text) >>. It
  takes a string of unencoded JSON text to deserialise to a perl data structure. You
  should only use this function if another layer is already handling the UTF-8
  decoding of the input JSON text.
  
    my $data_structure = from_json($json_text);
  
  Additional arguments can be passed and will be handled as in L<JSON/from_json>,
  this is included to support legacy code B<only>.
  
  =head2 JSON
  
  The C<JSON> constant returns the selected implementation module's name for
  use as a class name - so:
  
    my $json_obj = JSON()->new; # returns a Cpanel::JSON::XS or JSON::PP object
  
  and that object can then be used normally:
  
    my $data_structure = $json_obj->decode($json_text); # etc.
  
  The use of parentheses here is optional, and only used as a hint to the reader
  that this use of C<JSON> is a I<subroutine> call, I<not> a class name.
  
  =head2 is_bool
  
    $is_boolean = is_bool($scalar)
  
  Returns true if the passed scalar represents either C<true> or
  C<false>, two constants that act like C<1> and C<0>, respectively
  and are used to represent JSON C<true> and C<false> values in Perl.
  
  Since this is a bare sub in the various backend classes, it cannot be called as
  a class method like the other interfaces; it must be called as a function, with
  no invocant.  It supports the representation used in all JSON backends.
  
  Available since version 1.002004.
  
  =head1 CONSTRUCTOR
  
  =head2 new
  
  With L<JSON::PP>, L<JSON::XS> and L<Cpanel::JSON::XS> you are required to call
  mutators to set options, such as:
  
    my $json = $class->new->utf8(1)->pretty(1);
  
  Since this is a trifle irritating and noticeably un-perlish, we also offer:
  
    my $json = JSON::MaybeXS->new(utf8 => 1, pretty => 1);
  
  which works equivalently to the above (and in the usual tradition will accept
  a hashref instead of a hash, should you so desire).
  
  The resulting object is blessed into the underlying backend, which offers (at
  least) the methods C<encode> and C<decode>.
  
  =head1 BOOLEANS
  
  To include JSON-aware booleans (C<true>, C<false>) in your data, just do:
  
      use JSON::MaybeXS;
      my $true = JSON()->true;
      my $false = JSON()->false;
  
  The booleans are also available as subs or methods on JSON::MaybeXS.
  
      use JSON::MaybeXS ();
      my $true = JSON::MaybeXS::true;
      my $true = JSON::MaybeXS->true;
      my $false = JSON::MaybeXS::false;
      my $false = JSON::MaybeXS->false;
  
  =head1 CONVERTING FROM JSON::Any
  
  L<JSON::Any> used to be the favoured compatibility layer above the various
  JSON backends, but over time has grown a lot of extra code to deal with legacy
  backends (e.g. L<JSON::Syck>) that are no longer needed.  This is a rough guide of translating such code:
  
  Change code from:
  
      use JSON::Any;
      my $json = JSON::Any->new->objToJson($data);    # or to_json($data), or Dump($data)
  
  to:
  
      use JSON::MaybeXS;
      my $json = encode_json($data);
  
  
  Change code from:
  
      use JSON::Any;
      my $data = JSON::Any->new->jsonToObj($json);    # or from_json($json), or Load($json)
  
  to:
  
      use JSON::MaybeXS;
      my $json = decode_json($data);
  
  =head1 CAVEATS
  
  The C<new()> method in this module is technically a factory, not a
  constructor, because the objects it returns will I<NOT> be blessed into the
  C<JSON::MaybeXS> class.
  
  If you are using an object returned by this module as a Moo(se) attribute,
  this type constraint code:
  
      is 'json' => ( isa => 'JSON::MaybeXS' );
  
  will I<NOT> do what you expect. Instead, either rely on the C<JSON> class
  constant described above, as so:
  
      is 'json' => ( isa => JSON::MaybeXS::JSON() );
  
  Alternatively, you can use duck typing:
  
      use Moose::Util::TypeConstraints 'duck_type';
      is 'json' => ( isa => Object , duck_type([qw/ encode decode /]));
  
  =head1 INSTALLATION
  
  At installation time, F<Makefile.PL> will attempt to determine if you have a
  working compiler available, and therefore whether you are able to run XS code.
  If so, L<Cpanel::JSON::XS> will be added to the prerequisite list, unless
  L<JSON::XS> is already installed at a high enough version. L<JSON::XS> may
  also be upgraded to fix any incompatibility issues.
  
  Because running XS code is not mandatory and L<JSON::PP> (which is in perl
  core) is used as a fallback backend, this module is safe to be used in a suite
  of code that is fatpacked or installed into a restricted-resource environment.
  
  You can also prevent any XS dependencies from being installed by setting
  C<PUREPERL_ONLY=1> in F<Makefile.PL> options (or in the C<PERL_MM_OPT>
  environment variable), or using the C<--pp> or C<--pureperl> flags with the
  L<cpanminus client|cpanm>.
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  =over 4
  
  =item * Clinton Gormley <drtech@cpan.org>
  
  =item * Karen Etheridge <ether@cpan.org>
  
  =item * Kieren Diment <diment@gmail.com>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2013 the C<JSON::MaybeXS> L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
JSON_MAYBEXS

    $fatpacked{"Module/Load.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'MODULE_LOAD';
  package Module::Load;
  
  use strict;
  use warnings;
  use File::Spec ();
  
  our $VERSION = '0.36';
  
  
  sub import {
      my $who = _who();
      my $h; shift;
  
      {   no strict 'refs';
  
          @_ or (
              *{"${who}::load"} = \&load, # compat to prev version
              *{"${who}::autoload"} = \&autoload,
              return
          );
  
          map { $h->{$_} = () if defined $_ } @_;
  
          (exists $h->{none} or exists $h->{''})
              and shift, last;
  
          ((exists $h->{autoload} and shift,1) or (exists $h->{all} and shift))
              and *{"${who}::autoload"} = \&autoload;
  
          ((exists $h->{load} and shift,1) or exists $h->{all})
              and *{"${who}::load"} = \&load;
  
          ((exists $h->{load_remote} and shift,1) or exists $h->{all})
              and *{"${who}::load_remote"} = \&load_remote;
  
          ((exists $h->{autoload_remote} and shift,1) or exists $h->{all})
              and *{"${who}::autoload_remote"} = \&autoload_remote;
  
      }
  
  }
  
  sub load(*;@){
      goto &_load;
  }
  
  sub autoload(*;@){
      unshift @_, 'autoimport';
      goto &_load;
  }
  
  sub load_remote($$;@){
      my ($dst, $src, @exp) = @_;
  
      eval "package $dst;Module::Load::load('$src', qw/@exp/);";
      $@ && die "$@";
  }
  
  sub autoload_remote($$;@){
      my ($dst, $src, @exp) = @_;
  
      eval "package $dst;Module::Load::autoload('$src', qw/@exp/);";
      $@ && die "$@";
  }
  
  sub _load{
      my $autoimport = $_[0] eq 'autoimport' and shift;
      my $mod = shift or return;
      my $who = _who();
  
      if( _is_file( $mod ) ) {
          require $mod;
      } else {
          LOAD: {
              my $err;
              for my $flag ( qw[1 0] ) {
                  my $file = _to_file( $mod, $flag);
                  eval { require $file };
                  $@ ? $err .= $@ : last LOAD;
              }
              die $err if $err;
          }
      }
  
      ### This addresses #41883: Module::Load cannot import
      ### non-Exporter module. ->import() routines weren't
      ### properly called when load() was used.
  
      {   no strict 'refs';
          my $import;
  
      ((@_ or $autoimport) and (
          $import = $mod->can('import')
          ) and (
          unshift(@_, $mod),
          goto &$import
          )
      );
      }
  
  }
  
  sub _to_file{
      local $_    = shift;
      my $pm      = shift || '';
  
      ## trailing blanks ignored by default. [rt #69886]
      my @parts = split /::|'/, $_, -1;
      ## make sure that we can't hop out of @INC
      shift @parts if @parts && !$parts[0];
  
      ### because of [perl #19213], see caveats ###
      my $file = $^O eq 'MSWin32'
                      ? join "/", @parts
                      : File::Spec->catfile( @parts );
  
      $file   .= '.pm' if $pm;
  
      ### on perl's before 5.10 (5.9.5@31746) if you require
      ### a file in VMS format, it's stored in %INC in VMS
      ### format. Therefor, better unixify it first
      ### Patch in reply to John Malmbergs patch (as mentioned
      ### above) on p5p Tue 21 Aug 2007 04:55:07
      $file = VMS::Filespec::unixify($file) if $^O eq 'VMS';
  
      return $file;
  }
  
  sub _who { (caller(1))[0] }
  
  sub _is_file {
      local $_ = shift;
      return  /^\./               ? 1 :
              /[^\w:']/           ? 1 :
              undef
      #' silly bbedit..
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Module::Load - runtime require of both modules and files
  
  =head1 SYNOPSIS
  
    use Module::Load;
  
    my $module = 'Data::Dumper';
  
    load Data::Dumper;     # loads that module, but not import any functions
                           # -> cannot use 'Dumper' function
  
    load 'Data::Dumper';   # ditto
    load $module           # tritto
  
    autoload Data::Dumper; # loads that module and imports the default functions
                           # -> can use 'Dumper' function
  
    my $script = 'some/script.pl'
    load $script;
    load 'some/script.pl';  # use quotes because of punctuations
  
    load thing;             # try 'thing' first, then 'thing.pm'
  
    load CGI, ':all';       # like 'use CGI qw[:standard]'
  
  =head1 DESCRIPTION
  
  C<Module::Load> eliminates the need to know whether you are trying
  to require either a file or a module.
  
  If you consult C<perldoc -f require> you will see that C<require> will
  behave differently when given a bareword or a string.
  
  In the case of a string, C<require> assumes you are wanting to load a
  file. But in the case of a bareword, it assumes you mean a module.
  
  This gives nasty overhead when you are trying to dynamically require
  modules at runtime, since you will need to change the module notation
  (C<Acme::Comment>) to a file notation fitting the particular platform
  you are on.
  
  C<Module::Load> eliminates the need for this overhead and will
  just DWYM.
  
  =head2 Difference between C<load> and C<autoload>
  
  C<Module::Load> imports the two functions - C<load> and C<autoload>
  
  C<autoload> imports the default functions automatically,
  but C<load> do not import any functions.
  
  C<autoload> is usable under C<BEGIN{};>.
  
  Both the functions can import the functions that are specified.
  
  Following codes are same.
  
    load File::Spec::Functions, qw/splitpath/;
  
    autoload File::Spec::Functions, qw/splitpath/;
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item load
  
  Loads a specified module.
  
  See L</Rules> for detailed loading rule.
  
  =item autoload
  
  Loads a specified module and imports the default functions.
  
  Except importing the functions, 'autoload' is same as 'load'.
  
  =item load_remote
  
  Loads a specified module to the specified package.
  
    use Module::Load 'load_remote';
  
    my $pkg = 'Other::Package';
  
    load_remote $pkg, 'Data::Dumper'; # load a module to 'Other::Package'
                                      # but do not import 'Dumper' function
  
  A module for loading must be quoted.
  
  Except specifing the package and quoting module name,
  'load_remote' is same as 'load'.
  
  =item autoload_remote
  
  Loads a specified module and imports the default functions to the specified package.
  
    use Module::Load 'autoload_remote';
  
    my $pkg = 'Other::Package';
  
    autoload_remote $pkg, 'Data::Dumper'; # load a module to 'Other::Package'
                                          # and imports 'Dumper' function
  
  A module for loading must be quoted.
  
  Except specifing the package and quoting module name,
  'autoload_remote' is same as 'load_remote'.
  
  =back
  
  =head1 Rules
  
  All functions have the following rules to decide what it thinks
  you want:
  
  =over 4
  
  =item *
  
  If the argument has any characters in it other than those matching
  C<\w>, C<:> or C<'>, it must be a file
  
  =item *
  
  If the argument matches only C<[\w:']>, it must be a module
  
  =item *
  
  If the argument matches only C<\w>, it could either be a module or a
  file. We will try to find C<file.pm> first in C<@INC> and if that
  fails, we will try to find C<file> in @INC.  If both fail, we die with
  the respective error messages.
  
  =back
  
  =head1 IMPORTS THE FUNCTIONS
  
  'load' and 'autoload' are imported by default, but 'load_remote' and
  'autoload_remote' are not imported.
  
  To use 'load_remote' or 'autoload_remote', specify at 'use'.
  
  =over 4
  
  =item "load","autoload","load_remote","autoload_remote"
  
  Imports the selected functions.
  
    # imports 'load' and 'autoload' (default)
    use Module::Load;
  
    # imports 'autoload' only
    use Module::Load 'autoload';
  
    # imports 'autoload' and 'autoload_remote', but don't import 'load';
    use Module::Load qw/autoload autoload_remote/;
  
  =item 'all'
  
  Imports all the functions.
  
    use Module::Load 'all'; # imports load, autoload, load_remote, autoload_remote
  
  =item '','none',undef
  
  Not import any functions (C<load> and C<autoload> are not imported).
  
    use Module::Load '';
  
    use Module::Load 'none';
  
    use Module::Load undef;
  
  =back
  
  =head1 Caveats
  
  Because of a bug in perl (#19213), at least in version 5.6.1, we have
  to hardcode the path separator for a require on Win32 to be C</>, like
  on Unix rather than the Win32 C<\>. Otherwise perl will not read its
  own %INC accurately double load files if they are required again, or
  in the worst case, core dump.
  
  C<Module::Load> cannot do implicit imports, only explicit imports.
  (in other words, you always have to specify explicitly what you wish
  to import from a module, even if the functions are in that modules'
  C<@EXPORT>)
  
  =head1 SEE ALSO
  
  L<Module::Runtime> provides functions for loading modules,
  checking the validity of a module name,
  converting a module name to partial C<.pm> path,
  and related utility functions.
  
  L<"require" in perlfunc|https://metacpan.org/pod/perlfunc#require>
  and
  L<"use" in perlfunc|https://metacpan.org/pod/perlfunc#use>.
  
  L<Mojo::Loader> is a "class loader and plugin framework",
  and is included in the
  L<Mojolicious|https://metacpan.org/release/Mojolicious> distribution.
  
  L<Module::Loader> is a module for finding and loading modules
  in a given namespace, inspired by C<Mojo::Loader>.
  
  
  =head1 ACKNOWLEDGEMENTS
  
  Thanks to Jonas B. Nielsen for making explicit imports work.
  
  =head1 BUG REPORTS
  
  Please report bugs or other issues to E<lt>bug-module-load@rt.cpan.orgE<gt>.
  
  =head1 AUTHOR
  
  This module by Jos Boumans E<lt>kane@cpan.orgE<gt>.
  
  =head1 COPYRIGHT
  
  This library is free software; you may redistribute and/or modify it
  under the same terms as Perl itself.
  
  =cut
MODULE_LOAD

    $fatpacked{"POSIX/strftime/Compiler.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'POSIX_STRFTIME_COMPILER';
  package POSIX::strftime::Compiler;
  
  use 5.008001;
  use strict;
  use warnings;
  use Carp;
  use Time::Local qw//;
  use POSIX qw//;
  use base qw/Exporter/;
  
  our $VERSION = "0.44";
  our @EXPORT_OK = qw/strftime/;
  
  use constant {
      SEC => 0,
      MIN => 1,
      HOUR => 2,
      DAY => 3,
      MONTH => 4,
      YEAR => 5,
      WDAY => 6,
      YDAY => 7,
      ISDST => 8,
      ISO_WEEK_START_WDAY => 1,  # Monday
      ISO_WEEK1_WDAY      => 4,  # Thursday
      YDAY_MINIMUM        => -366,
  };
  
  BEGIN {
      *tzoffset = \&_tzoffset;
      *tzname = \&_tzname;
  
      if (eval { require Time::TZOffset; 1; }) {
          no warnings 'redefine';
          *tzoffset = \&Time::TZOffset::tzoffset;
      }
  }
  
  
  # copy from POSIX/strftime/GNU/PP.pm and modify
  my @offset2zone = qw(
      -1100       0 SST     -1100       0 SST
      -1000       0 HAST    -0900       1 HADT
      -1000       0 HST     -1000       0 HST
      -0930       0 MART    -0930       0 MART
      -0900       0 AKST    -0800       1 AKDT
      -0900       0 GAMT    -0900       0 GAMT
      -0800       0 PST     -0700       1 PDT
      -0800       0 PST     -0800       0 PST
      -0700       0 MST     -0600       1 MDT
      -0700       0 MST     -0700       0 MST
      -0600       0 CST     -0500       1 CDT
      -0600       0 GALT    -0600       0 GALT
      -0500       0 ECT     -0500       0 ECT
      -0500       0 EST     -0400       1 EDT
      -0500       1 EASST   -0600       0 EAST
      -0430       0 VET     -0430       0 VET
      -0400       0 AMT     -0400       0 AMT
      -0400       0 AST     -0300       1 ADT
      -0330       0 NST     -0230       1 NDT
      -0300       0 ART     -0300       0 ART
      -0300       0 PMST    -0200       1 PMDT
      -0300       1 AMST    -0400       0 AMT
      -0300       1 WARST   -0300       1 WARST
      -0200       0 FNT     -0200       0 FNT
      -0200       1 UYST    -0300       0 UYT
      -0100       0 AZOT    +0000       1 AZOST
      -0100       0 CVT     -0100       0 CVT
      +0000       0 GMT     +0000       0 GMT
      +0000       0 WET     +0100       1 WEST
      +0100       0 CET     +0200       1 CEST
      +0100       0 WAT     +0100       0 WAT
      +0200       0 EET     +0200       0 EET
      +0200       0 IST     +0300       1 IDT
      +0200       1 WAST    +0100       0 WAT
      +0300       0 FET     +0300       0 FET
      +030704     0 zzz     +030704     0 zzz
      +0330       0 IRST    +0430       1 IRDT
      +0400       0 AZT     +0500       1 AZST
      +0400       0 GST     +0400       0 GST
      +0430       0 AFT     +0430       0 AFT
      +0500       0 DAVT    +0700       0 DAVT
      +0500       0 MVT     +0500       0 MVT
      +0530       0 IST     +0530       0 IST
      +0545       0 NPT     +0545       0 NPT
      +0600       0 BDT     +0600       0 BDT
      +0630       0 CCT     +0630       0 CCT
      +0700       0 ICT     +0700       0 ICT
      +0800       0 HKT     +0800       0 HKT
      +0845       0 CWST    +0845       0 CWST
      +0900       0 JST     +0900       0 JST
      +0930       0 CST     +0930       0 CST
      +1000       0 PGT     +1000       0 PGT
      +1030       1 CST     +0930       0 CST
      +1100       0 CAST    +0800       0 WST
      +1100       0 NCT     +1100       0 NCT
      +1100       1 EST     +1000       0 EST
      +1100       1 LHST    +1030       0 LHST
      +1130       0 NFT     +1130       0 NFT
      +1200       0 FJT     +1200       0 FJT
      +1300       0 TKT     +1300       0 TKT
      +1300       1 NZDT    +1200       0 NZST
      +1345       1 CHADT   +1245       0 CHAST
      +1400       0 LINT    +1400       0 LINT
      +1400       1 WSDT    +1300       0 WST
  );
  
  sub _tzoffset {
      my $diff = (exists $ENV{TZ} and $ENV{TZ} =~ m!^(?:GMT|UTC)$!)
               ? 0
               : Time::Local::timegm(@_) - Time::Local::timelocal(@_);
      sprintf '%+03d%02u', $diff/60/60, $diff/60%60;
  }
  
  sub _tzname {
      return $ENV{TZ} if exists $ENV{TZ} and $ENV{TZ} =~ m!^(?:GMT|UTC)$!;
  
      my $diff = tzoffset(@_);
  
      my @t1 = my @t2 = @_;
      @t1[3,4] = (1, 1);  # winter
      my $diff1 = tzoffset(@t1);
      @t2[3,4] = (1, 7);  # summer
      my $diff2 = tzoffset(@t2);
  
      for (my $i=0; $i < @offset2zone; $i += 6) {
          next unless $offset2zone[$i] eq $diff1 and $offset2zone[$i+3] eq $diff2;
          return $diff2 eq $diff ? $offset2zone[$i+5] : $offset2zone[$i+2];
      }
  
      if ($diff =~ /^([+-])(\d\d)$/) {
          return sprintf 'GMT%s%d', $1 eq '-' ? '+' : '-', $2;
      };
  
      return 'Etc';
  }
  
  sub iso_week_days {
      my ($yday, $wday) = @_;
  
      # Add enough to the first operand of % to make it nonnegative.
      my $big_enough_multiple_of_7 = (int(- YDAY_MINIMUM / 7) + 2) * 7;
      return ($yday
          - ($yday - $wday + ISO_WEEK1_WDAY + $big_enough_multiple_of_7) % 7
          + ISO_WEEK1_WDAY - ISO_WEEK_START_WDAY);
  }
  
  sub isleap {
      my $year = shift;
      return ($year % 4 == 0 && ($year % 100 != 0 || $year % 400 == 0)) ? 1 : 0
  }
  
  sub isodaysnum {
      my @t = @_;
  
      my $year = ($t[YEAR] + ($t[YEAR] < 0 ? 1900 % 400 : 1900 % 400 - 400));
      my $year_adjust = 0;
      my $days = iso_week_days($t[YDAY], $t[WDAY]);
  
      if ($days < 0) {
          # This ISO week belongs to the previous year.
          $year_adjust = -1;
          $days = iso_week_days($t[YDAY] + (365 + isleap($year -1)), $t[WDAY]);
      }
      else {
          my $d = iso_week_days($t[YDAY] - (365 + isleap($year)), $t[WDAY]);
          if ($d >= 0) {
              # This ISO week belongs to the next year.  */
              $year_adjust = 1;
              $days = $d;
          }
      }
  
      return ($days, $year_adjust);
  }
  
  sub isoyearnum {
      my ($days, $year_adjust) = isodaysnum(@_);
      return $_[YEAR] + 1900 + $year_adjust;
  }
  
  sub isoweeknum {
      my ($days, $year_adjust) = isodaysnum(@_);
      return int($days / 7) + 1;
  }
  
  our %FORMAT_CHARS = map { $_ => 1 } split //, q!%aAbBcCdDeFGghHIjklmMnNpPrRsStTuUVwWxXyYzZ!;
  
  our %SPRINTF_CHARS = (
      '%' => [q!%s!, q!%!],
      'a' => [q!%s!, q!$weekday_abbr[$_[WDAY]]!],
      'A' => [q!%s!, q!$weekday_name[$_[WDAY]]!],
      'b' => [q!%s!, q!$month_abbr[$_[MONTH]]!],
      'B' => [q!%s!, q!$month_name[$_[MONTH]]!],
      'c' => [q!%s %s %2d %02d:%02d:%02d %04d!,
              q!$weekday_abbr[$_[WDAY]], $month_abbr[$_[MONTH]], $_[DAY], $_[HOUR], $_[MIN], $_[SEC], $_[YEAR]+1900!],
      'C' => [q!%02d!, q!($_[YEAR]+1900)/100!],
      'd' => [q!%02d!, q!$_[DAY]!],
      'D' => [q!%02d/%02d/%02d!, q!$_[MONTH]+1,$_[DAY],$_[YEAR]%100!],
      'e' => [q!%2d!, q!$_[DAY]!],
      'F' => [q!%04d-%02d-%02d!, q!$_[YEAR]+1900,$_[MONTH]+1,$_[DAY]!],
      'h' => [q!%s!, q!$month_abbr[$_[MONTH]]!],
      'H' => [q!%02d!, q!$_[HOUR]!],
      'I' => [q!%02d!, q!$_[HOUR]%12 || 1!],
      'j' => [q!%03d!, q!$_[YDAY]+1!],
      'k' => [q!%2d!, q!$_[HOUR]!],
      'l' => [q!%2d!, q!$_[HOUR]%12 || 1!],
      'm' => [q!%02d!, q!$_[MONTH]+1!],
      'M' => [q!%02d!, q!$_[MIN]!],
      'n' => [q!%s!, q!"\n"!],
      'N' => [q!%s!, q!substr(sprintf('%.9f', $_[SEC] - int $_[SEC]), 2)!],
      'p' => [q!%s!, q!$_[HOUR] > 0 && $_[HOUR] < 13 ? "AM" : "PM"!],
      'P' => [q!%s!, q!$_[HOUR] > 0 && $_[HOUR] < 13 ? "am" : "pm"!],
      'r' => [q!%02d:%02d:%02d %s!, q!$_[HOUR]%12 || 1, $_[MIN], $_[SEC], $_[HOUR] > 0 && $_[HOUR] < 13 ? "AM" : "PM"!],
      'R' => [q!%02d:%02d!, q!$_[HOUR], $_[MIN]!],
      'S' => [q!%02d!, q!$_[SEC]!],
      't' => [q!%s!, q!"\t"!],
      'T' => [q!%02d:%02d:%02d!, q!$_[HOUR], $_[MIN], $_[SEC]!],
      'u' => [q!%d!, q!$_[WDAY] || 7!],
      'w' => [q!%d!, q!$_[WDAY]!],
      'x' => [q!%02d/%02d/%02d!, q!$_[MONTH]+1,$_[DAY],$_[YEAR]%100!],
      'X' => [q!%02d:%02d:%02d!, q!$_[HOUR], $_[MIN], $_[SEC]!],
      'y' => [q!%02d!, q!$_[YEAR]%100!],
      'Y' => [q!%02d!, q!$_[YEAR]+1900!],
      '%' => [q!%s!, q!'%'!],
  );
  
  if ( eval { require Time::TZOffset; 1 } ) {
      $SPRINTF_CHARS{z} = [q!%s!,q!Time::TZOffset::tzoffset(@_)!];
  }
  
  our %LOCALE_CHARS = (
      '%' => [q!'%%'!],
      'a' => [q!$weekday_abbr[$_[WDAY]]!,1],
      'A' => [q!$weekday_name[$_[WDAY]]!,1],
      'b' => [q!$month_abbr[$_[MONTH]]!],
      'B' => [q!$month_name[$_[MONTH]]!],
      'c' => [q!$weekday_abbr[$_[WDAY]] . ' ' . $month_abbr[$_[MONTH]] . ' ' . substr(' '.$_[DAY],-2) . ' %H:%M:%S %Y'!,1],
      'C' => [q!substr('0'.int(($_[YEAR]+1900)/100), -2)!],  #century
      'h' => [q!$month_abbr[$_[MONTH]]!],
      'k' => [q!substr(' '.$_[HOUR],-2)!],
      'l' => [q!substr(' '.($_[HOUR]%12 || 1),-2)!],
      'N' => [q!substr(sprintf('%.9f', $_[SEC] - int $_[SEC]), 2)!],
      'n' => [q!"\n"!],
      'p' => [q!$_[HOUR] > 0 && $_[HOUR] < 13 ? "AM" : "PM"!],
      'P' => [q!$_[HOUR] > 0 && $_[HOUR] < 13 ? "am" : "pm"!],
      'r' => [q!sprintf('%02d:%02d:%02d %s',$_[HOUR]%12 || 1, $_[MIN], $_[SEC], $_[HOUR] > 0 && $_[HOUR] < 13 ? "AM" : "PM")!],
      't' => [q!"\t"!],
      'x' => [q!'%m/%d/%y'!],
      'X' => [q!'%H:%M:%S'!],
      'z' => [q!'%z'!,1],
      'Z' => [q!'%Z'!,1],
  );
  
  if ( $^O =~ m!^(MSWin32|cygwin)$!i ) {
      %LOCALE_CHARS = (
          %LOCALE_CHARS,
          'D' => [q!'%m/%d/%y'!],
          'F' => [q!'%Y-%m-%d'!],
          'G' => [q!substr('0000'. isoyearnum(@_), -4)!,1],
          'R' => [q!'%H:%M'!],
          'T' => [q!'%H:%M:%S'!],
          'V' => [q!substr('0'.isoweeknum(@_),-2)!,1],
          'e' => [q!substr(' '.$_[DAY],-2)!],
          'g' => [q!substr('0'.isoyearnum(@_)%100,-2)!,1],
          's' => [q!int(Time::Local::timegm(@_))!,1],
          'u' => [q!$_[WDAY] || 7!,1],
          'z' => [q!tzoffset(@_)!,1],
          'Z' => [q!tzname(@_)!,1],
      );
  }
  elsif ( $^O =~ m!^solaris$!i ) {
      $LOCALE_CHARS{s} = [q!int(Time::Local::timegm(@_))!,1];
  }
  
  my $sprintf_char_handler = sub {
      my ($char,$args) = @_;
      return q|! . '%%' .q!| if $char eq ''; #last %
      return q|! . '%%| . $char . q|' . q!| if ! exists $FORMAT_CHARS{$char}; #escape %%
      my ($format, $code) = @{$SPRINTF_CHARS{$char}};
      push @$args, $code;
      return $format;
  };
  
  my $char_handler = sub {
      my ($char,$need9char_ref) = @_;
      return q|! . '%%' .q!| if $char eq ''; #last %
      return q|! . '%%| . $char . q|' . q!| if ! exists $FORMAT_CHARS{$char}; #escape %%
      return q|! . '%| . $char . q|' . q!| if ! exists $LOCALE_CHARS{$char}; #stay
      my ($code,$flag) = @{$LOCALE_CHARS{$char}};
      $$need9char_ref++ if $flag;
      q|! . | . $code . q| . q!|;
  };
  
  sub compile {
      my ($fmt) = @_;
  
      my @weekday_name = qw(Sunday Monday Tuesday Wednesday Thursday Friday Saturday);
      my @weekday_abbr = qw(Sun Mon Tue Wed Thu Fri Sat);
      my @month_name = qw(January February March April May June July August September October November December);
      my @month_abbr = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
  
      $fmt =~ s/!/\\!/g;
      $fmt =~ s!\%E([cCxXyY])!%$1!g;
      $fmt =~ s!\%O([deHImMSuUVwWy])!%$1!g;
  
      my $sprintf_fmt = $fmt;
      my $disable_sprintf=0;
      my $sprintf_code = '';
      while ( $sprintf_fmt =~ m~ (?:\%([\%\+a-zA-Z])) ~gx ) {
          if ( exists $FORMAT_CHARS{$1} && ! exists $SPRINTF_CHARS{$1} ) {
              $disable_sprintf++
          }
      }
      if ( !$disable_sprintf ) {
          my @args;
          $sprintf_fmt =~ s!
              (?:
                   \%([\%\+a-zA-Z]|$)
              )
          ! $sprintf_char_handler->($1,\@args) !egx;
          $sprintf_code = q~if ( @_ == 9 ) {
              return sprintf(q!~ . $sprintf_fmt .  q~!,~ . join(",", @args) . q~);
          }~;
      }
  
      my $posix_fmt = $fmt;
      my $need9char=0;
      $posix_fmt =~ s!
          (?:
               \%([\%\+a-zA-Z]|$)
          )
      ! $char_handler->($1,\$need9char) !egx;
      
      my $need9char_code='';
      if ( $need9char ) {
          $need9char_code = q~if ( @_ == 6 ) {
            my $sec = $_[0];
            @_ = gmtime Time::Local::timegm(@_);
            $_[0] = $sec;
          }~;
      }
      my $code = q~sub {
          ~ . $sprintf_code . q~
          ~ . $need9char_code . q~
          if ( @_ != 9  && @_ != 6 ) {
              Carp::croak 'Usage: strftime(sec, min, hour, mday, mon, year, wday = -1, yday = -1, isdst = -1)';
          }
          POSIX::strftime(q!~ . $posix_fmt . q~!,@_);
      }~;
      my $sub = eval $code; ## no critic
      die $@ ."\n=====\n".$code."\n=====\n" if $@;
      wantarray ? ($sub,$code) : $sub;
  }
  
  my %STRFTIME;
  sub strftime {
      my $fmt = shift;
      ($STRFTIME{$fmt} ||= compile($fmt))->(@_);
  }
  
  sub new {
      my $class = shift;
      my $fmt = shift;
      my ($sub,$code) = compile($fmt);
      bless [$sub,$code], $class;
  }
  
  sub to_string {
      my $self = shift;
      $self->[0]->(@_);
  }
  
  sub code_ref {
      my $self = shift;
      $self->[0];
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  POSIX::strftime::Compiler - GNU C library compatible strftime for loggers and servers
  
  =head1 SYNOPSIS
  
      use POSIX::strftime::Compiler qw/strftime/;
  
      say strftime('%a, %d %b %Y %T %z',localtime):
      
      my $fmt = '%a, %d %b %Y %T %z';
      my $psc = POSIX::strftime::Compiler->new($fmt);
      say $psc->to_string(localtime);
  
  =head1 DESCRIPTION
  
  POSIX::strftime::Compiler provides GNU C library compatible strftime(3). But this module will not affected
  by the system locale.  This feature is useful when you want to write loggers, servers and portable applications.
  
  For generate same result strings on any locale, POSIX::strftime::Compiler wraps POSIX::strftime and 
  converts some format characters to perl code
  
  =head1 FUNCTION
  
  =over 4
  
  =item strftime($fmt:String, @time)
  
  Generate formatted string from a format and time.
  
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime();
    strftime('%d/%b/%Y:%T %z',$sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst):
  
  Compiled codes are stored in C<%POSIX::strftime::Compiler::STRFTIME>. This function is not exported by default.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item new($fmt)
  
  create instance of POSIX::strftime::Compiler
  
  =item to_string(@time)
  
  Generate formatted string from time.
  
  =back
  
  =head1 FORMAT CHARACTERS
  
  POSIX::strftime::Compiler supports almost all characters that GNU strftime(3) supports. 
  But C<%E[cCxXyY]> and C<%O[deHImMSuUVwWy]> are not supported, just remove E and O prefix.
  
  =head1 A RECOMMEND MODULE
  
  =over
  
  =item L<Time::TZOffset>
  
  If L<Time::TZOffset> is available, P::s::Compiler use it for more faster time zone offset calculation.
  I strongly recommend you to install this if you use C<%z>.
  
  =back
  
  =head1 PERFORMANCE ISSUES ON WINDOWS
  
  Windows and Cygwin and some system may not support C<%z> and C<%Z>. For these system, 
  POSIX::strftime::Compiler calculate time zone offset and find zone name. This is not fast.
  If you need performance on Windows and Cygwin, please install L<Time::TZOffset>
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<POSIX::strftime::GNU>
  
  POSIX::strftime::Compiler is built on POSIX::strftime::GNU::PP code
  
  =item L<POSIX>
  
  =item L<Apache::LogFormat::Compiler>
  
  =back
  
  =head1 LICENSE
  
  Copyright (C) Masahiro Nagano.
  
  Format specification is based on strftime(3) manual page which is a part of the Linux man-pages project.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Masahiro Nagano E<lt>kazeburo@gmail.comE<gt>
  
  =cut
  
POSIX_STRFTIME_COMPILER

    $fatpacked{"Plack.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK';
  package Plack;
  
  use strict;
  use warnings;
  use 5.008_001;
  our $VERSION = '1.0050';
  
  1;
  __END__
  
  =head1 NAME
  
  Plack - Perl Superglue for Web frameworks and Web Servers (PSGI toolkit)
  
  =head1 DESCRIPTION
  
  Plack is a set of tools for using the PSGI stack. It contains
  middleware components, a reference server and utilities for Web
  application frameworks. Plack is like Ruby's Rack or Python's Paste
  for WSGI.
  
  See L<PSGI> for the PSGI specification and L<PSGI::FAQ> to know what
  PSGI and Plack are and why we need them.
  
  =head1 MODULES AND UTILITIES
  
  =head2 Plack::Handler
  
  L<Plack::Handler> and its subclasses contains adapters for web
  servers. We have adapters for the built-in standalone web server
  L<HTTP::Server::PSGI>, L<CGI|Plack::Handler::CGI>,
  L<FCGI|Plack::Handler::FCGI>, L<Apache1|Plack::Handler::Apache1>,
  L<Apache2|Plack::Handler::Apache2> and
  L<HTTP::Server::Simple|Plack::Handler::HTTP::Server::Simple> included
  in the core Plack distribution.
  
  There are also many HTTP server implementations on CPAN that have Plack
  handlers.
  
  See L<Plack::Handler> when writing your own adapters.
  
  =head2 Plack::Loader
  
  L<Plack::Loader> is a loader to load one L<Plack::Handler> adapter
  and run a PSGI application code reference with it.
  
  =head2 Plack::Util
  
  L<Plack::Util> contains a lot of utility functions for server
  implementors as well as middleware authors.
  
  =head2 .psgi files
  
  A PSGI application is a code reference but it's not easy to pass code
  reference via the command line or configuration files, so Plack uses a
  convention that you need a file named C<app.psgi> or similar, which
  would be loaded (via perl's core function C<do>) to return the PSGI
  application code reference.
  
    # Hello.psgi
    my $app = sub {
        my $env = shift;
        # ...
        return [ $status, $headers, $body ];
    };
  
  If you use a web framework, chances are that they provide a helper
  utility to automatically generate these C<.psgi> files for you, such
  as:
  
    # MyApp.psgi
    use MyApp;
    my $app = sub { MyApp->run_psgi(@_) };
  
  It's important that the return value of C<.psgi> file is the code
  reference. See C<eg/dot-psgi> directory for more examples of C<.psgi>
  files.
  
  =head2 plackup, Plack::Runner
  
  L<plackup> is a command line launcher to run PSGI applications from
  command line using L<Plack::Loader> to load PSGI backends. It can be
  used to run standalone servers and FastCGI daemon processes. Other
  server backends like Apache2 needs a separate configuration but
  C<.psgi> application file can still be the same.
  
  If you want to write your own frontend that replaces, or adds
  functionalities to L<plackup>, take a look at the L<Plack::Runner> module.
  
  =head2 Plack::Middleware
  
  PSGI middleware is a PSGI application that wraps an existing PSGI
  application and plays both side of application and servers. From the
  servers the wrapped code reference still looks like and behaves
  exactly the same as PSGI applications.
  
  L<Plack::Middleware> gives you an easy way to wrap PSGI applications
  with a clean API, and compatibility with L<Plack::Builder> DSL.
  
  =head2 Plack::Builder
  
  L<Plack::Builder> gives you a DSL that you can enable Middleware in
  C<.psgi> files to wrap existent PSGI applications.
  
  =head2 Plack::Request, Plack::Response
  
  L<Plack::Request> gives you a nice wrapper API around PSGI C<$env>
  hash to get headers, cookies and query parameters much like
  L<Apache::Request> in mod_perl.
  
  L<Plack::Response> does the same to construct the response array
  reference.
  
  =head2 Plack::Test
  
  L<Plack::Test> is a unified interface to test your PSGI application
  using standard L<HTTP::Request> and L<HTTP::Response> pair with simple
  callbacks.
  
  =head2 Plack::Test::Suite
  
  L<Plack::Test::Suite> is a test suite to test a new PSGI server backend.
  
  =head1 CONTRIBUTING
  
  =head2 Patches and Bug Fixes
  
  Small patches and bug fixes can be either submitted via nopaste on IRC
  L<irc://irc.perl.org/#plack> or L<the github issue
  tracker|http://github.com/plack/Plack/issues>.  Forking on
  L<github|http://github.com/plack/Plack> is another good way if you
  intend to make larger fixes.
  
  See also L<http://contributing.appspot.com/plack> when you think this
  document is terribly outdated.
  
  =head2 Module Namespaces
  
  Modules added to the Plack:: sub-namespaces should be reasonably generic
  components which are useful as building blocks and not just simply using
  Plack.
  
  Middleware authors are free to use the Plack::Middleware:: namespace for
  their middleware components. Middleware must be written in the pipeline
  style such that they can chained together with other middleware components.
  The Plack::Middleware:: modules in the core distribution are good examples
  of such modules. It is recommended that you inherit from L<Plack::Middleware>
  for these types of modules.
  
  Not all middleware components are wrappers, but instead are more like
  endpoints in a middleware chain. These types of components should use the
  Plack::App:: namespace. Again, look in the core modules to see excellent
  examples of these (L<Plack::App::File>, L<Plack::App::Directory>, etc.).
  It is recommended that you inherit from L<Plack::Component> for these
  types of modules.
  
  B<DO NOT USE> Plack:: namespace to build a new web application or a
  framework. It's like naming your application under CGI:: namespace if
  it's supposed to run on CGI and that is a really bad choice and
  would confuse people badly.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 COPYRIGHT
  
  The following copyright notice applies to all the files provided in
  this distribution, including binary files, unless explicitly noted
  otherwise.
  
  Copyright 2009-2013 Tatsuhiko Miyagawa
  
  =head1 CORE DEVELOPERS
  
  Tatsuhiko Miyagawa (miyagawa)
  
  Tokuhiro Matsuno (tokuhirom)
  
  Jesse Luehrs (doy)
  
  Tomas Doran (bobtfish)
  
  Graham Knop (haarg)
  
  =head1 CONTRIBUTORS
  
  Yuval Kogman (nothingmuch)
  
  Kazuhiro Osawa (Yappo)
  
  Kazuho Oku
  
  Florian Ragwitz (rafl)
  
  Chia-liang Kao (clkao)
  
  Masahiro Honma (hiratara)
  
  Daisuke Murase (typester)
  
  John Beppu
  
  Matt S Trout (mst)
  
  Shawn M Moore (Sartak)
  
  Stevan Little
  
  Hans Dieter Pearcey (confound)
  
  mala
  
  Mark Stosberg
  
  Aaron Trevena
  
  =head1 SEE ALSO
  
  The L<PSGI> specification upon which Plack is based.
  
  L<http://plackperl.org/>
  
  The Plack wiki: L<https://github.com/plack/Plack/wiki>
  
  The Plack FAQ: L<https://github.com/plack/Plack/wiki/Faq>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK

    $fatpacked{"Plack/App/CGIBin.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_APP_CGIBIN';
  package Plack::App::CGIBin;
  use strict;
  use warnings;
  use parent qw/Plack::App::File/;
  use Plack::Util::Accessor qw( exec_cb );
  use Plack::App::WrapCGI;
  
  sub allow_path_info { 1 }
  
  my %exec_cache;
  
  sub would_exec {
      my($self, $file) = @_;
  
      return $exec_cache{$file} if exists $exec_cache{$file};
  
      my $exec_cb = $self->exec_cb || sub { $self->exec_cb_default(@_) };
  
      return $exec_cache{$file} = $exec_cb->($file);
  }
  
  sub exec_cb_default {
      my($self, $file) = @_;
  
      if ($file =~ /\.pl$/i) {
          return 0;
      } elsif ($self->shebang_for($file) =~ /^\#\!.*perl/) {
          return 0;
      } else {
          return 1;
      }
  }
  
  sub shebang_for {
      my($self, $file) = @_;
  
      open my $fh, "<", $file or return '';
      my $line = <$fh>;
      return $line;
  }
  
  sub serve_path {
      my($self, $env, $file) = @_;
  
      local @{$env}{qw(SCRIPT_NAME PATH_INFO)} = @{$env}{qw( plack.file.SCRIPT_NAME plack.file.PATH_INFO )};
  
      my $app = $self->{_compiled}->{$file} ||= Plack::App::WrapCGI->new(
          script => $file, execute => $self->would_exec($file),
      )->to_app;
      $app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::CGIBin - cgi-bin replacement for Plack servers
  
  =head1 SYNOPSIS
  
    use Plack::App::CGIBin;
    use Plack::Builder;
  
    my $app = Plack::App::CGIBin->new(root => "/path/to/cgi-bin")->to_app;
    builder {
        mount "/cgi-bin" => $app;
    };
  
    # Or from the command line
    plackup -MPlack::App::CGIBin -e 'Plack::App::CGIBin->new(root => "/path/to/cgi-bin")->to_app'
  
  =head1 DESCRIPTION
  
  Plack::App::CGIBin allows you to load CGI scripts from a directory and
  convert them into a PSGI application.
  
  This would give you the extreme easiness when you have bunch of old
  CGI scripts that is loaded using I<cgi-bin> of Apache web server.
  
  =head1 HOW IT WORKS
  
  This application checks if a given file path is a perl script and if
  so, uses L<CGI::Compile> to compile a CGI script into a sub (like
  L<ModPerl::Registry>) and then run it as a persistent application
  using L<CGI::Emulate::PSGI>.
  
  If the given file is not a perl script, it executes the script just
  like a normal CGI script with fork & exec. This is like a normal web
  server mode and no performance benefit is achieved.
  
  The default mechanism to determine if a given file is a Perl script is
  as follows:
  
  =over 4
  
  =item *
  
  Check if the filename ends with C<.pl>. If yes, it is a Perl script.
  
  =item *
  
  Open the file and see if the shebang (first line of the file) contains
  the word C<perl> (like C<#!/usr/bin/perl>). If yes, it is a Perl
  script.
  
  =back
  
  You can customize this behavior by passing C<exec_cb> callback, which
  takes a file path to its first argument.
  
  For example, if your perl-based CGI script uses lots of global
  variables and such and are not ready to run on a persistent
  environment, you can do:
  
    my $app = Plack::App::CGIBin->new(
        root => "/path/to/cgi-bin",
        exec_cb => sub { 1 },
    )->to_app;
  
  to always force the execute option for any files.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::File> L<CGI::Emulate::PSGI> L<CGI::Compile> L<Plack::App::WrapCGI>
  
  See also L<Plack::App::WrapCGI> if you compile one CGI script into a
  PSGI application without serving CGI scripts from a directory, to
  remove overhead of filesystem lookups, etc.
  
  =cut
PLACK_APP_CGIBIN

    $fatpacked{"Plack/App/Cascade.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_APP_CASCADE';
  package Plack::App::Cascade;
  use strict;
  use base qw(Plack::Component);
  
  use Plack::Util;
  use Plack::Util::Accessor qw(apps catch codes);
  
  sub add {
      my $self = shift;
      $self->apps([]) unless $self->apps;
      push @{$self->apps}, @_;
  }
  
  sub prepare_app {
      my $self = shift;
      my %codes = map { $_ => 1 } @{ $self->catch || [ 404 ] };
      $self->codes(\%codes);
  }
  
  sub call {
      my($self, $env) = @_;
  
      return sub {
          my $respond = shift;
  
          my $done;
          my $respond_wrapper = sub {
              my $res = shift;
              if ($self->codes->{$res->[0]}) {
                  # suppress output by giving the app an
                  # output spool which drops everything on the floor
                  return Plack::Util::inline_object
                      write => sub { }, close => sub { };
              } else {
                  $done = 1;
                  return $respond->($res);
              }
          };
  
          my @try = @{$self->apps || []};
          my $tries_left = 0 + @try;
  
          if (not $tries_left) {
              return $respond->([ 404, [ 'Content-Type' => 'text/html' ], [ '404 Not Found' ] ])
          }
  
          for my $app (@try) {
              my $res = $app->($env);
              if ($tries_left-- == 1) {
                  $respond_wrapper = sub { $respond->(shift) };
              }
  
              if (ref $res eq 'CODE') {
                  $res->($respond_wrapper);
              } else {
                  $respond_wrapper->($res);
              }
              return if $done;
          }
      };
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::Cascade - Cascadable compound application
  
  =head1 SYNOPSIS
  
    use Plack::App::Cascade;
    use Plack::App::URLMap;
    use Plack::App::File;
  
    # Serve static files from multiple search paths
    my $cascade = Plack::App::Cascade->new;
    $cascade->add( Plack::App::File->new(root => "/www/example.com/foo")->to_app );
    $cascade->add( Plack::App::File->new(root => "/www/example.com/bar")->to_app );
  
    my $app = Plack::App::URLMap->new;
    $app->map("/static", $cascade);
    $app->to_app;
  
  =head1 DESCRIPTION
  
  Plack::App::Cascade is a Plack middleware component that compounds
  several apps and tries them to return the first response that is not
  404.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $app = Plack::App::Cascade->new(apps => [ $app1, $app2 ]);
  
  Creates a new Cascade application.
  
  =item add
  
    $app->add($app1);
    $app->add($app2, $app3);
  
  Appends a new application to the list of apps to try. You can pass the
  multiple apps to the one C<add> call.
  
  =item catch
  
    $app->catch([ 403, 404 ]);
  
  Sets which error codes to catch and process onwards. Defaults to C<404>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::URLMap> Rack::Cascade
  
  =cut
PLACK_APP_CASCADE

    $fatpacked{"Plack/App/Directory.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_APP_DIRECTORY';
  package Plack::App::Directory;
  use parent qw(Plack::App::File);
  use strict;
  use warnings;
  use Plack::Util;
  use HTTP::Date;
  use Plack::MIME;
  use DirHandle;
  use URI::Escape;
  use Plack::Request;
  
  # Stolen from rack/directory.rb
  my $dir_file = "<tr><td class='name'><a href='%s'>%s</a></td><td class='size'>%s</td><td class='type'>%s</td><td class='mtime'>%s</td></tr>";
  my $dir_page = <<PAGE;
  <html><head>
    <title>%s</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <style type='text/css'>
  table { width:100%%; }
  .name { text-align:left; }
  .size, .mtime { text-align:right; }
  .type { width:11em; }
  .mtime { width:15em; }
    </style>
  </head><body>
  <h1>%s</h1>
  <hr />
  <table>
    <tr>
      <th class='name'>Name</th>
      <th class='size'>Size</th>
      <th class='type'>Type</th>
      <th class='mtime'>Last Modified</th>
    </tr>
  %s
  </table>
  <hr />
  </body></html>
  PAGE
  
  sub should_handle {
      my($self, $file) = @_;
      return -d $file || -f $file;
  }
  
  sub return_dir_redirect {
      my ($self, $env) = @_;
      my $uri = Plack::Request->new($env)->uri;
      return [ 301,
          [
              'Location' => $uri . '/',
              'Content-Type' => 'text/plain',
              'Content-Length' => 8,
          ],
          [ 'Redirect' ],
      ];
  }
  
  sub serve_path {
      my($self, $env, $dir) = @_;
  
      if (-f $dir) {
          return $self->SUPER::serve_path($env, $dir);
      }
  
      my $dir_url = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
  
      if ($dir_url !~ m{/$}) {
          return $self->return_dir_redirect($env);
      }
  
      my @files = ([ "../", "Parent Directory", '', '', '' ]);
  
      my $dh = DirHandle->new($dir);
      my @children;
      while (defined(my $ent = $dh->read)) {
          next if $ent eq '.' or $ent eq '..';
          push @children, $ent;
      }
  
      for my $basename (sort { $a cmp $b } @children) {
          my $file = "$dir/$basename";
          my $url = $dir_url . $basename;
  
          my $is_dir = -d $file;
          my @stat = stat _;
  
          $url = join '/', map {uri_escape($_)} split m{/}, $url;
  
          if ($is_dir) {
              $basename .= "/";
              $url      .= "/";
          }
  
          my $mime_type = $is_dir ? 'directory' : ( Plack::MIME->mime_type($file) || 'text/plain' );
          push @files, [ $url, $basename, $stat[7], $mime_type, HTTP::Date::time2str($stat[9]) ];
      }
  
      my $path  = Plack::Util::encode_html("Index of $env->{PATH_INFO}");
      my $files = join "\n", map {
          my $f = $_;
          sprintf $dir_file, map Plack::Util::encode_html($_), @$f;
      } @files;
      my $page  = sprintf $dir_page, $path, $path, $files;
  
      return [ 200, ['Content-Type' => 'text/html; charset=utf-8'], [ $page ] ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::Directory - Serve static files from document root with directory index
  
  =head1 SYNOPSIS
  
    # app.psgi
    use Plack::App::Directory;
    my $app = Plack::App::Directory->new({ root => "/path/to/htdocs" })->to_app;
  
  =head1 DESCRIPTION
  
  This is a static file server PSGI application with directory index a la Apache's mod_autoindex.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item root
  
  Document root directory. Defaults to the current directory.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::File>
  
  =cut
PLACK_APP_DIRECTORY

    $fatpacked{"Plack/App/File.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_APP_FILE';
  package Plack::App::File;
  use strict;
  use warnings;
  use parent qw/Plack::Component/;
  use File::Spec::Unix;
  use Cwd ();
  use Plack::Util;
  use Plack::MIME;
  use HTTP::Date;
  
  use Plack::Util::Accessor qw( root file content_type encoding );
  
  sub should_handle {
      my($self, $file) = @_;
      return -f $file;
  }
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my($file, $path_info) = $self->file || $self->locate_file($env);
      return $file if ref $file eq 'ARRAY';
  
      if ($path_info) {
          $env->{'plack.file.SCRIPT_NAME'} = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
          $env->{'plack.file.SCRIPT_NAME'} =~ s/\Q$path_info\E$//;
          $env->{'plack.file.PATH_INFO'}   = $path_info;
      } else {
          $env->{'plack.file.SCRIPT_NAME'} = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
          $env->{'plack.file.PATH_INFO'}   = '';
      }
  
      return $self->serve_path($env, $file);
  }
  
  sub locate_file {
      my($self, $env) = @_;
  
      my $path = $env->{PATH_INFO} || '';
  
      if ($path =~ /\0/) {
          return $self->return_400;
      }
  
      my $docroot = $self->root || ".";
      my @path = split /[\\\/]/, $path, -1; # -1 *MUST* be here to avoid security issues!
      if (@path) {
          shift @path if $path[0] eq '';
      } else {
          @path = ('.');
      }
  
      if (grep /^\.{2,}$/, @path) {
          return $self->return_403;
      }
  
      my($file, @path_info);
      while (@path) {
          my $try = File::Spec::Unix->catfile($docroot, @path);
          if ($self->should_handle($try)) {
              $file = $try;
              last;
          } elsif (!$self->allow_path_info) {
              last;
          }
          unshift @path_info, pop @path;
      }
  
      if (!$file) {
          return $self->return_404;
      }
  
      if (!-r $file) {
          return $self->return_403;
      }
  
      return $file, join("/", "", @path_info);
  }
  
  sub allow_path_info { 0 }
  
  sub serve_path {
      my($self, $env, $file) = @_;
  
      my $content_type = $self->content_type || Plack::MIME->mime_type($file)
                         || 'text/plain';
  
      if ("CODE" eq ref $content_type) {
  		$content_type = $content_type->($file);
      }
  
      if ($content_type =~ m!^text/!) {
          $content_type .= "; charset=" . ($self->encoding || "utf-8");
      }
  
      open my $fh, "<:raw", $file
          or return $self->return_403;
  
      my @stat = stat $file;
  
      Plack::Util::set_io_path($fh, Cwd::realpath($file));
  
      return [
          200,
          [
              'Content-Type'   => $content_type,
              'Content-Length' => $stat[7],
              'Last-Modified'  => HTTP::Date::time2str( $stat[9] )
          ],
          $fh,
      ];
  }
  
  sub return_403 {
      my $self = shift;
      return [403, ['Content-Type' => 'text/plain', 'Content-Length' => 9], ['forbidden']];
  }
  
  sub return_400 {
      my $self = shift;
      return [400, ['Content-Type' => 'text/plain', 'Content-Length' => 11], ['Bad Request']];
  }
  
  # Hint: subclasses can override this to return undef to pass through 404
  sub return_404 {
      my $self = shift;
      return [404, ['Content-Type' => 'text/plain', 'Content-Length' => 9], ['not found']];
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::App::File - Serve static files from root directory
  
  =head1 SYNOPSIS
  
    use Plack::App::File;
    my $app = Plack::App::File->new(root => "/path/to/htdocs")->to_app;
  
    # Or map the path to a specific file
    use Plack::Builder;
    builder {
        mount "/favicon.ico" => Plack::App::File->new(file => '/path/to/favicon.ico')->to_app;
    };
  
  =head1 DESCRIPTION
  
  This is a static file server PSGI application, and internally used by
  L<Plack::Middleware::Static>. This application serves files from the
  document root if the path matches with the local file. Use
  L<Plack::App::Directory> if you want to list files in the directory
  as well.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item root
  
  Document root directory. Defaults to C<.> (current directory)
  
  =item file
  
  The file path to create responses from. Optional.
  
  If it's set the application would B<ALWAYS> create a response out of
  the file and there will be no security check etc. (hence fast). If
  it's not set, the application uses C<root> to find the matching file.
  
  =item encoding
  
  Set the file encoding for text files. Defaults to C<utf-8>.
  
  =item content_type
  
  Set the file content type. If not set L<Plack::MIME> will try to detect it
  based on the file extension or fall back to C<text/plain>.
  Can be set to a callback which should work on $_[0] to check full path file
  name.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Middleware::Static> L<Plack::App::Directory>
  
  =cut
PLACK_APP_FILE

    $fatpacked{"Plack/App/PSGIBin.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_APP_PSGIBIN';
  package Plack::App::PSGIBin;
  use strict;
  use warnings;
  use parent qw/Plack::App::File/;
  use Plack::Util;
  
  sub allow_path_info { 1 }
  
  sub serve_path {
      my($self, $env, $file) = @_;
  
      local @{$env}{qw(SCRIPT_NAME PATH_INFO)} = @{$env}{qw( plack.file.SCRIPT_NAME plack.file.PATH_INFO )};
  
      my $app = $self->{_compiled}->{$file} ||= Plack::Util::load_psgi($file);
      $app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::PSGIBin - Run .psgi files from a directory
  
  =head1 SYNOPSIS
  
    use Plack::App::PSGIBin;
    use Plack::Builder;
  
    my $app = Plack::App::PSGIBin->new(root => "/path/to/psgi/scripts")->to_app;
    builder {
        mount "/psgi" => $app;
    };
  
    # Or from the command line
    plackup -MPlack::App::PSGIBin -e 'Plack::App::PSGIBin->new(root => "/path/psgi/scripts")->to_app'
  
  =head1 DESCRIPTION
  
  This application loads I<.psgi> files (or actually whichever filename
  extensions) from the root directory and run it as a PSGI
  application. Suppose you have a directory containing C<foo.psgi> and
  C<bar.psgi>, map this application to C</app> with
  L<Plack::App::URLMap> and you can access them via the URL:
  
    http://example.com/app/foo.psgi
    http://example.com/app/bar.psgi
  
  to load them. You can rename the file to the one without C<.psgi>
  extension to make the URL look nicer, or use the URL rewriting tools
  like L<Plack::Middleware::Rewrite> to do the same thing.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::CGIBin>
PLACK_APP_PSGIBIN

    $fatpacked{"Plack/App/Proxy.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_APP_PROXY';
  package Plack::App::Proxy;
  
  use strict;
  use 5.008_001;
  use parent 'Plack::Component';
  use Plack::Util::Accessor qw/remote preserve_host_header backend options/;
  use Plack::Request;
  use Plack::Util;
  use HTTP::Headers;
  
  our $VERSION = '0.29';
  
  sub prepare_app {
      my $self = shift;
      $self->backend($ENV{PLACK_PROXY_BACKEND} || 'AnyEvent::HTTP') unless defined $self->backend;
  }
  
  # hop-by-hop headers (see also RFC2616)
  my @hop_by_hop = qw(
      Connection Keep-Alive Proxy-Authenticate Proxy-Authorization
      TE Trailer Transfer-Encoding Upgrade
  );
  
  sub filter_headers {
      my $self = shift;
      my ( $headers ) = @_;
  
      # Save from known hop-by-hop deletion.
      my @connection_tokens = $headers->header('Connection');
  
      # Remove hop-by-hop headers.
      $headers->remove_header( $_ ) for @hop_by_hop;
  
      # Connection header's tokens are also hop-by-hop.
      for my $token ( @connection_tokens ){
          $headers->remove_header( $_ ) for split /\s*,\s*/, $token;
      }
  }
  
  sub build_url_from_env {
      my($self, $env) = @_;
  
      return $env->{'plack.proxy.url'}
          if exists $env->{'plack.proxy.url'};
  
      my $url = $env->{'plack.proxy.remote'} || $self->remote
          or return;
  
      # avoid double slashes
      $url =~ s!/$!! unless $env->{SCRIPT_NAME} && $env->{SCRIPT_NAME} =~ m!/$!;
  
      $url .= $env->{PATH_INFO} || '';
      $url .= '?' . $env->{QUERY_STRING} if defined $env->{QUERY_STRING} && length $env->{QUERY_STRING} > 0;
  
      return $url;
  }
  
  sub build_headers_from_env {
      my($self, $env, $req) = @_;
  
      my $headers = $req->headers->clone;
      $headers->header("X-Forwarded-For" => $env->{REMOTE_ADDR});
      $headers->remove_header("Host") unless $self->preserve_host_header;
      $self->filter_headers( $headers );
  
      +{ map {$_ => scalar $headers->header($_) } $headers->header_field_names };
  }
  
  sub call {
      my ($self, $env) = @_;
  
      unless ($env->{'psgi.streaming'}) {
          die "Plack::App::Proxy only runs with the server with psgi.streaming support";
      }
  
      my $url = $self->build_url_from_env($env)
          or return [502, ["Content-Type","text/html"], ["Can't determine proxy remote URL"]];
  
      my $req = Plack::Request->new($env);
      my $headers = $self->build_headers_from_env($env, $req);
  
      my $method  = $env->{REQUEST_METHOD};
      my $content = $req->content;
  
      my $backend_class = Plack::Util::load_class(
          $self->backend, 'Plack::App::Proxy::Backend'
      );
  
      return $backend_class->new(
          url              => $url,
          req              => $req,
          headers          => $headers,
          method           => $method,
          content          => $content,
          options          => $self->options,
          response_headers => sub { $self->response_headers(@_) },
      )->call($env);
  }
  
  sub response_headers {
      my ($self, $headers) = @_;
  
      $self->filter_headers( $headers );
  
      # Remove PSGI forbidden headers
      $headers->remove_header('Status');
  
      my @headers;
      $headers->scan( sub { push @headers, @_ } );
  
      return @headers;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::Proxy - proxy requests
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    # proxy all requests for /static to 127.0.0.1:80
    builder {
        mount "/static" => Plack::App::Proxy->new(remote => "http://127.0.0.1:80")->to_app;
    };
  
    # Call from other app
    my $proxy = Plack::App::Proxy->new->to_app;
    my $app = sub {
        my $env = shift;
        ...
        $env->{'plack.proxy.url'} = $url;
        $proxy->($env);
    };
  
  =head1 DESCRIPTION
  
  Plack::App::Proxy is a middleware-aware proxy application for Plack.
  
  =head1 OPTIONS
  
  =over 4
  
  =item remote
  
    Plack::App::Proxy->new(remote => 'http://perl.org')->to_app;
  
  Specifies the base remote URL to proxy requests to.
  
    builder {
        mount "/example",
            Plack::App::Proxy->new(remote => 'http://example.com/app/foo')->to_app;
    };
  
  This proxies incoming requests for C</example/bar> proxied to
  C<http://example.com/app/foo/bar>.
  
  =item preserve_host_header
  
  Preserves the original Host header, which is useful when you do
  reverse proxying to the internal hosts.
  
  =item backend
  
  The HTTP backend to use. This dist comes with C<LWP> and C<AnyEvent::HTTP>
  backends. C<AnyEvent::HTTP> is the default if no backend is specified.
  
  =item options
  
  The options for the HTTP backend instance.
  
  =back
  
  =head1 MIDDLEWARE CONFIGURATIONS
  
  This application is just like a normal PSGI application and is
  middleware aware, which means you can modify proxy requests (and
  responses) using Plack middleware stack.
  
  It also supports the following special environment variables:
  
  =over 4
  
  =item plack.proxy.url
  
  Overrides the proxy request URL.
  
  =item plack.proxy.remote
  
  Overrides the base URL path to proxy to.
  
  =back
  
  For example, the following builder code allows you to proxy all GET
  requests for .png paths to the lolcat image (yes, a silly example) but
  proxies to the internal host otherwise.
  
    my $mw = sub {
        my $app = shift;
        sub {
            my $env = shift;
            if ($env->{REQUEST_METHOD} eq 'GET' && $env->{PATH_INFO} =~ /\.png$/) {
                $env->{'plack.proxy.url'} = 'http://lolcat.example.com/lol.png';
            }
            $app->($env);
        };
    };
  
    use Plack::Builder;
  
    builder {
        enable $mw;
        Plack::App::Proxy->new(remote => 'http://10.0.0.1:8080')->to_app;
    };
  
  =head1 AUTHOR
  
  Lee Aylward
  
  Masahiro Honma
  
  Tatsuhiko Miyagawa
  
  Jesse Luehrs
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Plack::Builder>
  
  =cut
PLACK_APP_PROXY

    $fatpacked{"Plack/App/Proxy/Backend.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_APP_PROXY_BACKEND';
  package Plack::App::Proxy::Backend;
  
  use strict;
  use parent 'Plack::Component';
  use Plack::Util::Accessor qw/url req headers method content response_headers options/;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::Proxy::Backend - pluggable backend for making the actual HTTP request
  
  =head1 SYNOPSIS
  
    package Plack::App::Proxy::Backend::foo;
    use parent 'Plack::App::Proxy::Backend';
    sub call {
        my $self = shift;
        my ($env) = @_;
        # ...
    }
  
  =head1 DESCRIPTION
  
  This is a base class for HTTP backends for L<Plack::App::Proxy>.
  
  =head1 AUTHOR
  
  Lee Aylward
  
  Masahiro Honma
  
  Tatsuhiko Miyagawa
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK_APP_PROXY_BACKEND

    $fatpacked{"Plack/App/Proxy/Backend/AnyEvent/HTTP.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_APP_PROXY_BACKEND_ANYEVENT_HTTP';
  package Plack::App::Proxy::Backend::AnyEvent::HTTP;
  
  use strict;
  use parent 'Plack::App::Proxy::Backend';
  use AnyEvent::HTTP;
  
  sub call {
      my $self = shift;
      my ($env) = @_;
  
      return sub {
          my $respond = shift;
          my $cv = AE::cv;
          my $writer;
          AnyEvent::HTTP::http_request(
              $self->method => $self->url,
              headers => $self->headers,
              body => $self->content,
              recurse => 0,  # want not to treat any redirections
              persistent => 0,
              %{ $self->options || {} },
              on_header => sub {
                  my $headers = shift;
  
                  if ($headers->{Status} !~ /^59\d+/) {
                      $env->{'plack.proxy.last_protocol'} = $headers->{HTTPVersion};
                      $env->{'plack.proxy.last_status'}   = $headers->{Status};
                      $env->{'plack.proxy.last_reason'}   = $headers->{Reason};
                      $env->{'plack.proxy.last_url'}      = $headers->{URL};
  
                      my $http_headers = HTTP::Headers->new(
                        map { $_ => $headers->{$_} } grep {! /^[A-Z]/} keys %$headers
                      );
  
                      my $cookies = $http_headers->header( 'Set-Cookie' );
                      if ( $cookies ) {
                          my @cookies = split /,(?=\S+)/, $cookies;
                          $http_headers->header( Set_Cookie => \@cookies );
                      }
  
                      $writer = $respond->([
                          $headers->{Status},
                          [$self->response_headers->($http_headers)],
                      ]);
                  }
                  return 1;
              },
              on_body => sub {
                $writer->write($_[0]);
                return 1;
              },
              sub {
                  my (undef, $headers) = @_;
  
                  if (!$writer and $headers->{Status} =~ /^59\d/) {
                      $respond->([502, ["Content-Type","text/html"], ["Gateway error: $headers->{Reason}"]]);
                  }
  
                  $writer->close if $writer;
                  $cv->send;
  
                  # http_request may not release $cb with perl 5.8.8
                  # and AE::HTTP 1.44. So free $env manually.
                  undef $env;
  
                  # Free the reference manually for perl 5.8.x
                  # to avoid nested closure memory leaks.
                  undef $respond;
              }
          );
          $cv->recv unless $env->{"psgi.nonblocking"};
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::Proxy::Backend::AnyEvent::HTTP - backend which uses AnyEvent::HTTP
  
  =head1 SYNOPSIS
  
    my $app = Plack::App::Proxy->new(backend => 'AnyEvent::HTTP')->to_app;
  
  =head1 DESCRIPTION
  
  This backend uses L<AnyEvent::HTTP> to make HTTP requests. This is the default
  backend used when no backend is specified in the constructor.
  
  =head1 AUTHOR
  
  Lee Aylward
  
  Masahiro Honma
  
  Tatsuhiko Miyagawa
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK_APP_PROXY_BACKEND_ANYEVENT_HTTP

    $fatpacked{"Plack/App/Proxy/Backend/HTTP/Tiny.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_APP_PROXY_BACKEND_HTTP_TINY';
  package Plack::App::Proxy::Backend::HTTP::Tiny;
  
  =head1 NAME
  
  Plack::App::Proxy::HTTP::Tiny - Backend for Plack::App::Proxy
  
  =head1 SYNOPSIS
  
  =for markdown ```perl
  
      # In app.psgi
      use Plack::Builder;
      use Plack::App::Proxy::Anonymous;
  
      builder {
          enable "Proxy::Requests";
          Plack::App::Proxy->new(backend => 'HTTP::Tiny')->to_app;
      };
  
  =for markdown ```
  
  =head1 DESCRIPTION
  
  This backend uses L<HTTP::Tiny::PreserveHostHeader> to make HTTP requests.
  
  L<HTTP::Tiny::PreserveHostHeader> is a wrapper for L<HTTP::Tiny> which is
  Pure-Perl only and doesn't require any architecture specific files.
  
  It is possible to bundle it e.g. by L<App::FatPacker>.
  
  =for readme stop
  
  =cut
  
  use 5.006;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.0203';
  
  use parent qw(Plack::App::Proxy::Backend);
  
  use HTTP::Headers;
  
  use HTTP::Tiny::PreserveHostHeader;
  
  sub call {
      my ($self, $env) = @_;
  
      return sub {
          my ($respond) = @_;
  
          my $http = HTTP::Tiny::PreserveHostHeader->new(
              max_redirect => 0,
              %{ $self->options || {} }
          );
  
          my $writer;
  
          my $response = $http->request(
              $self->method => $self->url,
              {
                  headers       => $self->headers,
                  content       => $self->content,
                  data_callback => sub {
                      my ($data, $res) = @_;
  
                      return if $res->{status} =~ /^59\d+/;
  
                      if (not $writer) {
                          $env->{'plack.proxy.last_protocol'} = '1.1';    # meh
                          $env->{'plack.proxy.last_status'} = $res->{status};
                          $env->{'plack.proxy.last_reason'} = $res->{reason};
                          $env->{'plack.proxy.last_url'} = $self->url;
  
                          $writer = $respond->(
                              [
                                  $res->{status},
                                  [$self->response_headers->(HTTP::Headers->new(%{ $res->{headers} }))],
                              ]
                          );
                      }
  
                      $writer->write($data);
                  },
              }
          );
  
          if ($writer) {
              $writer->close;
              return;
          }
  
          if ($response->{status} =~ /^59\d/) {
              return $respond->([502, ['Content-Type' => 'text/html'], ["Gateway error: $response->{content}"]]);
          }
  
          return $respond->(
              [
                  $response->{status},
                  [$self->response_headers->(HTTP::Headers->new(%{ $response->{headers} }))],
                  [$response->{content}],
              ]
          );
      };
  }
  
  1;
  
  =for readme continue
  
  =head1 SEE ALSO
  
  L<Plack>, L<Plack::App::Proxy>, L<Plack::Middleware::Proxy::Requests>,
  L<HTTP::Tiny>.
  
  =head1 BUGS
  
  This module might be incompatible with further versions of
  L<Plack::App::Proxy> module.
  
  If you find the bug or want to implement new features, please report it at
  L<https://github.com/dex4er/perl-Plack-App-Proxy-Backend-HTTP-Tiny/issues>
  
  The code repository is available at
  L<http://github.com/dex4er/perl-Plack-App-Proxy-Backend-HTTP-Tiny>
  
  =head1 AUTHOR
  
  Piotr Roszatycki <dexter@cpan.org>
  
  =head1 LICENSE
  
  Copyright (c) 2014-2016, 2023 Piotr Roszatycki <dexter@cpan.org>.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as perl itself.
  
  See L<http://dev.perl.org/licenses/artistic.html>
PLACK_APP_PROXY_BACKEND_HTTP_TINY

    $fatpacked{"Plack/App/Proxy/Backend/LWP.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_APP_PROXY_BACKEND_LWP';
  package Plack::App::Proxy::Backend::LWP;
  
  use strict;
  use parent 'Plack::App::Proxy::Backend';
  use LWP::UserAgent;
  
  sub call {
      my $self = shift;
      my ($env) = @_;
  
      return sub {
          my $respond = shift;
  
          my $req = HTTP::Request->new(
              $self->method => $self->url,
              HTTP::Headers->new(%{ $self->headers }),
              $self->content
          );
  
          my $ua = LWP::UserAgent->new(%{ $self->options || {} });
          my $writer;
  
          $ua->add_handler(
              response_header => sub {
                  my ($res) = @_;
  
                  $env->{'plack.proxy.last_protocol'} = '1.1'; # meh
                  $env->{'plack.proxy.last_status'}   = $res->code;
                  $env->{'plack.proxy.last_reason'}   = $res->message;
                  $env->{'plack.proxy.last_url'}      = $self->url;
  
                  $writer = $respond->([
                      $res->code,
                      [$self->response_headers->($res->headers)],
                  ]);
              },
          );
          $ua->add_handler(
              response_data => sub {
                  my (undef, undef, undef, $data) = @_;
                  $writer->write($data);
                  return 1;
              },
          );
          $ua->add_handler(
              response_done => sub {
                  $writer->close if $writer;
              },
          );
  
          my $res = $ua->simple_request($req);
          return if $writer;
          $respond->([
              $res->code,
              [$self->response_headers->($res->headers)],
              [$res->content],
          ]);
      };
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::Proxy::Backend::LWP - backend which uses LWP::UserAgent
  
  =head1 SYNOPSIS
  
    my $app = Plack::App::Proxy->new(backend => 'LWP')->to_app;
  
  =head1 DESCRIPTION
  
  This backend uses L<LWP::UserAgent> to make HTTP requests.
  
  =head1 AUTHOR
  
  Lee Aylward
  
  Masahiro Honma
  
  Tatsuhiko Miyagawa
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK_APP_PROXY_BACKEND_LWP

    $fatpacked{"Plack/App/Proxy/Test.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_APP_PROXY_TEST';
  package Plack::App::Proxy::Test;
  use strict;
  use warnings;
  use Carp;
  use Plack::Loader;
  use Plack::Test;
  use Test::More;
  use Test::TCP;
  use LWP::UserAgent;
  use base Exporter::;
  our @EXPORT = qw(test_proxy);
  
  BEGIN {
    # disable HTTP proxy when testing since we are connecting to localhost
    delete $ENV{http_proxy};
  }
  
  our @BACKENDS = qw/LWP AnyEvent::HTTP/;
  
  sub test_proxy {
      my %args = @_;
  
      local $Plack::Test::Impl = 'Server';
  
      my $client = delete $args{client} or croak "client test code needed";
      my $app    = delete $args{app}    or croak "app needed";
      my $proxy  = delete $args{proxy}  or croak "proxy needed";
      my $host   = delete $args{host} || '127.0.0.1';
  
      for my $backend (@BACKENDS) {
  
          local $ENV{PLACK_PROXY_BACKEND} = $backend;
  
          test_tcp(
              client => sub {
                  my $port = shift;
                  test_psgi(
                      app => $proxy->( $host, $port ),
                      client => $client,
                      host => $host,
                      # disable the auto redirection of LWP::UA
                      ua => LWP::UserAgent->new( max_redirect => 0 ),
                  );
              },
              server => sub {
                  my $port = shift;
  
                  # Use an ordinary server.
                  local $ENV{PLACK_SERVER} = 'Standalone';
  
                  my $server = Plack::Loader->auto(port => $port, host => $host);
                  $server->run($app);
              },
          );
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::Proxy::Test - Is utilities to test Plack::App::Proxy.
  
  =head1 SYNOPSIS
  
    test_proxy(
        app   => $backend_app,
        proxy => sub { Plack::App::Proxy->new(remote => "http://$_[0]:$_[1]") },
        client => sub {
            my $cb = shift;
            my $res = $cb->(GET '/');
            ok $res->is_success, "Check the status line.";
        },
    );
  
  =head1 DESCRIPTION
  
  Plack::App::Proxy::Test provids test_proxy function which wraps 
  test_psgi of Plack::Test simply. 
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item test_proxy
  
    test_proxy app    => $app, 
               proxy  => $proxy_cb->($app_host, $app_port), 
               client => $client_cb->($cb);
  
  =back
  
  test_proxy runs two servers, 'C<app>' as an origin server and the proxy server.
  In 'C<proxy>' callback, you should create the proxy server instance to send 
  requests to 'C<app>' server. Then 'C<client>' callback is called to run your 
  tests. In 'C<client>' callback, all HTTP requests are sent to 'C<proxy>' 
  server. (And the proxy server will proxy your request to the app server.)
  
  =head1 AUTHOR
  
  Masahiro Honma E<lt>hiratara@cpan.orgE<gt>
  
  =cut
  
  =head1 SEE ALSO
  
  L<Plack::App::Proxy> L<Plack::Test>
  
  =cut
  
PLACK_APP_PROXY_TEST

    $fatpacked{"Plack/App/URLMap.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_APP_URLMAP';
  package Plack::App::URLMap;
  use strict;
  use warnings;
  use parent qw(Plack::Component);
  use constant DEBUG => $ENV{PLACK_URLMAP_DEBUG} ? 1 : 0;
  
  use Carp ();
  
  sub mount { shift->map(@_) }
  
  sub map {
      my $self = shift;
      my($location, $app) = @_;
  
      my $host;
      if ($location =~ m!^https?://(.*?)(/.*)!) {
          $host     = $1;
          $location = $2;
      }
  
      if ($location !~ m!^/!) {
          Carp::croak("Paths need to start with /");
      }
      $location =~ s!/$!!;
  
      push @{$self->{_mapping}}, [ $host, $location, qr/^\Q$location\E/, $app ];
  }
  
  sub prepare_app {
      my $self = shift;
      # sort by path length
      $self->{_sorted_mapping} = [
          map  { [ @{$_}[2..5] ] }
          sort { $b->[0] <=> $a->[0] || $b->[1] <=> $a->[1] }
          map  { [ ($_->[0] ? length $_->[0] : 0), length($_->[1]), @$_ ] } @{$self->{_mapping}},
      ];
  }
  
  sub call {
      my ($self, $env) = @_;
  
      my $path_info   = $env->{PATH_INFO};
      my $script_name = $env->{SCRIPT_NAME};
  
      my($http_host, $server_name) = @{$env}{qw( HTTP_HOST SERVER_NAME )};
  
      if ($http_host and my $port = $env->{SERVER_PORT}) {
          $http_host =~ s/:$port$//;
      }
  
      for my $map (@{ $self->{_sorted_mapping} }) {
          my($host, $location, $location_re, $app) = @$map;
          my $path = $path_info; # copy
          no warnings 'uninitialized';
          DEBUG && warn "Matching request (Host=$http_host Path=$path) and the map (Host=$host Path=$location)\n";
          next unless not defined $host     or
                      $http_host   eq $host or
                      $server_name eq $host;
          next unless $location eq '' or $path =~ s!$location_re!!;
          next unless $path eq '' or $path =~ m!^/!;
          DEBUG && warn "-> Matched!\n";
  
          my $orig_path_info   = $env->{PATH_INFO};
          my $orig_script_name = $env->{SCRIPT_NAME};
  
          $env->{PATH_INFO}  = $path;
          $env->{SCRIPT_NAME} = $script_name . $location;
          return $self->response_cb($app->($env), sub {
              $env->{PATH_INFO} = $orig_path_info;
              $env->{SCRIPT_NAME} = $orig_script_name;
          });
      }
  
      DEBUG && warn "All matching failed.\n";
  
      return [404, [ 'Content-Type' => 'text/plain' ], [ "Not Found" ]];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::URLMap - Map multiple apps in different paths
  
  =head1 SYNOPSIS
  
    use Plack::App::URLMap;
  
    my $app1 = sub { ... };
    my $app2 = sub { ... };
    my $app3 = sub { ... };
  
    my $urlmap = Plack::App::URLMap->new;
    $urlmap->map("/" => $app1);
    $urlmap->map("/foo" => $app2);
    $urlmap->map("http://bar.example.com/" => $app3);
  
    my $app = $urlmap->to_app;
  
  =head1 DESCRIPTION
  
  Plack::App::URLMap is a PSGI application that can dispatch multiple
  applications based on URL path and host names (a.k.a "virtual hosting")
  and takes care of rewriting C<SCRIPT_NAME> and C<PATH_INFO> (See
  L</"HOW THIS WORKS"> for details). This module is inspired by
  Ruby's Rack::URLMap.
  
  =head1 METHODS
  
  =over 4
  
  =item map
  
    $urlmap->map("/foo" => $app);
    $urlmap->map("http://bar.example.com/" => $another_app);
  
  Maps URL path or an absolute URL to a PSGI application. The match
  order is sorted by host name length and then path length (longest strings
  first).
  
  URL paths need to match from the beginning and should match completely
  until the path separator (or the end of the path). For example, if you
  register the path C</foo>, it I<will> match with the request C</foo>,
  C</foo/> or C</foo/bar> but it I<won't> match with C</foox>.
  
  Mapping URLs with host names is also possible, and in that case the URL
  mapping works like a virtual host.
  
  Mappings will nest.  If $app is already mapped to C</baz> it will
  match a request for C</foo/baz> but not C</foo>. See L</"HOW THIS
  WORKS"> for more details.
  
  =item mount
  
  Alias for C<map>.
  
  =item to_app
  
    my $handler = $urlmap->to_app;
  
  Returns the PSGI application code reference. Note that the
  Plack::App::URLMap object is callable (by overloading the code
  dereference), so returning the object itself as a PSGI application
  should also work.
  
  =back
  
  =head1 PERFORMANCE
  
  If you C<map> (or C<mount> with Plack::Builder) N applications,
  Plack::App::URLMap will need to at most iterate through N paths to
  match incoming requests.
  
  It is a good idea to use C<map> only for a known, limited amount of
  applications, since mounting hundreds of applications could affect
  runtime request performance.
  
  =head1 DEBUGGING
  
  You can set the environment variable C<PLACK_URLMAP_DEBUG> to see how
  this application matches with the incoming request host names and
  paths.
  
  =head1 HOW THIS WORKS
  
  This application works by I<fixing> C<SCRIPT_NAME> and C<PATH_INFO>
  before dispatching the incoming request to the relocated
  applications.
  
  Say you have a Wiki application that takes C</index> and C</page/*>
  and makes a PSGI application C<$wiki_app> out of it, using one of
  supported web frameworks, you can put the whole application under
  C</wiki> by:
  
    # MyWikiApp looks at PATH_INFO and handles /index and /page/*
    my $wiki_app = sub { MyWikiApp->run(@_) };
    
    use Plack::App::URLMap;
    my $app = Plack::App::URLMap->new;
    $app->mount("/wiki" => $wiki_app);
  
  When a request comes in with C<PATH_INFO> set to C</wiki/page/foo>,
  the URLMap application C<$app> strips the C</wiki> part from
  C<PATH_INFO> and B<appends> that to C<SCRIPT_NAME>.
  
  That way, if the C<$app> is mounted under the root
  (i.e. C<SCRIPT_NAME> is C<"">) with standalone web servers like
  L<Starman>, C<SCRIPT_NAME> is now locally set to C</wiki> and
  C<PATH_INFO> is changed to C</page/foo> when C<$wiki_app> gets called.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Builder>
  
  =cut
PLACK_APP_URLMAP

    $fatpacked{"Plack/App/WrapCGI.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_APP_WRAPCGI';
  package Plack::App::WrapCGI;
  use strict;
  use warnings;
  use parent qw(Plack::Component);
  use Plack::Util::Accessor qw(script execute _app);
  use File::Spec;
  use CGI::Emulate::PSGI;
  use CGI::Compile;
  use Carp;
  use POSIX ":sys_wait_h";
  
  sub slurp_fh {
      my $fh = $_[0];
      local $/;
      my $v = <$fh>;
      defined $v ? $v : '';
  }
  
  sub prepare_app {
      my $self = shift;
      my $script = $self->script
          or croak "'script' is not set";
  
      $script = File::Spec->rel2abs($script);
  
      if ($self->execute) {
          my $app = sub {
              my $env = shift;
  
              pipe( my $stdoutr, my $stdoutw );
              pipe( my $stdinr,  my $stdinw );
  
              local $SIG{CHLD} = 'DEFAULT';
  
              my $pid = fork();
              Carp::croak("fork failed: $!") unless defined $pid;
  
  
              if ($pid == 0) { # child
                  local $SIG{__DIE__} = sub {
                      print STDERR @_;
                      exit(1);
                  };
  
                  close $stdoutr;
                  close $stdinw;
  
                  local %ENV = (%ENV, CGI::Emulate::PSGI->emulate_environment($env));
  
                  open( STDOUT, ">&=" . fileno($stdoutw) )
                    or Carp::croak "Cannot dup STDOUT: $!";
                  open( STDIN, "<&=" . fileno($stdinr) )
                    or Carp::croak "Cannot dup STDIN: $!";
  
                  chdir(File::Basename::dirname($script));
                  exec($script) or Carp::croak("cannot exec: $!");
  
                  exit(2);
              }
  
              close $stdoutw;
              close $stdinr;
  
              syswrite($stdinw, slurp_fh($env->{'psgi.input'}));
              # close STDIN so child will stop waiting
              close $stdinw;
  
              my $res = ''; my $waited_pid;
              while (($waited_pid = waitpid($pid, WNOHANG)) == 0) {
                  $res .= slurp_fh($stdoutr);
              }
              $res .= slurp_fh($stdoutr);
  
              # -1 means that the child went away, and something else
              # (probably some global SIGCHLD handler) took care of it;
              # yes, we just reset $SIG{CHLD} above, but you can never
              # be too sure
              if (POSIX::WIFEXITED($?) || $waited_pid == -1) {
                  return CGI::Parse::PSGI::parse_cgi_output(\$res);
              } else {
                  Carp::croak("Error at run_on_shell CGI: $!");
              }
          };
          $self->_app($app);
      } else {
          my $sub = CGI::Compile->compile($script);
          my $app = CGI::Emulate::PSGI->handler($sub);
  
          $self->_app($app);
      }
  }
  
  sub call {
      my($self, $env) = @_;
      $self->_app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::WrapCGI - Compiles a CGI script as PSGI application
  
  =head1 SYNOPSIS
  
    use Plack::App::WrapCGI;
  
    my $app = Plack::App::WrapCGI->new(script => "/path/to/script.pl")->to_app;
  
    # if you want to execute as a real CGI script
    my $app = Plack::App::WrapCGI->new(script => "/path/to/script.rb", execute => 1)->to_app;
  
  =head1 DESCRIPTION
  
  Plack::App::WrapCGI compiles a CGI script into a PSGI application
  using L<CGI::Compile> and L<CGI::Emulate::PSGI>, and runs it with any
  PSGI server as a PSGI application.
  
  See also L<Plack::App::CGIBin> if you have a directory that contains a
  lot of CGI scripts and serve them like Apache's mod_cgi.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    my $app = Plack::App::WrapCGI->new(%args);
  
  Creates a new PSGI application using the given script. I<%args> has two
  parameters:
  
  =over 8
  
  =item script
  
  The path to a CGI-style program. This is a required parameter.
  
  =item execute
  
  An optional parameter. When set to a true value, this app will run the script
  with a CGI-style C<fork>/C<exec> model. Note that you may run programs written
  in other languages with this approach.
  
  =back
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::CGIBin>
  
  =cut
PLACK_APP_WRAPCGI

    $fatpacked{"Plack/Builder.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_BUILDER';
  package Plack::Builder;
  use strict;
  use parent qw( Exporter );
  our @EXPORT = qw( builder add enable enable_if mount );
  
  use Carp ();
  use Plack::App::URLMap;
  use Plack::Middleware::Conditional; # TODO delayed load?
  use Scalar::Util ();
  
  sub new {
      my $class = shift;
      bless { middlewares => [ ] }, $class;
  }
  
  sub add_middleware {
      my($self, $mw, @args) = @_;
  
      if (ref $mw ne 'CODE') {
          my $mw_class = Plack::Util::load_class($mw, 'Plack::Middleware');
          $mw = sub { $mw_class->wrap($_[0], @args) };
      }
  
      push @{$self->{middlewares}}, $mw;
  }
  
  sub add_middleware_if {
      my($self, $cond, $mw, @args) = @_;
  
      if (ref $mw ne 'CODE') {
          my $mw_class = Plack::Util::load_class($mw, 'Plack::Middleware');
          $mw = sub { $mw_class->wrap($_[0], @args) };
      }
  
      push @{$self->{middlewares}}, sub {
          Plack::Middleware::Conditional->wrap($_[0], condition => $cond, builder => $mw);
      };
  }
  
  # do you want remove_middleware() etc.?
  
  sub _mount {
      my ($self, $location, $app) = @_;
  
      if (!$self->{_urlmap}) {
          $self->{_urlmap} = Plack::App::URLMap->new;
      }
  
      $self->{_urlmap}->map($location => $app);
      $self->{_urlmap}; # for backward compat.
  }
  
  sub to_app {
      my($self, $app) = @_;
  
      if ($app) {
          $self->wrap($app);
      } elsif ($self->{_urlmap}) {
          $self->{_urlmap} = $self->{_urlmap}->to_app
              if Scalar::Util::blessed($self->{_urlmap});
          $self->wrap($self->{_urlmap});
      } else {
          Carp::croak("to_app() is called without mount(). No application to build.");
      }
  }
  
  sub wrap {
      my($self, $app) = @_;
  
      if ($self->{_urlmap} && $app ne $self->{_urlmap}) {
          Carp::carp("WARNING: wrap() and mount() can't be used altogether in Plack::Builder.\n" .
                     "WARNING: This causes all previous mount() mappings to be ignored.");
      }
  
      for my $mw (reverse @{$self->{middlewares}}) {
          $app = $mw->($app);
      }
  
      $app;
  }
  
  # DSL goes here
  our $_add = our $_add_if = our $_mount = sub {
      Carp::croak("enable/mount should be called inside builder {} block");
  };
  
  sub enable         { $_add->(@_) }
  sub enable_if(&$@) { $_add_if->(@_) }
  
  sub mount {
      my $self = shift;
      if (Scalar::Util::blessed($self)) {
          $self->_mount(@_);
      }else{
          $_mount->($self, @_);
      }
  }
  
  sub builder(&) {
      my $block = shift;
  
      my $self = __PACKAGE__->new;
  
      my $mount_is_called;
      my $urlmap = Plack::App::URLMap->new;
      local $_mount = sub {
          $mount_is_called++;
          $urlmap->map(@_);
          $urlmap;
      };
      local $_add = sub {
          $self->add_middleware(@_);
      };
      local $_add_if = sub {
          $self->add_middleware_if(@_);
      };
  
      my $app = $block->();
  
      if ($mount_is_called) {
          if ($app ne $urlmap) {
              Carp::carp("WARNING: You used mount() in a builder block, but the last line (app) isn't using mount().\n" .
                         "WARNING: This causes all mount() mappings to be ignored.\n");
          } else {
              $app = $app->to_app;
          }
      }
  
      $app = $app->to_app if $app and Scalar::Util::blessed($app) and $app->can('to_app');
  
      $self->to_app($app);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Builder - OO and DSL to enable Plack Middlewares
  
  =head1 SYNOPSIS
  
    # in .psgi
    use Plack::Builder;
  
    my $app = sub { ... };
  
    builder {
        enable "Deflater";
        enable "Session", store => "File";
        enable "Debug", panels => [ qw(DBITrace Memory Timer) ];
        enable "+My::Plack::Middleware";
        $app;
    };
  
    # use URLMap
  
    builder {
        mount "/foo" => builder {
            enable "Foo";
            $app;
        };
  
        mount "/bar" => $app2;
        mount "http://example.com/" => builder { $app3 };
    };
  
    # using OO interface
    my $builder = Plack::Builder->new;
    $builder->add_middleware('Foo', opt => 1);
    $builder->add_middleware('Bar');
    $builder->wrap($app);
  
  =head1 DESCRIPTION
  
  Plack::Builder gives you a quick domain specific language (DSL) to
  wrap your application with L<Plack::Middleware> subclasses. The
  middleware you're trying to use should use L<Plack::Middleware> as a
  base class to use this DSL, inspired by Rack::Builder.
  
  Whenever you call C<enable> on any middleware, the middleware app is
  pushed to the stack inside the builder, and then reversed when it
  actually creates a wrapped application handler. C<"Plack::Middleware::">
  is added as a prefix by default. So:
  
    builder {
        enable "Foo";
        enable "Bar", opt => "val";
        $app;
    };
  
  is syntactically equal to:
  
    $app = Plack::Middleware::Bar->wrap($app, opt => "val");
    $app = Plack::Middleware::Foo->wrap($app);
  
  In other words, you're supposed to C<enable> middleware from outer to inner.
  
  =head1 INLINE MIDDLEWARE
  
  Plack::Builder allows you to code middleware inline using a nested
  code reference.
  
  If the first argument to C<enable> is a code reference, it will be
  passed an C<$app> and should return another code reference
  which is a PSGI application that consumes C<$env> at runtime. So:
  
    builder {
        enable sub {
            my $app = shift;
            sub {
                my $env = shift;
                # do preprocessing
                my $res = $app->($env);
                # do postprocessing
                return $res;
            };
        };
        $app;
    };
  
  is equal to:
  
    my $mw = sub {
        my $app = shift;
        sub { my $env = shift; $app->($env) };
    };
  
    $app = $mw->($app);
  
  =head1 URLMap support
  
  Plack::Builder has a native support for L<Plack::App::URLMap> via the C<mount> method.
  
    use Plack::Builder;
    my $app = builder {
        mount "/foo" => $app1;
        mount "/bar" => builder {
            enable "Foo";
            $app2;
        };
    };
  
  See L<Plack::App::URLMap>'s C<map> method to see what they mean. With
  C<builder> you can't use C<map> as a DSL, for the obvious reason :)
  
  B<NOTE>: Once you use C<mount> in your builder code, you have to use
  C<mount> for all the paths, including the root path (C</>). You can't
  have the default app in the last line of C<builder> like:
  
    my $app = sub {
        my $env = shift;
        ...
    };
  
    builder {
        mount "/foo" => sub { ... };
        $app; # THIS DOESN'T WORK
    };
  
  You'll get warnings saying that your mount configuration will be
  ignored. Instead you should use C<< mount "/" => ... >> in the last
  line to set the default fallback app.
  
    builder {
        mount "/foo" => sub { ... };
        mount "/" => $app;
    }
  
  Note that the C<builder> DSL returns a whole new PSGI application, which means
  
  =over 4
  
  =item *
  
  C<builder { ... }> should normally be the last statement of a C<.psgi>
  file, because the return value of C<builder> is the application that
  is actually executed.
  
  =item *
  
  You can nest your C<builder> blocks, mixed with C<mount> statements (see L</"URLMap support">
  above):
  
    builder {
        mount "/foo" => builder {
            mount "/bar" => $app;
        }
    }
  
  will locate the C<$app> under C</foo/bar>, since the inner C<builder>
  block puts it under C</bar> and it results in a new PSGI application
  which is located under C</foo> because of the outer C<builder> block.
  
  =back
  
  =head1 CONDITIONAL MIDDLEWARE SUPPORT
  
  You can use C<enable_if> to conditionally enable middleware based on
  the runtime environment.
  
    builder {
        enable_if { $_[0]->{REMOTE_ADDR} eq '127.0.0.1' } 'StackTrace', force => 1;
        $app;
    };
  
  See L<Plack::Middleware::Conditional> for details.
  
  =head1 OBJECT ORIENTED INTERFACE
  
  Object oriented interface supports the same functionality with the DSL
  version in a clearer interface, probably with more typing required.
  
    # With mount
    my $builder = Plack::Builder->new;
    $builder->add_middleware('Foo', opt => 1);
    $builder->mount('/foo' => $foo_app);
    $builder->mount('/' => $root_app);
    $builder->to_app;
  
    # Nested builders. Equivalent to:
    # builder {
    #     mount '/foo' => builder {
    #         enable 'Foo';
    #         $app;
    #     };
    #     mount '/' => $app2;
    # };
    my $builder_out = Plack::Builder->new;
    my $builder_in  = Plack::Builder->new;
    $builder_in->add_middleware('Foo');
    $builder_out->mount("/foo" => $builder_in->wrap($app));
    $builder_out->mount("/" => $app2);
    $builder_out->to_app;
  
    # conditional. You can also directly use Plack::Middleware::Conditional
    my $builder = Plack::Builder->new;
    $builder->add_middleware_if(sub { $_[0]->{REMOTE_ADDR} eq '127.0.0.1' }, 'StackTrace');
    $builder->wrap($app);
  
  =head1 SEE ALSO
  
  L<Plack::Middleware> L<Plack::App::URLMap> L<Plack::Middleware::Conditional>
  
  =cut
  
  
  
PLACK_BUILDER

    $fatpacked{"Plack/Component.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_COMPONENT';
  package Plack::Component;
  use strict;
  use warnings;
  use Carp ();
  use Plack::Util;
  use overload '&{}' => \&to_app_auto, fallback => 1;
  
  sub new {
      my $proto = shift;
      my $class = ref $proto || $proto;
  
      my $self;
      if (@_ == 1 && ref $_[0] eq 'HASH') {
          $self = bless {%{$_[0]}}, $class;
      } else {
          $self = bless {@_}, $class;
      }
  
      $self;
  }
  
  sub to_app_auto {
      my $self = shift;
      if (($ENV{PLACK_ENV} || '') eq 'development') {
          my $class = ref($self);
          warn "WARNING: Automatically converting $class instance to a PSGI code reference. " .
            "If you see this warning for each request, you probably need to explicitly call " .
            "to_app() i.e. $class->new(...)->to_app in your PSGI file.\n";
      }
      $self->to_app(@_);
  }
  
  # NOTE:
  # this is for back-compat only,
  # future modules should use
  # Plack::Util::Accessor directly
  # or their own favorite accessor
  # generator.
  # - SL
  sub mk_accessors {
      my $self = shift;
      Plack::Util::Accessor::mk_accessors( ref( $self ) || $self, @_ )
  }
  
  sub prepare_app { return }
  
  sub to_app {
      my $self = shift;
      $self->prepare_app;
      return sub { $self->call(@_) };
  }
  
  
  sub response_cb {
      my($self, $res, $cb) = @_;
      Plack::Util::response_cb($res, $cb);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Component - Base class for PSGI endpoints
  
  =head1 SYNOPSIS
  
    package Plack::App::Foo;
    use parent qw( Plack::Component );
  
    sub call {
        my($self, $env) = @_;
        # Do something with $env
  
        my $res = ...; # create a response ...
  
        # return the response
        return $res;
    }
  
  =head1 DESCRIPTION
  
  Plack::Component is the base class shared between L<Plack::Middleware>
  and C<Plack::App::*> modules. If you are writing middleware, you should
  inherit from L<Plack::Middleware>, but if you are writing a
  Plack::App::* you should inherit from this directly.
  
  =head1 REQUIRED METHOD
  
  =over 4
  
  =item call ($env)
  
  You are expected to implement a C<call> method in your component. This
  is where all the work gets done. It receives the PSGI C<$env> hash-ref
  as an argument and is expected to return a proper PSGI response value.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item new (%opts | \%opts)
  
  The constructor accepts either a hash or a hashref and uses that to
  create the instance. It will call no other methods and simply return
  the instance that is created.
  
  =item prepare_app
  
  This method is called by C<to_app> and is meant as a hook to be used to
  prepare your component before it is packaged as a PSGI C<$app>.
  
  =item to_app
  
  This is the method used in several parts of the Plack infrastructure to
  convert your component into a PSGI C<$app>. You should not ever need to
  override this method; it is recommended to use C<prepare_app> and C<call>
  instead.
  
  =item response_cb
  
  This is a wrapper for C<response_cb> in L<Plack::Util>. See
  L<Plack::Middleware/RESPONSE CALLBACK> for details.
  
  =back
  
  =head1 OBJECT LIFECYCLE
  
  Objects for the derived classes (Plack::App::* or
  Plack::Middleware::*) are created at the PSGI application compile
  phase using C<new>, C<prepare_app> and C<to_app>, and the created
  object persists during the web server lifecycle, unless it is running
  on the non-persistent environment like CGI. C<call> is invoked against
  the same object whenever a new request comes in.
  
  You can check if it is running in a persistent environment by checking
  C<psgi.run_once> key in the C<$env> being true (non-persistent) or
  false (persistent), but it is best for you to write your middleware
  safely for a persistent environment. To accomplish that, you should
  avoid saving per-request data like C<$env> in your object.
  
  =head1 BACKWARDS COMPATIBILITY
  
  The L<Plack::Middleware> module used to inherit from L<Class::Accessor::Fast>,
  which has been removed in favor of the L<Plack::Util::Accessor> module. When
  developing new components it is recommended to use L<Plack::Util::Accessor>
  like so:
  
    use Plack::Util::Accessor qw( foo bar baz );
  
  However, in order to keep backwards compatibility this module provides a
  C<mk_accessors> method similar to L<Class::Accessor::Fast>. New code should
  not use this and use L<Plack::Util::Accessor> instead.
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Builder> L<Plack::Middleware>
  
  =cut
PLACK_COMPONENT

    $fatpacked{"Plack/HTTPParser.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_HTTPPARSER';
  package Plack::HTTPParser;
  use strict;
  use parent qw(Exporter);
  
  our @EXPORT = qw( parse_http_request );
  
  use Try::Tiny;
  
  {
      if (!$ENV{PLACK_HTTP_PARSER_PP} && try { require HTTP::Parser::XS; 1 }) {
          *parse_http_request = \&HTTP::Parser::XS::parse_http_request;
      } else {
          require Plack::HTTPParser::PP;
          *parse_http_request = \&Plack::HTTPParser::PP::parse_http_request;
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::HTTPParser - Parse HTTP headers
  
  =head1 SYNOPSIS
  
    use Plack::HTTPParser qw(parse_http_request);
  
    my $ret = parse_http_request($header_str, \%env);
    # see HTTP::Parser::XS docs
  
  =head1 DESCRIPTION
  
  Plack::HTTPParser is a wrapper class to dispatch C<parse_http_request>
  to Kazuho Oku's XS based HTTP::Parser::XS or pure perl fallback based
  on David Robins HTTP::Parser.
  
  If you want to force the use of the slower pure perl version even if the
  fast XS version is available, set the environment variable
  C<PLACK_HTTP_PARSER_PP> to 1.
  
  =head1 SEE ALSO
  
  L<HTTP::Parser::XS> L<HTTP::Parser>
  
  =cut
PLACK_HTTPPARSER

    $fatpacked{"Plack/HTTPParser/PP.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_HTTPPARSER_PP';
  package Plack::HTTPParser::PP;
  use strict;
  use warnings;
  use URI::Escape;
  
  sub parse_http_request {
      my($chunk, $env) = @_;
      $env ||= {};
  
      # pre-header blank lines are allowed (RFC 2616 4.1)
      $chunk =~ s/^(\x0d?\x0a)+//;
      return -2 unless length $chunk;
  
      # double line break indicates end of header; parse it
      if ($chunk =~ /^(.*?\x0d?\x0a\x0d?\x0a)/s) {
          return _parse_header($chunk, length $1, $env);
      }
      return -2;  # still waiting for unknown amount of header lines
  }
  
  sub _parse_header {
      my($chunk, $eoh, $env) = @_;
  
      my $header = substr($chunk, 0, $eoh,'');
      $chunk =~ s/^\x0d?\x0a\x0d?\x0a//;
  
      # parse into lines
      my @header  = split /\x0d?\x0a/,$header;
      my $request = shift @header;
  
      # join folded lines
      my @out;
      for(@header) {
          if(/^[ \t]+/) {
              return -1 unless @out;
              $out[-1] .= $_;
          } else {
              push @out, $_;
          }
      }
  
      # parse request or response line
      my $obj;
      my ($major, $minor);
  
      my ($method,$uri,$http) = split / /,$request;
      return -1 unless $http and $http =~ /^HTTP\/(\d+)\.(\d+)$/i;
      ($major, $minor) = ($1, $2);
  
      $env->{REQUEST_METHOD}  = $method;
      $env->{SERVER_PROTOCOL} = "HTTP/$major.$minor";
      $env->{REQUEST_URI}     = $uri;
  
      my($path, $query) = ( $uri =~ /^([^?]*)(?:\?(.*))?$/s );
      for ($path, $query) { s/\#.*$// if defined && length } # dumb clients sending URI fragments
  
      $env->{PATH_INFO}    = URI::Escape::uri_unescape($path);
      $env->{QUERY_STRING} = $query || '';
      $env->{SCRIPT_NAME}  = '';
  
      # import headers
      my $token = qr/[^][\x00-\x1f\x7f()<>@,;:\\"\/?={} \t]+/;
      my $k;
      for my $header (@out) {
          if ( $header =~ s/^($token): ?// ) {
              $k = $1;
              $k =~ s/-/_/g;
              $k = uc $k;
  
              if ($k !~ /^(?:CONTENT_LENGTH|CONTENT_TYPE)$/) {
                  $k = "HTTP_$k";
              }
          } elsif ( $header =~ /^\s+/) {
              # multiline header
          } else {
              return -1;
          }
  
          if (exists $env->{$k}) {
              $env->{$k} .= ", $header";
          } else {
              $env->{$k} = $header;
          }
      }
  
      return $eoh;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::HTTPParser::PP - Pure perl fallback of HTTP::Parser::XS
  
  =head1 DESCRIPTION
  
  Do not use this module directly. Use L<Plack::HTTPParser> instead.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
  
PLACK_HTTPPARSER_PP

    $fatpacked{"Plack/Handler.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_HANDLER';
  package Plack::Handler;
  use strict;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler - Connects PSGI applications and Web servers
  
  =head1 SYNOPSIS
  
    package Plack::Handler::AwesomeWebServer;
    sub new {
        my($class, %opt) = @_;
        ...
        return $self;
    }
  
    sub run {
        my($self, $app) = @_;
        # launch the AwesomeWebServer and run $app in the loop
    }
  
    # then from command line
    plackup -s AwesomeWebServer -a app.psgi
  
  =head1 DESCRIPTION
  
  Plack::Handler defines an adapter (connector) interface to adapt
  L<plackup> and L<Plack::Runner> to various PSGI web servers, such as
  Apache2 for mod_perl and Standalone for L<HTTP::Server::PSGI>.
  
  It is an empty class, and as long as they implement the methods
  defined as an Server adapter interface, they do not need to inherit
  Plack::Handler.
  
  If you write a new handler for existing web servers, I recommend you
  to include the full name of the server module after I<Plack::Handler>
  prefix, like L<Plack::Handler::Net::Server::Coro> if you write a
  handler for L<Net::Server::Coro>. That way you'll be using plackup
  command line option like:
  
    plackup -s Net::Server::Coro
  
  that makes it easy to figure out which web server you're going to use.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $server = FooBarServer->new(%args);
  
  Creates a new adapter object. I<%args> can take arbitrary parameters
  to configure server environments but common parameters are:
  
  =over 8
  
  =item port
  
  Port number the server listens to.
  
  =item host
  
  Address the server listens to. Set to undef to listen any interface.
  
  =back
  
  =item run
  
    $server->run($app);
  
  Starts the server process and when a request comes in, run the PSGI
  application passed in C<$app> in the loop.
  
  =item register_service
  
    $server->register_service($app);
  
  Optional interface if your server should run in parallel with other
  event loop, particularly L<AnyEvent>. This is the same as C<run> but
  doesn't run the main loop.
  
  =back
  
  =head1 SEE ALSO
  
  rackup
  
  =cut
  
PLACK_HANDLER

    $fatpacked{"Plack/Handler/Apache1.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_HANDLER_APACHE1';
  package Plack::Handler::Apache1;
  use strict;
  use Apache::Request;
  use Apache::Constants qw(:common :response);
  
  use Plack::Util;
  use Scalar::Util;
  
  my %apps; # psgi file to $app mapping
  
  sub new { bless {}, shift }
  
  sub preload {
      my $class = shift;
      for my $app (@_) {
          $class->load_app($app);
      }
  }
  
  sub load_app {
      my($class, $app) = @_;
      return $apps{$app} ||= do {
          # Trick Catalyst, CGI.pm, CGI::Cookie and others that check
          # for $ENV{MOD_PERL}.
          #
          # Note that we delete it instead of just localizing
          # $ENV{MOD_PERL} because some users may check if the key
          # exists, and we do it this way because "delete local" is new
          # in 5.12:
          # http://perldoc.perl.org/5.12.0/perldelta.html#delete-local
          local $ENV{MOD_PERL};
          delete $ENV{MOD_PERL};
  
          Plack::Util::load_psgi $app;
      };
  }
  
  sub handler {
      my $class = __PACKAGE__;
      my $r     = shift;
      my $psgi  = $r->dir_config('psgi_app');
      $class->call_app($r, $class->load_app($psgi));
  }
  
  sub call_app {
      my ($class, $r, $app) = @_;
  
      $r->subprocess_env; # let Apache create %ENV for us :)
  
      my $env = {
          %ENV,
          'psgi.version'        => [ 1, 1 ],
          'psgi.url_scheme'     => ($ENV{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
          'psgi.input'          => $r,
          'psgi.errors'         => *STDERR,
          'psgi.multithread'    => Plack::Util::FALSE,
          'psgi.multiprocess'   => Plack::Util::TRUE,
          'psgi.run_once'       => Plack::Util::FALSE,
          'psgi.streaming'      => Plack::Util::TRUE,
          'psgi.nonblocking'    => Plack::Util::FALSE,
          'psgix.harakiri'      => Plack::Util::TRUE,
      };
  
      if (defined(my $HTTP_AUTHORIZATION = $r->headers_in->{Authorization})) {
          $env->{HTTP_AUTHORIZATION} = $HTTP_AUTHORIZATION;
      }
  
      my $vpath    = $env->{SCRIPT_NAME} . ($env->{PATH_INFO} || '');
  
      my $location = $r->location || "/";
         $location =~ s{/$}{};
      (my $path_info = $vpath) =~ s/^\Q$location\E//;
  
      $env->{SCRIPT_NAME} = $location;
      $env->{PATH_INFO}   = $path_info;
  
      my $res = $app->($env);
  
      if (ref $res eq 'ARRAY') {
          _handle_response($r, $res);
      }
      elsif (ref $res eq 'CODE') {
          $res->(sub {
              _handle_response($r, $_[0]);
          });
      }
      else {
          die "Bad response $res";
      }
  
      if ($env->{'psgix.harakiri.commit'}) {
          $r->child_terminate;
      }
  
      return OK;
  }
  
  sub _handle_response {
      my ($r, $res) = @_;
      my ($status, $headers, $body) = @{ $res };
  
      my $hdrs = ($status >= 200 && $status < 300)
          ? $r->headers_out : $r->err_headers_out;
  
      Plack::Util::header_iter($headers, sub {
          my($h, $v) = @_;
          if (lc $h eq 'content-type') {
              $r->content_type($v);
          } else {
              $hdrs->add($h => $v);
          }
      });
  
      $r->status($status);
      $r->send_http_header;
  
      if (defined $body) {
          if (Plack::Util::is_real_fh($body)) {
              $r->send_fd($body);
          } else {
              Plack::Util::foreach($body, sub { $r->print(@_) });
          }
      }
      else {
          return Plack::Util::inline_object
              write => sub { $r->print(@_) },
              close => sub { };
      }
  }
  
  1;
  
  __END__
  
  
  =head1 NAME
  
  Plack::Handler::Apache1 - Apache 1.3.x mod_perl handlers to run PSGI application
  
  =head1 SYNOPSIS
  
    <Location />
    SetHandler perl-script
    PerlHandler Plack::Handler::Apache1
    PerlSetVar psgi_app /path/to/app.psgi
    </Location>
  
    <Perl>
    use Plack::Handler::Apache1;
    Plack::Handler::Apache1->preload("/path/to/app.psgi");
    </Perl>
  
  =head1 DESCRIPTION
  
  This is a mod_perl handler module to run any PSGI application with mod_perl on Apache 1.3.x.
  
  If you want to run PSGI applications I<behind> Apache instead of using
  mod_perl, see L<Plack::Handler::FCGI> to run with FastCGI, or use
  standalone HTTP servers such as L<Starman> or L<Starlet> proxied with
  mod_proxy.
  
  =head1 AUTHOR
  
  Aaron Trevena
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_HANDLER_APACHE1

    $fatpacked{"Plack/Handler/Apache2.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_HANDLER_APACHE2';
  package Plack::Handler::Apache2;
  use strict;
  use warnings;
  use Apache2::RequestRec;
  use Apache2::RequestIO;
  use Apache2::RequestUtil;
  use Apache2::Response;
  use Apache2::Const -compile => qw(OK);
  use Apache2::Log;
  use APR::Table;
  use IO::Handle;
  use Plack::Util;
  use Scalar::Util;
  use URI;
  use URI::Escape;
  
  my %apps; # psgi file to $app mapping
  
  sub new { bless {}, shift }
  
  sub preload {
      my $class = shift;
      for my $app (@_) {
          $class->load_app($app);
      }
  }
  
  sub load_app {
      my($class, $app) = @_;
      return $apps{$app} ||= do {
          # Trick Catalyst, CGI.pm, CGI::Cookie and others that check
          # for $ENV{MOD_PERL}.
          #
          # Note that we delete it instead of just localizing
          # $ENV{MOD_PERL} because some users may check if the key
          # exists, and we do it this way because "delete local" is new
          # in 5.12:
          # http://perldoc.perl.org/5.12.0/perldelta.html#delete-local
          local $ENV{MOD_PERL};
          delete $ENV{MOD_PERL};
  
          Plack::Util::load_psgi $app;
      };
  }
  
  sub call_app {
      my ($class, $r, $app) = @_;
  
      $r->subprocess_env; # let Apache create %ENV for us :)
  
      my $env = {
          %ENV,
          'psgi.version'           => [ 1, 1 ],
          'psgi.url_scheme'        => ($ENV{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
          'psgi.input'             => $r,
          'psgi.errors'            => *STDERR,
          'psgi.multithread'       => Plack::Util::FALSE,
          'psgi.multiprocess'      => Plack::Util::TRUE,
          'psgi.run_once'          => Plack::Util::FALSE,
          'psgi.streaming'         => Plack::Util::TRUE,
          'psgi.nonblocking'       => Plack::Util::FALSE,
          'psgix.harakiri'         => Plack::Util::TRUE,
          'psgix.cleanup'          => Plack::Util::TRUE,
          'psgix.cleanup.handlers' => [],
      };
  
      if (defined(my $HTTP_AUTHORIZATION = $r->headers_in->{Authorization})) {
          $env->{HTTP_AUTHORIZATION} = $HTTP_AUTHORIZATION;
      }
  
      # If you supply more than one Content-Length header Apache will
      # happily concat the values with ", ", e.g. "72, 72". This
      # violates the PSGI spec so fix this up and just take the first
      # one.
      if (exists $env->{CONTENT_LENGTH} && $env->{CONTENT_LENGTH} =~ /,/) {
          no warnings qw(numeric);
          $env->{CONTENT_LENGTH} = int $env->{CONTENT_LENGTH};
      }
  
      # Actually, we can not trust PATH_INFO from mod_perl because mod_perl squeezes multiple slashes into one slash.
      my $uri = URI->new("http://".$r->hostname.$r->unparsed_uri);
  
      $env->{PATH_INFO} = uri_unescape($uri->path);
  
      $class->fixup_path($r, $env);
  
      my $res = $app->($env);
  
      if (ref $res eq 'ARRAY') {
          _handle_response($r, $res);
      }
      elsif (ref $res eq 'CODE') {
          $res->(sub {
              _handle_response($r, $_[0]);
          });
      }
      else {
          die "Bad response $res";
      }
  
      if (@{ $env->{'psgix.cleanup.handlers'} }) {
          $r->push_handlers(
              PerlCleanupHandler => sub {
                  for my $cleanup_handler (@{ $env->{'psgix.cleanup.handlers'} }) {
                      $cleanup_handler->($env);
                  }
  
                  if ($env->{'psgix.harakiri.commit'}) {
                      $r->child_terminate;
                  }
              },
          );
      } else {
          if ($env->{'psgix.harakiri.commit'}) {
              $r->child_terminate;
          }
      }
  
      return Apache2::Const::OK;
  }
  
  sub handler {
      my $class = __PACKAGE__;
      my $r     = shift;
      my $psgi  = $r->dir_config('psgi_app');
      $class->call_app($r, $class->load_app($psgi));
  }
  
  # The method for PH::Apache2::Registry to override.
  sub fixup_path {
      my ($class, $r, $env) = @_;
  
      # $env->{PATH_INFO} is created from unparsed_uri so it is raw.
      my $path_info = $env->{PATH_INFO} || '';
  
      # Get argument of <Location> or <LocationMatch> directive
      # This may be string or regexp and we can't know either.
      my $location = $r->location;
  
      # Let's *guess* if we're in a LocationMatch directive
      if ($location eq '/') {
          # <Location /> could be handled as a 'root' case where we make
          # everything PATH_INFO and empty SCRIPT_NAME as in the PSGI spec
          $env->{SCRIPT_NAME} = '';
      } elsif ($path_info =~ s{^($location)/?}{/}) {
          $env->{SCRIPT_NAME} = $1 || '';
      } else {
          # Apache's <Location> is matched but here is not.
          # This is something wrong. We can only respect original.
          $r->server->log_error(
              "Your request path is '$path_info' and it doesn't match your Location(Match) '$location'. " .
              "This should be due to the configuration error. See perldoc Plack::Handler::Apache2 for details."
          );
      }
  
      $env->{PATH_INFO}   = $path_info;
  }
  
  sub _handle_response {
      my ($r, $res) = @_;
  
      my ($status, $headers, $body) = @{ $res };
  
      my $hdrs = ($status >= 200 && $status < 300)
          ? $r->headers_out : $r->err_headers_out;
  
      Plack::Util::header_iter($headers, sub {
          my($h, $v) = @_;
          if (lc $h eq 'content-type') {
              $r->content_type($v);
          } elsif (lc $h eq 'content-length') {
              $r->set_content_length($v);
          } else {
              $hdrs->add($h => $v);
          }
      });
  
      $r->status($status);
  
      if (Scalar::Util::blessed($body) and $body->can('path') and my $path = $body->path) {
          $r->sendfile($path);
      } elsif (defined $body) {
          Plack::Util::foreach($body, sub { $r->print(@_) });
          $r->rflush;
      }
      else {
          return Plack::Util::inline_object
              write => sub { $r->print(@_); $r->rflush },
              close => sub { $r->rflush };
      }
  
      return Apache2::Const::OK;
  }
  
  1;
  
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  Plack::Handler::Apache2 - Apache 2.0 mod_perl handler to run PSGI application
  
  =head1 SYNOPSIS
  
    # in your httpd.conf
    <Location />
    SetHandler perl-script
    PerlResponseHandler Plack::Handler::Apache2
    PerlSetVar psgi_app /path/to/app.psgi
    </Location>
  
    # Optionally preload your apps in startup
    PerlPostConfigRequire /etc/httpd/startup.pl
  
  See L</STARTUP FILE> for more details on writing a C<startup.pl>.
  
  =head1 DESCRIPTION
  
  This is a mod_perl handler module to run any PSGI application with mod_perl on Apache 2.x.
  
  If you want to run PSGI applications I<behind> Apache instead of using
  mod_perl, see L<Plack::Handler::FCGI> to run with FastCGI, or use
  standalone HTTP servers such as L<Starman> or L<Starlet> proxied with
  mod_proxy.
  
  =head1 CREATING CUSTOM HANDLER
  
  If you want to create a custom handler that loads or creates PSGI
  applications using other means than loading from C<.psgi> files, you
  can create your own handler class and use C<call_app> class method to
  run your application.
  
    package My::ModPerl::Handler;
    use Plack::Handler::Apache2;
  
    sub get_app {
      # magic!
    }
  
    sub handler {
      my $r = shift;
      my $app = get_app();
      Plack::Handler::Apache2->call_app($r, $app);
    }
  
  =head1 STARTUP FILE
  
  Here is an example C<startup.pl> to preload PSGI applications:
  
      #!/usr/bin/env perl
  
      use strict;
      use warnings;
      use Apache2::ServerUtil ();
  
      BEGIN {
          return unless Apache2::ServerUtil::restart_count() > 1;
  
          require lib;
          lib->import('/path/to/my/perl/libs');
  
          require Plack::Handler::Apache2;
  
          my @psgis = ('/path/to/app1.psgi', '/path/to/app2.psgi');
          foreach my $psgi (@psgis) {
              Plack::Handler::Apache2->preload($psgi);
          }
      }
  
      1; # file must return true!
  
  See L<http://perl.apache.org/docs/2.0/user/handlers/server.html#Startup_File>
  for general information on the C<startup.pl> file for preloading perl modules
  and your apps.
  
  Some things to keep in mind when writing this file:
  
  =over 4
  
  =item * multiple init phases
  
  You have to check that L<Apache2::ServerUtil/restart_count> is C<< > 1 >>,
  otherwise your app will load twice and the env vars you set with
  L<PerlSetEnv|http://perl.apache.org/docs/2.0/user/config/config.html#C_PerlSetEnv_>
  will not be available when your app is loading the first time.
  
  Use the example above as a template.
  
  =item * C<@INC>
  
  The C<startup.pl> file is a good place to add entries to your C<@INC>.
  Use L<lib> to add entries, they can be in your app or C<.psgi> as well, but if
  your modules are in a L<local::lib> or some such, you will need to add the path
  for anything to load.
  
  Alternately, if you follow the example above, you can use:
  
      PerlSetEnv PERL5LIB /some/path
  
  or
  
      PerlSwitches -I/some/path
  
  in your C<httpd.conf>, which will also work.
  
  =item * loading errors
  
  Any exceptions thrown in your C<startup.pl> will stop Apache from starting at
  all.
  
  You probably don't want a stray syntax error to bring your whole server down in
  a shared or development environment, in which case it's a good idea to wrap the
  L</preload> call in an eval, using something like this:
  
      require Plack::Handler::Apache2;
  
      my @psgis = ('/path/to/app1.psgi', '/path/to/app2.psgi');
  
      foreach my $psgi (@psgis) {
          eval {
              Plack::Handler::Apache2->preload($psgi); 1;
          } or do {
              my $error = $@ || 'Unknown Error';
              # STDERR goes to the error_log
              print STDERR "Failed to load psgi '$psgi': $error\n";
          };
      }
  
  
  =item * dynamically loaded modules
  
  Some modules load their dependencies at runtime via e.g. L<Class::Load>. These
  modules will not get preloaded into your parent process by just including the
  app/module you are using.
  
  As an optimization, you can dump C<%INC> from a request to see if you are using
  any such modules and preload them in your C<startup.pl>.
  
  Another method is dumping the difference between the C<%INC> on
  process start and process exit. You can use something like this to
  accomplish this:
  
      my $start_inc = { %INC };
  
      END {
          my @m;
          foreach my $m (keys %INC) {
              push @m, $m unless exists $start_inc->{$m};
          }
  
          if (@m) {
              # STDERR goes to the error_log
              print STDERR "The following modules need to be preloaded:\n";
              print STDERR "$_\n" for @m;
          }
      }
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 CONTRIBUTORS
  
  Paul Driver
  
  var Arnfjr Bjarmason
  
  Rafael Kitover
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
PLACK_HANDLER_APACHE2

    $fatpacked{"Plack/Handler/Apache2/Registry.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_HANDLER_APACHE2_REGISTRY';
  package Plack::Handler::Apache2::Registry;
  use strict;
  use warnings;
  use Try::Tiny;
  use Apache2::Const;
  use Apache2::Log;
  use parent qw/Plack::Handler::Apache2/;
  
  sub handler {
      my $class = __PACKAGE__;
      my ($r) = @_;
  
      return try {
          my $app = $class->load_app( $r->filename );
          $class->call_app( $r, $app );
      }catch{
          if(/no such file/i){
              $r->log_error( $_ );
              return Apache2::Const::NOT_FOUND;
          }else{
              $r->log_error( $_ );
              return Apache2::Const::SERVER_ERROR;
          }
      };
  }
  
  # Overriding
  sub fixup_path {
      my ($class, $r, $env) = @_;
      $env->{PATH_INFO} =~ s{^$env->{SCRIPT_NAME}}{};
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::Apache2::Registry - Runs .psgi files.
  
  =head1 SYNOPSIS
  
    PerlModule Plack::Handler::Apache2::Registry;
    <Location /psgi-bin>
    SetHandler modperl
    PerlHandler Plack::Handler::Apache2::Registry
    </Location>
  
  =head1 DESCRIPTION
  
  This is a handler module to run any *.psgi files with mod_perl2,
  just like ModPerl::Registry.
  
  =head1 AUTHOR
  
  Masahiro Honma E<lt>hiratara@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Plack::Handler::Apache2>
  
  =cut
  
PLACK_HANDLER_APACHE2_REGISTRY

    $fatpacked{"Plack/Handler/CGI.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_HANDLER_CGI';
  package Plack::Handler::CGI;
  use strict;
  use warnings;
  use IO::Handle;
  
  # copied from HTTP::Status
  my %StatusCode = (
      100 => 'Continue',
      101 => 'Switching Protocols',
      102 => 'Processing',                      # RFC 2518 (WebDAV)
      103 => 'Early Hints',
      200 => 'OK',
      201 => 'Created',
      202 => 'Accepted',
      203 => 'Non-Authoritative Information',
      204 => 'No Content',
      205 => 'Reset Content',
      206 => 'Partial Content',
      207 => 'Multi-Status',                    # RFC 2518 (WebDAV)
      300 => 'Multiple Choices',
      301 => 'Moved Permanently',
      302 => 'Found',
      303 => 'See Other',
      304 => 'Not Modified',
      305 => 'Use Proxy',
      307 => 'Temporary Redirect',
      400 => 'Bad Request',
      401 => 'Unauthorized',
      402 => 'Payment Required',
      403 => 'Forbidden',
      404 => 'Not Found',
      405 => 'Method Not Allowed',
      406 => 'Not Acceptable',
      407 => 'Proxy Authentication Required',
      408 => 'Request Timeout',
      409 => 'Conflict',
      410 => 'Gone',
      411 => 'Length Required',
      412 => 'Precondition Failed',
      413 => 'Request Entity Too Large',
      414 => 'Request-URI Too Large',
      415 => 'Unsupported Media Type',
      416 => 'Request Range Not Satisfiable',
      417 => 'Expectation Failed',
      422 => 'Unprocessable Entity',            # RFC 2518 (WebDAV)
      423 => 'Locked',                          # RFC 2518 (WebDAV)
      424 => 'Failed Dependency',               # RFC 2518 (WebDAV)
      425 => 'No code',                         # WebDAV Advanced Collections
      426 => 'Upgrade Required',                # RFC 2817
      449 => 'Retry with',                      # unofficial Microsoft
      500 => 'Internal Server Error',
      501 => 'Not Implemented',
      502 => 'Bad Gateway',
      503 => 'Service Unavailable',
      504 => 'Gateway Timeout',
      505 => 'HTTP Version Not Supported',
      506 => 'Variant Also Negotiates',         # RFC 2295
      507 => 'Insufficient Storage',            # RFC 2518 (WebDAV)
      509 => 'Bandwidth Limit Exceeded',        # unofficial
      510 => 'Not Extended',                    # RFC 2774
  );
  
  sub new { bless {}, shift }
  
  sub run {
      my ($self, $app) = @_;
  
      my $env = $self->setup_env();
  
      my $res = $app->($env);
      if (ref $res eq 'ARRAY') {
          $self->_handle_response($res);
      }
      elsif (ref $res eq 'CODE') {
          $res->(sub {
              $self->_handle_response($_[0]);
          });
      }
      else {
          die "Bad response $res";
      }
  }
  
  sub setup_env {
      my ( $self, $override_env ) = @_;
  
      $override_env ||= {};
  
      binmode STDIN;
      binmode STDERR;
  
      my $env = {
          %ENV,
          'psgi.version'    => [ 1, 1 ],
          'psgi.url_scheme' => ($ENV{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
          'psgi.input'      => *STDIN,
          'psgi.errors'     => *STDERR,
          'psgi.multithread'  => 0,
          'psgi.multiprocess' => 1,
          'psgi.run_once'     => 1,
          'psgi.streaming'    => 1,
          'psgi.nonblocking'  => 1,
          %{ $override_env },
      };
  
      delete $env->{HTTP_CONTENT_TYPE};
      delete $env->{HTTP_CONTENT_LENGTH};
      $env->{'HTTP_COOKIE'} ||= $ENV{COOKIE}; # O'Reilly server bug
  
      if (!exists $env->{PATH_INFO}) {
          $env->{PATH_INFO} = '';
      }
  
      if ($env->{SCRIPT_NAME} eq '/') {
          $env->{SCRIPT_NAME} = '';
          $env->{PATH_INFO}   = '/' . $env->{PATH_INFO};
      }
  
      return $env;
  }
  
  
  
  sub _handle_response {
      my ($self, $res) = @_;
  
      *STDOUT->autoflush(1);
      binmode STDOUT;
  
      my $hdrs;
      my $message = $StatusCode{$res->[0]};
      $hdrs = "Status: $res->[0] $message\015\012";
  
      my $headers = $res->[1];
      while (my ($k, $v) = splice(@$headers, 0, 2)) {
          $hdrs .= "$k: $v\015\012";
      }
      $hdrs .= "\015\012";
  
      print STDOUT $hdrs;
  
      my $body = $res->[2];
      my $cb = sub { print STDOUT $_[0] };
  
      # inline Plack::Util::foreach here
      if (ref $body eq 'ARRAY') {
          for my $line (@$body) {
              $cb->($line) if length $line;
          }
      }
      elsif (defined $body) {
          local $/ = \65536 unless ref $/;
          while (defined(my $line = $body->getline)) {
              $cb->($line) if length $line;
          }
          $body->close;
      }
      else {
          return Plack::Handler::CGI::Writer->new;
      }
  }
  
  package Plack::Handler::CGI::Writer;
  sub new   { bless \do { my $x }, $_[0] }
  sub write { print STDOUT $_[1] }
  sub close { }
  
  package Plack::Handler::CGI;
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Handler::CGI - CGI handler for Plack
  
  =head1 SYNOPSIS
  
  Want to run PSGI application as a CGI script? Rename .psgi to .cgi and
  change the shebang line like:
  
    #!/usr/bin/env plackup
    # rest of the file can be the same as other .psgi file
  
  You can alternatively create a .cgi file that contains something like:
  
    #!/usr/bin/perl
    use Plack::Loader;
    my $app = Plack::Util::load_psgi("/path/to/app.psgi");
    Plack::Loader->auto->run($app);
  
  This will auto-recognize the CGI environment variable to load this class.
  
  If you really want to explicitly load the CGI handler, you can. For instance
  you might do this when you want to embed a PSGI application server built into
  CGI-compatible perl-based web server:
  
    use Plack::Handler::CGI;
    Plack::Handler::CGI->new->run($app);
  
  =head1 DESCRIPTION
  
  This is a handler module to run any PSGI application as a CGI script.
  
  =head1 UTILITY METHODS
  
  =head2 setup_env()
  
    my $env = Plack::Handler::CGI->setup_env();
    my $env = Plack::Handler::CGI->setup_env(\%override_env);
  
  Sets up the PSGI environment hash for a CGI request from C<< %ENV >>> and returns it.
  You can provide a hashref of key/value pairs to override the defaults if you would like.
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
  
PLACK_HANDLER_CGI

    $fatpacked{"Plack/Handler/FCGI.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_HANDLER_FCGI';
  package Plack::Handler::FCGI;
  use strict;
  use warnings;
  use constant RUNNING_IN_HELL => $^O eq 'MSWin32';
  
  use Scalar::Util qw(blessed);
  use Plack::Util;
  use FCGI;
  use HTTP::Status qw(status_message);
  use URI;
  use URI::Escape;
  
  sub new {
      my $class = shift;
      my $self  = bless {@_}, $class;
  
      $self->{leave_umask} ||= 0;
      $self->{keep_stderr} ||= 0;
      $self->{nointr}      ||= 0;
      $self->{daemonize}   ||= $self->{detach}; # compatibility
      $self->{nproc}       ||= 1 unless blessed $self->{manager};
      $self->{pid}         ||= $self->{pidfile}; # compatibility
      $self->{listen}      ||= [ ":$self->{port}" ] if $self->{port}; # compatibility
      $self->{backlog}     ||= 100;
      $self->{manager}     = 'FCGI::ProcManager' unless exists $self->{manager};
  
      $self;
  }
  
  sub run {
      my ($self, $app) = @_;
  
      my $running_on_server_starter = exists $ENV{SERVER_STARTER_PORT};
      my $sock = 0;
      if (-S STDIN) {
          # running from web server. Do nothing
          # Note it should come before listen check because of plackup's default
      } elsif ($running_on_server_starter) {
          # Runing under Server::Starter
          require Server::Starter;
          my %socks = %{Server::Starter::server_ports()};
          if (scalar(keys(%socks)) > 1) {
              die "More than one socket are specified by Server::Starter";
          }
          $sock = (values %socks)[0];
      } elsif ($self->{listen}) {
          my $old_umask = umask;
          unless ($self->{leave_umask}) {
              umask(0);
          }
          $sock = FCGI::OpenSocket( $self->{listen}->[0], $self->{backlog} )
              or die "failed to open FastCGI socket: $!";
          unless ($self->{leave_umask}) {
              umask($old_umask);
          }
      } elsif (!RUNNING_IN_HELL) {
          die "STDIN is not a socket: specify a listen location";
      }
  
      @{$self}{qw(stdin stdout stderr)} 
        = (IO::Handle->new, IO::Handle->new, IO::Handle->new);
  
      my %env;
      my $request = FCGI::Request(
          $self->{stdin}, $self->{stdout}, $self->{stderr},
          \%env, $sock,
          ($self->{nointr} ? 0 : &FCGI::FAIL_ACCEPT_ON_INTR),
      );
  
      my $proc_manager;
  
      if ($self->{listen} or $running_on_server_starter) {
          $self->daemon_fork if $self->{daemonize};
  
          if ($self->{manager}) {
              if (blessed $self->{manager}) {
                  for (qw(nproc pid proc_title)) {
                      die "Don't use '$_' when passing in a 'manager' object"
                          if $self->{$_};
                  }
                  $proc_manager = $self->{manager};
              } else {
                  Plack::Util::load_class($self->{manager});
                  $proc_manager = $self->{manager}->new({
                      n_processes => $self->{nproc},
                      pid_fname   => $self->{pid},
                      (exists $self->{proc_title}
                           ? (pm_title => $self->{proc_title}) : ()),
                  });
              }
  
              # detach *before* the ProcManager inits
              $self->daemon_detach if $self->{daemonize};
          }
          elsif ($self->{daemonize}) {
              $self->daemon_detach;
          }
      } elsif (blessed $self->{manager}) {
          $proc_manager = $self->{manager};
      }
  
      $proc_manager && $proc_manager->pm_manage;
  
      while ($request->Accept >= 0) {
          $proc_manager && $proc_manager->pm_pre_dispatch;
  
          my $env = {
              %env,
              'psgi.version'      => [1,1],
              'psgi.url_scheme'   => ($env{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
              'psgi.input'        => $self->{stdin},
              'psgi.errors'       => 
                  ($self->{keep_stderr} ? \*STDERR : $self->{stderr}),
              'psgi.multithread'  => Plack::Util::FALSE,
              'psgi.multiprocess' => defined $proc_manager,
              'psgi.run_once'     => Plack::Util::FALSE,
              'psgi.streaming'    => Plack::Util::TRUE,
              'psgi.nonblocking'  => Plack::Util::FALSE,
              'psgix.harakiri'    => defined $proc_manager,
              'psgix.cleanup'     => 1,
              'psgix.cleanup.handlers' => [],
          };
  
          delete $env->{HTTP_CONTENT_TYPE};
          delete $env->{HTTP_CONTENT_LENGTH};
  
          # lighttpd munges multiple slashes in PATH_INFO into one. Try recovering it
          my $uri = URI->new("http://localhost" .  $env->{REQUEST_URI});
          $env->{PATH_INFO} = uri_unescape($uri->path);
          $env->{PATH_INFO} =~ s/^\Q$env->{SCRIPT_NAME}\E//;
  
          # root access for mod_fastcgi
          if (!exists $env->{PATH_INFO}) {
              $env->{PATH_INFO} = '';
          }
  
          # typical fastcgi_param from nginx might get empty values
          for my $key (qw(CONTENT_TYPE CONTENT_LENGTH)) {
              no warnings;
              delete $env->{$key} if exists $env->{$key} && $env->{$key} eq '';
          }
  
          if (defined(my $HTTP_AUTHORIZATION = $env->{Authorization})) {
              $env->{HTTP_AUTHORIZATION} = $HTTP_AUTHORIZATION;
          }
  
          my $res = Plack::Util::run_app $app, $env;
  
          if (ref $res eq 'ARRAY') {
              $self->_handle_response($res);
          }
          elsif (ref $res eq 'CODE') {
              $res->(sub {
                  $self->_handle_response($_[0]);
              });
          }
          else {
              die "Bad response $res";
          }
  
          # give pm_post_dispatch the chance to do things after the client thinks
          # the request is done
          $request->Finish;
  
          $proc_manager && $proc_manager->pm_post_dispatch();
  
          # When the fcgi-manager exits it sends a TERM signal to the workers.
          # However, if we're busy processing the cleanup handlers, testing
          # shows that the worker doesn't actually exit in that case.
          # Trapping the TERM signal and finshing up fixes that.
          my $exit_due_to_signal = 0;
          if ( @{ $env->{'psgix.cleanup.handlers'} || [] } ) {
              local $SIG{TERM} = sub { $exit_due_to_signal = 1 };
              for my $handler ( @{ $env->{'psgix.cleanup.handlers'} } ) {
                  $handler->($env);
              }
          }
  
          if ($proc_manager && $env->{'psgix.harakiri.commit'}) {
              $proc_manager->pm_exit("safe exit with harakiri");
          }
          elsif ($exit_due_to_signal) {
              $proc_manager && $proc_manager->pm_exit("safe exit due to signal");
              exit;    # want to exit, even without a $proc_manager
          }
      }
  }
  
  sub _handle_response {
      my ($self, $res) = @_;
  
      $self->{stdout}->autoflush(1);
      binmode $self->{stdout};
  
      my $hdrs;
      my $message = status_message($res->[0]);
      $hdrs = "Status: $res->[0] $message\015\012";
  
      my $headers = $res->[1];
      while (my ($k, $v) = splice @$headers, 0, 2) {
          $hdrs .= "$k: $v\015\012";
      }
      $hdrs .= "\015\012";
  
      print { $self->{stdout} } $hdrs;
  
      my $cb = sub { print { $self->{stdout} } $_[0] };
      my $body = $res->[2];
      if (defined $body) {
          Plack::Util::foreach($body, $cb);
      }
      else {
          return Plack::Util::inline_object
              write => $cb,
              close => sub { };
      }
  }
  
  sub daemon_fork {
      require POSIX;
      fork && exit;
  }
  
  sub daemon_detach {
      my $self = shift;
      print "FastCGI daemon started (pid $$)\n";
      open STDIN,  "+</dev/null" or die $!; ## no critic
      open STDOUT, ">&STDIN"     or die $!;
      open STDERR, ">&STDIN"     or die $!;
      POSIX::setsid();
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::FCGI - FastCGI handler for Plack
  
  =head1 SYNOPSIS
  
    # Run as a standalone daemon
    plackup -s FCGI --listen /tmp/fcgi.sock --daemonize --nproc 10
  
    # Run from your web server like mod_fastcgi
    #!/usr/bin/env plackup -s FCGI
    my $app = sub { ... };
  
    # Roll your own
    my $server = Plack::Handler::FCGI->new(
        nproc  => $num_proc,
        listen => [ $port_or_socket ],
        detach => 1,
    );
    $server->run($app);
  
  
  =head1 DESCRIPTION
  
  This is a handler module to run any PSGI application as a standalone
  FastCGI daemon or a .fcgi script.
  
  =head2 OPTIONS
  
  =over 4
  
  =item listen
  
      listen => [ '/path/to/socket' ]
      listen => [ ':8080' ]
  
  Listen on a socket path, hostname:port, or :port.
  
  =item port
  
  listen via TCP on port on all interfaces (Same as C<< listen => ":$port" >>)
  
  =item leave-umask
  
  Set to 1 to disable setting umask to 0 for socket open
  
  =item nointr
  
  Do not allow the listener to be interrupted by Ctrl+C
  
  =item nproc
  
  Specify a number of processes for FCGI::ProcManager
  
  =item pid
  
  Specify a filename for the pid file
  
  =item manager
  
  Specify either a FCGI::ProcManager subclass, or an actual FCGI::ProcManager-compatible object.
  If you do not want a FCGI::ProcManager but instead run in a single process, set this to undef.
  
    use FCGI::ProcManager::Dynamic;
    Plack::Handler::FCGI->new(
        manager => FCGI::ProcManager::Dynamic->new(...),
    );
  
  =item daemonize
  
  Daemonize the process.
  
  =item proc-title
  
  Specify process title
  
  =item keep-stderr
  
  Send psgi.errors to STDERR instead of to the FCGI error stream.
  
  =item backlog
  
  Maximum length of the queue of pending connections, defaults to 100.
  
  =back
  
  =head2 EXTENSIONS
  
  Supported L<PSGI::Extensions>.
  
  =over 4
  
  =item psgix.cleanup
  
      push @{ $env->{'psgix.cleanup.handlers'} }, sub { warn "Did this later" }
          if $env->{'psgix.cleanup'};
  
  Supports the C<psgix.cleanup> extension,
  in order to use it, just push a callback onto
  C<< $env->{'psgix.cleanup.handlers' >>.
  These callbacks are run after the C<pm_post_dispatch> hook.
  
  =item psgix.harakiri
  
      $env->{'psgix.harakiri.commit'} = 1
          if $env->{'psgix.harakiri'};
  
  If there is a L</manager>, then C<psgix.harakiri> will be enabled
  and setting C<< $env->{'psgix.harakiri.commit'} >> to a true value
  will cause C<< $manager->pm_exit >> to be called after the
  request is finished.
  
  =back
  
  =head2 WEB SERVER CONFIGURATIONS
  
  In all cases, you will want to install L<FCGI> and L<FCGI::ProcManager>.
  You may find it most convenient to simply install L<Task::Plack> which
  includes both of these.
  
  =head3 nginx
  
  This is an example nginx configuration to run your FCGI daemon on a
  Unix domain socket and run it at the server's root URL (/).
  
    http {
      server {
        listen 3001;
        location / {
          set $script "";
          set $path_info $uri;
          fastcgi_pass unix:/tmp/fastcgi.sock;
          fastcgi_param  SCRIPT_NAME      $script;
          fastcgi_param  PATH_INFO        $path_info;
          fastcgi_param  QUERY_STRING     $query_string;
          fastcgi_param  REQUEST_METHOD   $request_method;
          fastcgi_param  CONTENT_TYPE     $content_type;
          fastcgi_param  CONTENT_LENGTH   $content_length;
          fastcgi_param  REQUEST_URI      $request_uri;
          fastcgi_param  SERVER_PROTOCOL  $server_protocol;
          fastcgi_param  REMOTE_ADDR      $remote_addr;
          fastcgi_param  REMOTE_PORT      $remote_port;
          fastcgi_param  SERVER_ADDR      $server_addr;
          fastcgi_param  SERVER_PORT      $server_port;
          fastcgi_param  SERVER_NAME      $server_name;
        }
      }
    }
  
  If you want to host your application in a non-root path, then you
  should mangle this configuration to set the path to C<SCRIPT_NAME> and
  the rest of the path in C<PATH_INFO>.
  
  See L<https://www.nginx.com/resources/wiki/start/topics/examples/fastcgiexample/> for more details.
  
  =head3 Apache mod_fastcgi
  
  After installing C<mod_fastcgi>, you should add the C<FastCgiExternalServer>
  directive to your Apache config:
  
    FastCgiExternalServer /tmp/myapp.fcgi -socket /tmp/fcgi.sock
  
    ## Then set up the location that you want to be handled by fastcgi:
  
    # EITHER from a given path
    Alias /myapp/ /tmp/myapp.fcgi/
  
    # OR at the root
    Alias / /tmp/myapp.fcgi/
  
  Now you can use plackup to listen to the socket that you've just configured in Apache.
  
    $  plackup -s FCGI --listen /tmp/myapp.sock psgi/myapp.psgi
  
  The above describes the "standalone" method, which is usually appropriate.
  There are other methods, described in more detail at 
  L<Catalyst::Engine::FastCGI/Standalone_server_mode> (with regards to Catalyst, but which may be set up similarly for Plack).
  
  See also L<http://www.fastcgi.com/mod_fastcgi/docs/mod_fastcgi.html#FastCgiExternalServer>
  for more details.
  
  =head3 lighttpd
  
  To host the app in the root path, you're recommended to use lighttpd
  1.4.23 or newer with C<fix-root-scriptname> flag like below.
  
    fastcgi.server = ( "/" =>
       ((
         "socket" => "/tmp/fcgi.sock",
         "check-local" => "disable",
         "fix-root-scriptname" => "enable",
       ))
  
  If you use lighttpd older than 1.4.22 where you don't have
  C<fix-root-scriptname>, mounting apps under the root causes wrong
  C<SCRIPT_NAME> and C<PATH_INFO> set. Also, mounting under the empty
  root (C<"">) or a path that has a trailing slash would still cause
  weird values set even with C<fix-root-scriptname>. In such cases you
  can use L<Plack::Middleware::LighttpdScriptNameFix> to fix it.
  
  To mount in the non-root path over TCP:
  
    fastcgi.server = ( "/foo" =>
       ((
         "host" = "127.0.0.1",
         "port" = "5000",
         "check-local" => "disable",
       ))
  
  It's recommended that your mount path does B<NOT> have the trailing
  slash. If you I<really> need to have one, you should consider using
  L<Plack::Middleware::LighttpdScriptNameFix> to fix the wrong
  B<PATH_INFO> values set by lighttpd.
  
  =cut
  
  =head2 Authorization
  
  Most fastcgi configuration does not pass C<Authorization> headers to
  C<HTTP_AUTHORIZATION> environment variable by default for security
  reasons. Authentication middleware such as L<Plack::Middleware::Auth::Basic> or
  L<Catalyst::Authentication::Credential::HTTP> requires the variable to
  be set up. Plack::Handler::FCGI supports extracting the C<Authorization> environment
  variable when it is configured that way.
  
  Apache2 with mod_fastcgi:
  
    --pass-header Authorization
  
  mod_fcgid:
  
    FcgidPassHeader Authorization
  
  =head2 Server::Starter
  
  This plack handler supports L<Server::Starter> as a superdaemon.
  Simply launch plackup from start_server with a path option.
  The listen option is ignored when launched from Server::Starter.
  
    start_server --path=/tmp/socket -- plackup -s FCGI app.psgi 
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_HANDLER_FCGI

    $fatpacked{"Plack/Handler/HTTP/Server/PSGI.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_HANDLER_HTTP_SERVER_PSGI';
  package Plack::Handler::HTTP::Server::PSGI;
  use strict;
  
  # for temporary backward compat
  use parent qw( HTTP::Server::PSGI );
  
  sub new {
      my($class, %args) = @_;
      bless { %args }, $class;
  }
  
  sub run {
      my($self, $app) = @_;
      $self->_server->run($app);
  }
  
  sub _server {
      my $self = shift;
      HTTP::Server::PSGI->new(%$self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::HTTP::Server::PSGI - adapter for HTTP::Server::PSGI
  
  =head1 SYNOPSIS
  
    % plackup -s HTTP::Server::PSGI \
        --host 127.0.0.1 --port 9091 --timeout 120
  
  =head1 BACKWARD COMPATIBLITY
  
  Since Plack 0.99_22 this handler doesn't support preforking
  configuration i.e. C<--max-workers>. Use L<Starman> or L<Starlet> if
  you need preforking PSGI web server.
  
  =head1 CONFIGURATIONS
  
  =over 4
  
  =item host
  
  Host the server binds to. Defaults to all interfaces.
  
  =item port
  
  Port number the server listens on. Defaults to 8080.
  
  =item timeout
  
  Number of seconds a request times out. Defaults to 300.
  
  =item max-reqs-per-child
  
  Number of requests per worker to process. Defaults to 100.
  
  =back
  
  =head1 AUTHOR
  
  Kazuho Oku
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack> L<HTTP::Server::PSGI>
  
  =cut
PLACK_HANDLER_HTTP_SERVER_PSGI

    $fatpacked{"Plack/Handler/Standalone.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_HANDLER_STANDALONE';
  package Plack::Handler::Standalone;
  use strict;
  use warnings;
  use parent qw( Plack::Handler::HTTP::Server::PSGI );
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::Standalone - adapter for HTTP::Server::PSGI
  
  =head1 SYNOPSIS
  
    % plackup -s Standalone \
        --host 127.0.0.1 --port 9091 --timeout 120
  
  =head1 DESCRIPTION
  
  Plack::Handler::Standalone is an adapter for default Plack server
  implementation L<HTTP::Server::PSGI>. This is just an alias for
  L<Plack::Handler::HTTP::Server::PSGI>.
  
  =head1 SEE ALSO
  
  L<Plack::Handler::HTTP::Server::PSGI>
  
  =cut
PLACK_HANDLER_STANDALONE

    $fatpacked{"Plack/Handler/Starlight.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_HANDLER_STARLIGHT';
  package Plack::Handler::Starlight;
  
  =head1 NAME
  
  Plack::Handler::Starlight - Plack adapter for Starlight
  
  =head1 SYNOPSIS
  
  =for markdown ```perl
  
      use Plack::Loader;
  
      my $loader = Plack::Loader->load('Starlight', port => 80);
      $loader->run(sub { [200, ['Content-Type', 'text/plain'], ['PSGI app']] });
  
  =for markdown ```
  
  =head1 DESCRIPTION
  
  This is a stub module that allows Starlight to be loaded up under L<plackup>
  and other L<Plack> tools. Set C<$ENV{PLACK_SERVER}> to C<'Starlight'> or use
  the -s parameter to L<plackup> to use Starlight under L<Plack>.
  
  See L<plackup> and L<starlight> (lower case) for available command line
  options.
  
  =cut
  
  use strict;
  use warnings;
  
  our $VERSION = '0.0501';
  
  use base qw(Starlight::Server);
  
  use Config ();
  use English '-no_match_vars';
  use Fcntl ();
  use File::Spec;
  use POSIX ();
  use Plack::Util;
  
  use constant HAS_WIN32_PROCESS => $^O eq 'cygwin' && eval { require Win32::Process; 1; } && 1;
  
  use constant DEBUG => $ENV{PERL_STARLIGHT_DEBUG};
  
  sub new {
      my ($class, %args) = @_;
  
      # setup before instantiation
      my $max_workers = 10;
      for (qw(max_workers workers)) {
          $max_workers = delete $args{$_}
              if defined $args{$_};
      }
  
      # instantiate and set the variables
      my $self = $class->SUPER::new(%args);
      if ($^O eq 'MSWin32') {
  
          # forks are emulated
          $self->{is_multithread} = Plack::Util::TRUE;
          $self->{is_multiprocess} = Plack::Util::FALSE;
      } else {
  
          # real forks
          $self->{is_multithread} = Plack::Util::FALSE;
          $self->{is_multiprocess} = Plack::Util::TRUE;
      }
      $self->{max_workers} = $max_workers;
  
      $self->{main_process} = $$;
      $self->{processes} = +{};
  
      $self->{_kill_stalled_processes_delay} = 10;
  
      $self;
  }
  
  sub run {
      my ($self, $app) = @_;
  
      $self->_daemonize();
  
      warn "*** starting main process $$" if DEBUG;
      $self->setup_listener();
  
      $self->_setup_privileges();
  
      local $SIG{PIPE} = 'IGNORE';
  
      local $SIG{CHLD} = sub {
          my ($sig) = @_;
          warn "*** SIG$sig received in process $$" if DEBUG;
          local ($!, $?);
          my $pid = waitpid(-1, &POSIX::WNOHANG);    ## no critic
          return if $pid == -1;
          delete $self->{processes}->{$pid};
      };
  
      my $sigint = $self->{_sigint};
      my $sigterm = $^O eq 'MSWin32' ? 'KILL' : 'TERM';
  
      if ($self->{max_workers} != 0) {
          local $SIG{$sigint} = local $SIG{TERM} = sub {
              my ($sig) = @_;
              warn "*** SIG$sig received in process $$" if DEBUG;
              $self->{term_received}++;
          };
          for (my $loop = 0; not $self->{term_received}; $loop++) {
              warn "*** running ", scalar keys %{ $self->{processes} }, " processes" if DEBUG;
              if ($loop >= $self->{_kill_stalled_processes_delay} / ($self->{main_process_delay} || 1)) {
                  $loop = 0;
  
                  # check stalled processes once per n sec
                  foreach my $pid (keys %{ $self->{processes} }) {
                      delete $self->{processes}->{$pid} if not kill 0, $pid;
                  }
              }
              foreach my $n (1 + scalar keys %{ $self->{processes} } .. $self->{max_workers}) {
                  $self->_create_process($app);
                  $self->_sleep($self->{spawn_interval});
              }
  
              # slow down main process
              $self->_sleep($self->{main_process_delay});
          }
          if (my @pids = keys %{ $self->{processes} }) {
              warn "*** stopping ", scalar @pids, " processes" if DEBUG;
              foreach my $pid (@pids) {
                  warn "*** stopping process $pid" if DEBUG;
                  kill $sigterm, $pid;
              }
              if (HAS_WIN32_PROCESS) {
                  $self->_sleep(1);
                  foreach my $pid (keys %{ $self->{processes} }) {
                      my $winpid = Cygwin::pid_to_winpid($pid) or next;
                      warn "*** terminating process $pid winpid $winpid" if DEBUG;
                      Win32::Process::KillProcess($winpid, 0);
                  }
              }
              $self->_sleep(1);
              foreach my $pid (keys %{ $self->{processes} }) {
                  warn "*** waiting for process ", $pid if DEBUG;
                  waitpid $pid, 0;
              }
          }
          if ($^O eq 'cygwin' and not HAS_WIN32_PROCESS) {
              warn "Win32::Process is not installed. Some processes might be still active.\n";
          }
          warn "*** stopping main process $$" if DEBUG;
          exit 0;
      } else {
  
          # run directly, mainly for debugging
          local $SIG{$sigint} = local $SIG{TERM} = sub {
              my ($sig) = @_;
              warn "*** SIG$sig received in process $$" if DEBUG;
              exit 0;
          };
          while (1) {
              $self->accept_loop($app, $self->_calc_reqs_per_child());
              $self->_sleep($self->{spawn_interval});
          }
      }
  }
  
  1;
  
  __END__
  
  =head1 SEE ALSO
  
  L<starlight>,
  L<Starlight>,
  L<Plack>,
  L<Plack::Runner>.
  
  =head1 LICENSE
  
  Copyright (c) 2013-2016, 2020, 2023 Piotr Roszatycki <dexter@cpan.org>.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as perl itself.
  
  See L<http://dev.perl.org/licenses/artistic.html>
PLACK_HANDLER_STARLIGHT

    $fatpacked{"Plack/Handler/Thrall.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_HANDLER_THRALL';
  package Plack::Handler::Thrall;
  
  =head1 NAME
  
  Plack::Handler::Thrall - Plack adapter for Thrall
  
  =head1 SYNOPSIS
  
  =for markdown ```perl
  
      use Plack::Loader;
  
      my $loader = Plack::Loader->load('Thrall', port => 80);
      $loader->run(sub { [200, ['Content-Type', 'text/plain'], ['PSGI app']] });
  
  =for markdown ```
  
  =head1 DESCRIPTION
  
  This is a stub module that allows Thrall to be loaded up under L<plackup>
  and other L<Plack> tools. Set C<$ENV{PLACK_SERVER}> to C<'Thrall'> or use
  the -s parameter to L<plackup> to use Thrall under L<Plack>.
  
  See L<plackup> and L<thrall> (lower case) for available command line
  options.
  
  =cut
  
  use strict;
  use warnings;
  
  our $VERSION = '0.0402';
  
  use base qw(Thrall::Server);
  
  use threads;
  
  use Config ();
  use English '-no_match_vars';
  use Fcntl ();
  use File::Spec;
  use POSIX ();
  use Plack::Util;
  
  use constant DEBUG => $ENV{PERL_THRALL_DEBUG};
  
  sub new {
      my ($class, %args) = @_;
  
      # setup before instantiation
      my $max_workers = 10;
      for (qw(max_workers workers)) {
          $max_workers = delete $args{$_}
              if defined $args{$_};
      }
  
      # instantiate and set the variables
      my $self = $class->SUPER::new(%args);
  
      $self->{is_multithread} = Plack::Util::TRUE;
      $self->{is_multiprocess} = Plack::Util::FALSE;
  
      $self->{max_workers} = $max_workers;
  
      $self->{main_thread} = threads->tid;
      $self->{processes} = +{};
  
      $self->{_kill_stalled_processes_delay} = 10;
  
      $self;
  }
  
  sub run {
      my ($self, $app) = @_;
  
      $self->_daemonize();
  
      # EV does not work with threads
      $ENV{PERL_ANYEVENT_MODEL} = 'Perl';
      $ENV{PERL_ANYEVENT_IO_MODEL} = 'Perl';
  
      warn "*** starting main thread ", threads->tid if DEBUG;
      $self->setup_listener();
  
      $self->_setup_privileges();
  
      # Threads don't like simple 'IGNORE'
      local $SIG{PIPE} = sub { 'IGNORE' };
  
      my $sigint = $self->{_sigint};
      my $sigterm = $^O eq 'MSWin32' ? 'KILL' : 'TERM';
  
      if ($self->{max_workers} != 0) {
          if ($self->{thread_stack_size}) {
              threads->set_stack_size($self->{thread_stack_size});
          }
          local $SIG{$sigint} = local $SIG{TERM} = sub {
              my ($sig) = @_;
              warn "*** SIG$sig received in thread ", threads->tid if DEBUG;
              $self->{term_received}++;
              if (threads->tid) {
                  $self->{main_thread}->kill('TERM');
                  foreach my $thr (threads->list(threads::running)) {
                      $thr->kill('TERM') if $thr->tid != threads->tid;
                  }
              }
          };
          foreach my $n (1 .. $self->{max_workers}) {
              $self->_create_thread($app);
              $self->_sleep($self->{spawn_interval});
          }
          while (not $self->{term_received}) {
              warn "*** running ", scalar threads->list, " threads" if DEBUG;
              foreach my $thr (threads->list(threads::joinable)) {
                  warn "*** wait for thread ", $thr->tid if DEBUG;
                  eval { $thr->detach; };
                  warn $@ if $@;
                  $self->_create_thread($app);
                  $self->_sleep($self->{spawn_interval});
              }
  
              # slow down main thread
              $self->_sleep($self->{main_thread_delay});
          }
          foreach my $thr (threads->list) {
              $thr->detach;
          }
          warn "*** stopping main thread ", threads->tid if DEBUG;
          exit 0;
      } else {
  
          # run directly, mainly for debugging
          local $SIG{$sigint} = local $SIG{TERM} = sub {
              my ($sig) = @_;
              warn "*** SIG$sig received in thread ", threads->tid if DEBUG;
              exit 0;
          };
          while (1) {
              $self->accept_loop($app, $self->_calc_reqs_per_child());
              $self->_sleep($self->{spawn_interval});
          }
      }
  }
  
  1;
  
  __END__
  
  =head1 SEE ALSO
  
  L<thrall>,
  L<Thrall>,
  L<Plack>,
  L<Plack::Runner>.
  
  =head1 LICENSE
  
  Copyright (c) 2013-2016, 2023 Piotr Roszatycki <dexter@cpan.org>.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as perl itself.
  
  See L<http://dev.perl.org/licenses/artistic.html>
PLACK_HANDLER_THRALL

    $fatpacked{"Plack/LWPish.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_LWPISH';
  package Plack::LWPish;
  use strict;
  use warnings;
  use HTTP::Tiny;
  use HTTP::Response;
  use Hash::MultiValue;
  
  sub new {
      my $class = shift;
      my $self  = bless {}, $class;
      $self->{http} = @_ == 1 ? $_[0] : HTTP::Tiny->new(verify_SSL => 1, @_);
      $self;
  }
  
  sub request {
      my($self, $req) = @_;
  
      my @headers;
      $req->headers->scan(sub { push @headers, @_ });
  
      my $options = {
          headers => Hash::MultiValue->new(@headers)->mixed,
      };
      $options->{content} = $req->content if defined $req->content && length($req->content);
  
      my $response = $self->{http}->request($req->method, $req->url, $options);
  
      my $res = HTTP::Response->new(
          $response->{status},
          $response->{reason},
          [ Hash::MultiValue->from_mixed($response->{headers})->flatten ],
          $response->{content},
      );
      $res->request($req);
  
      return $res;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::LWPish - HTTP::Request/Response compatible interface with HTTP::Tiny backend
  
  =head1 SYNOPSIS
  
    use Plack::LWPish;
  
    my $request = HTTP::Request->new(GET => 'http://perl.com/');
  
    my $ua = Plack::LWPish->new;
    my $res = $ua->request($request); # returns HTTP::Response
  
  =head1 DESCRIPTION
  
  This module is an adapter object that implements one method,
  C<request> that acts like L<LWP::UserAgent>'s request method
  i.e. takes HTTP::Request object and returns HTTP::Response object.
  
  This module is used solely inside L<Plack::Test::Suite> and
  L<Plack::Test::Server>, and you are recommended to take a look at
  L<HTTP::Thin> if you would like to use this outside Plack.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<HTTP::Thin> L<HTTP::Tiny> L<LWP::UserAgent>
  
  =cut
PLACK_LWPISH

    $fatpacked{"Plack/Loader.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_LOADER';
  package Plack::Loader;
  use strict;
  use Carp ();
  use Plack::Util;
  use Try::Tiny;
  
  sub new {
      my $class = shift;
      bless {}, $class;
  }
  
  sub watch {
      # do nothing. Override in subclass
  }
  
  sub auto {
      my($class, @args) = @_;
  
      my $backend = $class->guess
          or Carp::croak("Couldn't auto-guess server server implementation. Set it with PLACK_SERVER");
  
      my $server = try {
          $class->load($backend, @args);
      } catch {
          if (($ENV{PLACK_ENV}||'') eq 'development' or !/^Can't locate /) {
              warn "Autoloading '$backend' backend failed. Falling back to the Standalone. ",
                  "(You might need to install Plack::Handler::$backend from CPAN.  Caught error was: $_)\n"
                      if $ENV{PLACK_ENV} && $ENV{PLACK_ENV} eq 'development';
          }
          $class->load('Standalone' => @args);
      };
  
      return $server;
  }
  
  sub load {
      my($class, $server, @args) = @_;
  
      my($server_class, $error);
      try {
          $server_class = Plack::Util::load_class($server, 'Plack::Handler');
      } catch {
          $error ||= $_;
      };
  
      if ($server_class) {
          $server_class->new(@args);
      } else {
          die $error;
      }
  }
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{app} = $builder->();
  }
  
  sub guess {
      my $class = shift;
  
      my $env = $class->env;
  
      return $env->{PLACK_SERVER} if $env->{PLACK_SERVER};
  
      if ($env->{PHP_FCGI_CHILDREN} || $env->{FCGI_ROLE} || $env->{FCGI_SOCKET_PATH}) {
          return "FCGI";
      } elsif ($env->{GATEWAY_INTERFACE}) {
          return "CGI";
      } elsif (exists $INC{"Coro.pm"}) {
          return "Corona";
      } elsif (exists $INC{"AnyEvent.pm"}) {
          return "Twiggy";
      } elsif (exists $INC{"POE.pm"}) {
          return "POE";
      } else {
          return "Standalone";
      }
  }
  
  sub env { \%ENV }
  
  sub run {
      my($self, $server) = @_;
      $server->run($self->{app});
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader - (auto)load Plack Servers
  
  =head1 SYNOPSIS
  
    # auto-select server backends based on env vars
    use Plack::Loader;
    Plack::Loader->auto(%args)->run($app);
  
    # specify the implementation with a name
    Plack::Loader->load('FCGI', %args)->run($app);
  
  =head1 DESCRIPTION
  
  Plack::Loader is a factory class to load one of Plack::Handler subclasses based on the environment.
  
  =head1 AUTOLOADING
  
  C<< Plack::Loader->auto(%args) >> will autoload the most correct
  server implementation by guessing from environment variables and Perl INC
  hashes.
  
  =over 4
  
  =item PLACK_SERVER
  
    env PLACK_SERVER=AnyEvent ...
  
  Plack users can specify the specific implementation they want to load
  using the C<PLACK_SERVER> environment variable.
  
  =item PHP_FCGI_CHILDREN, GATEWAY_INTERFACE
  
  If there's one of FastCGI or CGI specific environment variables set,
  use the corresponding server implementation.
  
  =item %INC
  
  If one of L<AnyEvent>, L<Coro> or L<POE> is loaded, the relevant
  server implementation such as L<Twiggy>, L<Corona> or
  L<POE::Component::Server::PSGI> will be loaded, if they're available.
  
  =back
  
  =cut
  
  
PLACK_LOADER

    $fatpacked{"Plack/Loader/Delayed.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_LOADER_DELAYED';
  package Plack::Loader::Delayed;
  use strict;
  use parent qw(Plack::Loader);
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{builder} = $builder;
  }
  
  sub run {
      my($self, $server) = @_;
  
      my $compiled;
      my $app = sub {
          $compiled ||= $self->{builder}->();
          $compiled->(@_);
      };
  
      $server->{psgi_app_builder} = $self->{builder};
      $server->run($app);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader::Delayed - Delay the loading of .psgi until the first run
  
  =head1 SYNOPSIS
  
    plackup -s Starlet -L Delayed myapp.psgi
  
  =head1 DESCRIPTION
  
  This loader delays the compilation of specified PSGI application until
  the first request time. This prevents bad things from happening with
  preforking web servers like L<Starlet>, when your application
  manipulates resources such as sockets or database connections in the
  master startup process and then shared by children.
  
  You can combine this loader with C<-M> command line option, like:
  
    plackup -s Starlet -MCatalyst -L Delayed myapp.psgi
  
  loads the module Catalyst in the master process for the better process
  management with copy-on-write, however the application C<myapp.psgi>
  is loaded per children.
  
  L<Starman> since version 0.2000 loads this loader by default unless
  you specify the command line option C<--preload-app> for the
  L<starman> executable.
  
  =head1 DEVELOPERS
  
  Web server developers can make use of C<psgi_app_builder> attribute
  callback set in Plack::Handler, to load the application earlier than
  the first request time.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
  
PLACK_LOADER_DELAYED

    $fatpacked{"Plack/Loader/Restarter.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_LOADER_RESTARTER';
  package Plack::Loader::Restarter;
  use strict;
  use warnings;
  use parent qw(Plack::Loader);
  use Plack::Util;
  use Try::Tiny;
  
  sub new {
      my($class, $runner) = @_;
      bless { watch => [] }, $class;
  }
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{builder} = $builder;
  }
  
  sub watch {
      my($self, @dir) = @_;
      push @{$self->{watch}}, @dir;
  }
  
  sub _fork_and_start {
      my($self, $server) = @_;
  
      delete $self->{pid}; # re-init in case it's a restart
  
      my $pid = fork;
      die "Can't fork: $!" unless defined $pid;
  
      if ($pid == 0) { # child
          return $server->run($self->{builder}->());
      } else {
          $self->{pid} = $pid;
      }
  }
  
  sub _kill_child {
      my $self = shift;
  
      my $pid = $self->{pid} or return;
      warn "Killing the existing server (pid:$pid)\n";
      kill 'TERM' => $pid;
      waitpid($pid, 0);
  }
  
  sub valid_file {
      my($self, $file) = @_;
  
      # vim temporary file is  4913 to 5036
      # http://www.mail-archive.com/vim_dev@googlegroups.com/msg07518.html
      if ( $file->{path} =~ m{(\d+)$} && $1 >= 4913 && $1 <= 5036) {
          return 0;
      }
      $file->{path} !~ m!^\.(?:git|svn)[/\\]|\.(?:bak|swp|swpx|swx)$|~$|_flymake\.p[lm]$|\.#!;
  }
  
  sub run {
      my($self, $server) = @_;
  
      $self->_fork_and_start($server);
      return unless $self->{pid};
  
      require Filesys::Notify::Simple;
      my $watcher = Filesys::Notify::Simple->new($self->{watch});
      warn "Watching @{$self->{watch}} for file updates.\n";
      local $SIG{TERM} = sub { $self->_kill_child; exit(0); };
  
      while (1) {
          my @restart;
  
          # this is blocking
          $watcher->wait(sub {
              my @events = @_;
              @events = grep $self->valid_file($_), @events;
              return unless @events;
  
              @restart = @events;
          });
  
          next unless @restart;
  
          for my $ev (@restart) {
              warn "-- $ev->{path} updated.\n";
          }
  
          $self->_kill_child;
          warn "Successfully killed! Restarting the new server process.\n";
          $self->_fork_and_start($server);
          return unless $self->{pid};
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader::Restarter - Restarting loader
  
  =head1 SYNOPSIS
  
    plackup -r -R paths
  
  =head1 DESCRIPTION
  
  Plack::Loader::Restarter is a loader backend that implements C<-r> and
  C<-R> option for the L<plackup> script. It forks the server as a child
  process and the parent watches the directories for file updates, and
  whenever it receives the notification, kills the child server and
  restart.
  
  =head1 SEE ALSO
  
  L<Plack::Runner>, L<Catalyst::Restarter>
  
  =cut
PLACK_LOADER_RESTARTER

    $fatpacked{"Plack/Loader/Shotgun.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_LOADER_SHOTGUN';
  package Plack::Loader::Shotgun;
  use strict;
  use parent qw(Plack::Loader);
  use Storable;
  use Try::Tiny;
  use Plack::Middleware::BufferedStreaming;
  
  die <<DIE if $^O eq 'MSWin32' && !$ENV{PLACK_SHOTGUN_MEMORY_LEAK};
  
  Shotgun loader uses fork(2) system call to create a fresh Perl interpreter, that is known to not work
  properly in a fork-emulation layer on Windows and cause huge memory leaks.
  
  If you're aware of this and still want to run the loader, run it with the environment variable
  PLACK_SHOTGUN_MEMORY_LEAK on.
  
  DIE
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{builder} = sub { Plack::Middleware::BufferedStreaming->wrap($builder->()) };
  }
  
  sub run {
      my($self, $server) = @_;
  
      my $app = sub {
          my $env = shift;
  
          pipe my $read, my $write;
  
          my $pid = fork;
          if ($pid) {
              # parent
              close $write;
              my $res = Storable::thaw(join '', <$read>);
              close $read;
              waitpid($pid, 0);
  
              return $res;
          } else {
              # child
              close $read;
  
              my $res;
              try {
                  $env->{'psgi.streaming'} = 0;
                  $res = $self->{builder}->()->($env);
                  my @body;
                  Plack::Util::foreach($res->[2], sub { push @body, $_[0] });
                  $res->[2] = \@body;
              } catch {
                  $env->{'psgi.errors'}->print($_);
                  $res = [ 500, [ "Content-Type", "text/plain" ], [ "Internal Server Error" ] ];
              };
  
              print {$write} Storable::freeze($res);
              close $write;
              exit;
          }
      };
  
      $server->run($app);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader::Shotgun - forking implementation of plackup
  
  =head1 SYNOPSIS
  
    plackup -L Shotgun
  
  =head1 DESCRIPTION
  
  Shotgun loader delays the compilation and execution of your
  application until the runtime. When a new request comes in, this forks
  a new child, compiles your code and runs the application.
  
  This should be an ultimate alternative solution when reloading with
  L<Plack::Middleware::Refresh> doesn't work, or plackup's default C<-r>
  filesystem watcher causes problems. I can imagine this is useful for
  applications which expects their application is only evaluated once
  (like in-file templates) or on operating systems with broken fork
  implementation, etc.
  
  This is much like good old CGI's fork and run but you don't need a web
  server, and there's a benefit of preloading modules that are not
  likely to change. For instance if you develop a web application using
  Moose and DBIx::Class,
  
    plackup -MMoose -MDBIx::Class -L Shotgun yourapp.psgi
  
  would preload those modules and only re-evaluates your code in every
  request.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa with an inspiration from L<http://github.com/rtomayko/shotgun>
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
PLACK_LOADER_SHOTGUN

    $fatpacked{"Plack/MIME.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIME';
  package Plack::MIME;
  use strict;
  
  # stolen from rack.mime.rb
  our $MIME_TYPES = {
      ".3gp"     => "video/3gpp",
      ".a"       => "application/octet-stream",
      ".ai"      => "application/postscript",
      ".aif"     => "audio/x-aiff",
      ".aiff"    => "audio/x-aiff",
      ".apk"     => "application/vnd.android.package-archive",
      ".asc"     => "application/pgp-signature",
      ".asf"     => "video/x-ms-asf",
      ".asm"     => "text/x-asm",
      ".asx"     => "video/x-ms-asf",
      ".atom"    => "application/atom+xml",
      ".au"      => "audio/basic",
      ".avi"     => "video/x-msvideo",
      ".bat"     => "application/x-msdownload",
      ".bin"     => "application/octet-stream",
      ".bmp"     => "image/bmp",
      ".bz2"     => "application/x-bzip2",
      ".c"       => "text/x-c",
      ".cab"     => "application/vnd.ms-cab-compressed",
      ".cc"      => "text/x-c",
      ".chm"     => "application/vnd.ms-htmlhelp",
      ".class"   => "application/octet-stream",
      ".com"     => "application/x-msdownload",
      ".conf"    => "text/plain",
      ".cpp"     => "text/x-c",
      ".crt"     => "application/x-x509-ca-cert",
      ".css"     => "text/css",
      ".csv"     => "text/csv",
      ".cxx"     => "text/x-c",
      ".deb"     => "application/x-debian-package",
      ".der"     => "application/x-x509-ca-cert",
      ".diff"    => "text/x-diff",
      ".djv"     => "image/vnd.djvu",
      ".djvu"    => "image/vnd.djvu",
      ".dll"     => "application/x-msdownload",
      ".dmg"     => "application/octet-stream",
      ".doc"     => "application/msword",
      ".dot"     => "application/msword",
      ".dtd"     => "application/xml-dtd",
      ".dvi"     => "application/x-dvi",
      ".ear"     => "application/java-archive",
      ".eml"     => "message/rfc822",
      ".eps"     => "application/postscript",
      ".exe"     => "application/x-msdownload",
      ".f"       => "text/x-fortran",
      ".f77"     => "text/x-fortran",
      ".f90"     => "text/x-fortran",
      ".flv"     => "video/x-flv",
      ".for"     => "text/x-fortran",
      ".gem"     => "application/octet-stream",
      ".gemspec" => "text/x-script.ruby",
      ".gif"     => "image/gif",
      ".gz"      => "application/x-gzip",
      ".h"       => "text/x-c",
      ".hh"      => "text/x-c",
      ".htm"     => "text/html",
      ".html"    => "text/html",
      ".ico"     => "image/vnd.microsoft.icon",
      ".ics"     => "text/calendar",
      ".ifb"     => "text/calendar",
      ".iso"     => "application/octet-stream",
      ".jar"     => "application/java-archive",
      ".java"    => "text/x-java-source",
      ".jnlp"    => "application/x-java-jnlp-file",
      ".jpeg"    => "image/jpeg",
      ".jpg"     => "image/jpeg",
      ".js"      => "application/javascript",
      ".json"    => "application/json",
      ".log"     => "text/plain",
      ".m3u"     => "audio/x-mpegurl",
      ".m4v"     => "video/mp4",
      ".man"     => "text/troff",
      ".manifest"=> "text/cache-manifest",
      ".mathml"  => "application/mathml+xml",
      ".mbox"    => "application/mbox",
      ".mdoc"    => "text/troff",
      ".me"      => "text/troff",
      ".mid"     => "audio/midi",
      ".midi"    => "audio/midi",
      ".mime"    => "message/rfc822",
      ".mml"     => "application/mathml+xml",
      ".mng"     => "video/x-mng",
      ".mov"     => "video/quicktime",
      ".mp3"     => "audio/mpeg",
      ".mp4"     => "video/mp4",
      ".mp4v"    => "video/mp4",
      ".mpeg"    => "video/mpeg",
      ".mpg"     => "video/mpeg",
      ".ms"      => "text/troff",
      ".msi"     => "application/x-msdownload",
      ".odp"     => "application/vnd.oasis.opendocument.presentation",
      ".ods"     => "application/vnd.oasis.opendocument.spreadsheet",
      ".odt"     => "application/vnd.oasis.opendocument.text",
      ".ogg"     => "application/ogg",
      ".ogv"     => "video/ogg",
      ".p"       => "text/x-pascal",
      ".pas"     => "text/x-pascal",
      ".pbm"     => "image/x-portable-bitmap",
      ".pdf"     => "application/pdf",
      ".pem"     => "application/x-x509-ca-cert",
      ".pgm"     => "image/x-portable-graymap",
      ".pgp"     => "application/pgp-encrypted",
      ".pkg"     => "application/octet-stream",
      ".pl"      => "text/x-script.perl",
      ".pm"      => "text/x-script.perl-module",
      ".png"     => "image/png",
      ".pnm"     => "image/x-portable-anymap",
      ".ppm"     => "image/x-portable-pixmap",
      ".pps"     => "application/vnd.ms-powerpoint",
      ".ppt"     => "application/vnd.ms-powerpoint",
      ".ps"      => "application/postscript",
      ".psd"     => "image/vnd.adobe.photoshop",
      ".py"      => "text/x-script.python",
      ".qt"      => "video/quicktime",
      ".ra"      => "audio/x-pn-realaudio",
      ".rake"    => "text/x-script.ruby",
      ".ram"     => "audio/x-pn-realaudio",
      ".rar"     => "application/x-rar-compressed",
      ".rb"      => "text/x-script.ruby",
      ".rdf"     => "application/rdf+xml",
      ".roff"    => "text/troff",
      ".rpm"     => "application/x-redhat-package-manager",
      ".rss"     => "application/rss+xml",
      ".rtf"     => "application/rtf",
      ".ru"      => "text/x-script.ruby",
      ".s"       => "text/x-asm",
      ".sgm"     => "text/sgml",
      ".sgml"    => "text/sgml",
      ".sh"      => "application/x-sh",
      ".sig"     => "application/pgp-signature",
      ".snd"     => "audio/basic",
      ".so"      => "application/octet-stream",
      ".svg"     => "image/svg+xml",
      ".svgz"    => "image/svg+xml",
      ".swf"     => "application/x-shockwave-flash",
      ".t"       => "text/troff",
      ".tar"     => "application/x-tar",
      ".tbz"     => "application/x-bzip-compressed-tar",
      ".tcl"     => "application/x-tcl",
      ".tex"     => "application/x-tex",
      ".texi"    => "application/x-texinfo",
      ".texinfo" => "application/x-texinfo",
      ".text"    => "text/plain",
      ".tif"     => "image/tiff",
      ".tiff"    => "image/tiff",
      ".torrent" => "application/x-bittorrent",
      ".tr"      => "text/troff",
      ".ttf"     => "font/ttf",
      ".txt"     => "text/plain",
      ".vcf"     => "text/x-vcard",
      ".vcs"     => "text/x-vcalendar",
      ".vrml"    => "model/vrml",
      ".war"     => "application/java-archive",
      ".wav"     => "audio/x-wav",
      ".webm"    => "video/webm",
      ".webp"    => "image/webp",
      ".wma"     => "audio/x-ms-wma",
      ".wmv"     => "video/x-ms-wmv",
      ".wmx"     => "video/x-ms-wmx",
      ".woff"    => "application/font-woff",
      ".wrl"     => "model/vrml",
      ".wsdl"    => "application/wsdl+xml",
      ".xbm"     => "image/x-xbitmap",
      ".xhtml"   => "application/xhtml+xml",
      ".xls"     => "application/vnd.ms-excel",
      ".xlsx"    => "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      ".xml"     => "application/xml",
      ".xpm"     => "image/x-xpixmap",
      ".xsl"     => "application/xml",
      ".xslt"    => "application/xslt+xml",
      ".yaml"    => "text/yaml",
      ".yml"     => "text/yaml",
      ".zip"     => "application/zip",
  };
  
  my $fallback = sub { };
  
  sub mime_type {
      my($class, $file) = @_;
      $file =~ /(\.[a-zA-Z0-9\-]+)$/ or return;
      $MIME_TYPES->{lc $1} || $fallback->(lc $1);
  }
  
  sub add_type {
      my $class = shift;
      while (my($ext, $type) = splice @_, 0, 2) {
          $MIME_TYPES->{lc $ext} = $type;
      }
  }
  
  sub set_fallback {
      my($class, $cb) = @_;
      $fallback = $cb;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::MIME - MIME type registry
  
  =head1 SYNOPSIS
  
    use Plack::MIME;
  
    my $mime = Plack::MIME->mime_type(".png"); # image/png
  
    # register new type(s)
    Plack::MIME->add_type(".foo" => "application/x-foo");
  
    # Use MIME::Types as a fallback
    use MIME::Types 'by_suffix';
    Plack::MIME->set_fallback(sub { (by_suffix $_[0])[0] });
  
  =head1 DESCRIPTION
  
  Plack::MIME is a simple MIME type registry for Plack applications. The
  selection of MIME types is based on Rack's Rack::Mime module.
  
  =head1 SEE ALSO
  
  L<Rack::Mime|https://github.com/rack/rack/blob/master/lib/rack/mime.rb> L<MIME::Types>
  
  =cut
PLACK_MIME

    $fatpacked{"Plack/Middleware.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE';
  package Plack::Middleware;
  use strict;
  use warnings;
  use Carp ();
  use parent qw(Plack::Component);
  use Plack::Util;
  use Plack::Util::Accessor qw( app );
  
  sub wrap {
      my($self, $app, @args) = @_;
      if (ref $self) {
          $self->{app} = $app;
      } else {
          $self = $self->new({ app => $app, @args });
      }
      return $self->to_app;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware - Base class for easy-to-use PSGI middleware
  
  =head1 SYNOPSIS
  
    package Plack::Middleware::Foo;
    use parent qw( Plack::Middleware );
  
    sub call {
        my($self, $env) = @_;
        # Do something with $env
  
        # $self->app is the original app
        my $res = $self->app->($env);
  
        # Do something with $res
        return $res;
    }
  
    # then in app.psgi
    use Plack::Builder;
  
    my $app = sub { ... } # as usual
  
    builder {
        enable "Plack::Middleware::Foo";
        enable "Plack::Middleware::Bar", %options;
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware is a utility base class to write PSGI
  middleware. All you have to do is to inherit from Plack::Middleware
  and then implement the callback C<call> method (or the C<to_app> method
  that would return the PSGI code reference) to do the actual work. You
  can use C<< $self->app >> to call the original (wrapped) application.
  
  Your middleware object is created at the PSGI application compile time
  and is persistent during the web server life cycle (unless it is a
  non-persistent environment such as CGI), so you should never set or
  cache per-request data like C<$env> in your middleware object. See
  also L<Plack::Component/"OBJECT LIFECYCLE">.
  
  See L<Plack::Builder> how to actually enable middleware in your
  I<.psgi> application file using the DSL. If you do not like our
  builder DSL, you can also use the C<wrap> method to wrap your application
  with a middleware:
  
    use Plack::Middleware::Foo;
  
    my $app = sub { ... };
    $app = Plack::Middleware::Foo->wrap($app, %options);
    $app = Plack::Middleware::Bar->wrap($app, %options);
  
  =head1 RESPONSE CALLBACK
  
  The typical middleware is written like this:
  
    package Plack::Middleware::Something;
    use parent qw(Plack::Middleware);
  
    sub call {
        my($self, $env) = @_;
        # pre-processing $env
        my $res = $self->app->($env);
        # post-processing $res
        return $res;
    }
  
  The tricky thing about post-processing the response is that it could
  either be an immediate 3 element array ref, or a code reference that
  implements the delayed (streaming) interface.
  
  Dealing with these two types of response in each piece of middleware
  is pointless, so you're recommended to use the C<response_cb> wrapper
  function in L<Plack::Util> when implementing a post processing
  middleware.
  
    sub call {
        my($self, $env) = @_;
        # pre-processing $env
        my $res = $self->app->($env);
  
        return Plack::Util::response_cb($res, sub {
            my $res = shift;
            # do something with $res;
        });
    }
  
  The callback function gets a response as an array reference, and you can
  update the reference to implement the post-processing. In the normal
  case, this arrayref will have three elements (as described by the PSGI
  spec), but will have only two elements when using a C<$writer> as
  described below.
  
    package Plack::Middleware::Always500;
    use parent qw(Plack::Middleware);
    use Plack::Util;
  
    sub call {
        my($self, $env) = @_;
        my $res  = $self->app->($env);
        return Plack::Util::response_cb($res, sub {
            my $res = shift;
            $res->[0] = 500;
            return;
        });
    }
  
  In this example, the callback gets the C<$res> and updates its first
  element (status code) to 500. Using C<response_cb> makes sure that
  this works with the delayed response too.
  
  You're not required (and not recommended either) to return a new array
  reference - they will be simply ignored. You're suggested to
  explicitly return, unless you fiddle with the content filter callback
  (see below).
  
  Similarly, note that you have to keep the C<$res> reference when you
  swap the entire response.
  
    Plack::Util::response_cb($res, sub {
        my $res = shift;
        $res = [ $new_status, $new_headers, $new_body ]; # THIS DOES NOT WORK
        return;
    });
  
  This does not work, since assigning a new anonymous array to C<$res>
  doesn't update the original PSGI response value. You should instead
  do:
  
    Plack::Util::response_cb($res, sub {
        my $res = shift;
        @$res = ($new_status, $new_headers, $new_body); # THIS WORKS
        return;
    });
  
  The third element of the response array ref is a body, and it could
  be either an arrayref or L<IO::Handle>-ish object. The application could
  also make use of the C<$writer> object if C<psgi.streaming> is in
  effect, and in this case, the third element will not exist
  (C<@$res == 2>). Dealing with these variants is again really painful,
  and C<response_cb> can take care of that too, by allowing you to return
  a content filter as a code reference.
  
    # replace all "Foo" in content body with "Bar"
    Plack::Util::response_cb($res, sub {
        my $res = shift;
        return sub {
            my $chunk = shift;
            return unless defined $chunk;
            $chunk =~ s/Foo/Bar/g;
            return $chunk;
        }
    });
  
  The callback takes one argument C<$chunk> and your callback is
  expected to return the updated chunk. If the given C<$chunk> is undef,
  it means the stream has reached the end, so your callback should also
  return undef, or return the final chunk and return undef when called
  next time.
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Builder> L<Plack::Component>
  
  =cut
PLACK_MIDDLEWARE

    $fatpacked{"Plack/Middleware/AccessLog.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_ACCESSLOG';
  package Plack::Middleware::AccessLog;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  use Plack::Util::Accessor qw( logger format compiled_format char_handlers block_handlers );
  use Apache::LogFormat::Compiler;
  
  my %formats = (
      common => '%h %l %u %t "%r" %>s %b',
      combined => '%h %l %u %t "%r" %>s %b "%{Referer}i" "%{User-agent}i"',
  );
  
  sub prepare_app {
      my $self = shift;
      my $fmt = $self->format || "combined";
      $fmt = $formats{$fmt} if exists $formats{$fmt};
      $self->compiled_format(Apache::LogFormat::Compiler->new($fmt,
              char_handlers => $self->char_handlers || {},
              block_handlers => $self->block_handlers || {},
          ));
  }
  
  sub call {
      my $self = shift;
      my($env) = @_;
  
      my $res = $self->app->($env);
  
      if ( ref($res) && ref($res) eq 'ARRAY' ) {
          my $content_length = Plack::Util::content_length($res->[2]);
          my $log_line = $self->log_line($res->[0], $res->[1], $env, { content_length => $content_length });
          if ( my $logger = $self->logger ) {
              $logger->($log_line);
          }
          else {
              $env->{'psgi.errors'}->print($log_line);
          }  
          return $res;
      }
  
      return $self->response_cb($res, sub {
          my $res = shift;
          my $content_length = Plack::Util::content_length($res->[2]);
          my $log_line = $self->log_line($res->[0], $res->[1], $env, { content_length => $content_length });
          if ( my $logger = $self->logger ) {
              $logger->($log_line);
          }
          else {
              $env->{'psgi.errors'}->print($log_line);
          }  
      });
  }
  
  sub log_line {
      my($self, $status, $headers, $env, $opts) = @_;
  
      $self->compiled_format->log_line(
          $env,
          [$status,$headers],
          $opts->{content_length},
          $opts->{time}
      );
  }
  
  1;
  
  __END__
  
  =for stopwords
  LogFormat
  
  =head1 NAME
  
  Plack::Middleware::AccessLog - Logs requests like Apache's log format
  
  =head1 SYNOPSIS
  
    # in app.psgi
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::AccessLog", format => "combined";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::AccessLog forwards the request to the given app and
  logs request and response details to the logger callback. The format
  can be specified using Apache-like format strings (or C<combined> or
  C<common> for the default formats). If none is specified C<combined> is
  used.
  
  This middleware uses calculable Content-Length by checking body type,
  and cannot log the time taken to serve requests. It also logs the
  request B<before> the response is actually sent to the client. Use
  L<Plack::Middleware::AccessLog::Timed> if you want to log details
  B<after> the response is transmitted (more like a real web server) to
  the client.
  
  This middleware is enabled by default when you run L<plackup> as a
  default C<development> environment.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item format
  
    enable "Plack::Middleware::AccessLog",
        format => '%h %l %u %t "%r" %>s %b "%{Referer}i" "%{User-agent}i"';
  
  Takes a format string (or a preset template C<combined> or C<custom>)
  to specify the log format. This middleware uses L<Apache::LogFormat::Compiler> to
  generate access_log lines. See more details on perldoc L<Apache::LogFormat::Compiler>
  
     %%    a percent sign
     %h    REMOTE_ADDR from the PSGI environment, or -
     %l    remote logname not implemented (currently always -)
     %u    REMOTE_USER from the PSGI environment, or -
     %t    [local timestamp, in default format]
     %r    REQUEST_METHOD, REQUEST_URI and SERVER_PROTOCOL from the PSGI environment
     %s    the HTTP status code of the response
     %b    content length of the response
     %T    custom field for handling times in subclasses
     %D    custom field for handling sub-second times in subclasses
     %v    SERVER_NAME from the PSGI environment, or -
     %V    HTTP_HOST or SERVER_NAME from the PSGI environment, or -
     %p    SERVER_PORT from the PSGI environment
     %P    the worker's process id
     %m    REQUEST_METHOD from the PSGI environment
     %U    PATH_INFO from the PSGI environment
     %q    QUERY_STRING from the PSGI environment
     %H    SERVER_PROTOCOL from the PSGI environment
  
  Some of these format fields are only supported by middleware that subclasses C<AccessLog>.
  
  In addition, custom values can be referenced, using C<%{name}>,
  with one of the mandatory modifier flags C<i>, C<o> or C<t>:
  
     %{variable-name}i    HTTP_VARIABLE_NAME value from the PSGI environment
     %{header-name}o      header-name header in the response
     %{time-format]t      localtime in the specified strftime format
  
  =item logger
  
    my $logger = Log::Dispatch->new(...);
    enable "Plack::Middleware::AccessLog",
        logger => sub { $logger->log(level => 'debug', message => @_) };
  
  Sets a callback to print log message to. It prints to the C<psgi.errors>
  output stream by default.
  
  =item char_handlers
  
    my $handlers = {
        'z' => sub {
            my ($env,$req) = @_;
            return $env->{HTTP_X_FORWARDED_FOR};
        }
    };
  
    enable "Plack::Middleware::AccessLog",
        format => '%z %{HTTP_X_FORWARDED_FOR|REMOTE_ADDR}Z',
        char_handlers => $handlers;
  
  Takes a hash reference and passes it to the underlying
  L<Apache::LogFormat::Compiler>'s C<char_handlers>.  For more details see
  L<Apache::LogFormat::Compiler/ADD CUSTOM FORMAT STRING>.
  
  =item block_handlers
  
    my $handlers = {
        'Z' => sub {
            my ($block,$env,$req) = @_;
            # block eq 'HTTP_X_FORWARDED_FOR|REMOTE_ADDR'
            my ($main, $alt) = split('\|', $args);
            return exists $env->{$main} ? $env->{$main} : $env->{$alt};
        }
    };
  
    enable "Plack::Middleware::AccessLog",
        format => '%z %{HTTP_X_FORWARDED_FOR|REMOTE_ADDR}Z',
        block_handlers => $handlers;
  
  Takes a hash reference and passes it to the underlying
  L<Apache::LogFormat::Compiler>'s C<block_handlers>.  For more details see
  L<Apache::LogFormat::Compiler/ADD CUSTOM FORMAT STRING>.
  
  =back
  
  =head1 AUTHORS
  
  Tatsuhiko Miyagawa
  
  Masahiro Nagano
  
  =head1 SEE ALSO
  
  L<Apache::LogFormat::Compiler>, L<http://httpd.apache.org/docs/2.2/mod/mod_log_config.html> Rack::CustomLogger
  
  =cut
  
PLACK_MIDDLEWARE_ACCESSLOG

    $fatpacked{"Plack/Middleware/AccessLog/Timed.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_ACCESSLOG_TIMED';
  package Plack::Middleware::AccessLog::Timed;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware::AccessLog );
  
  use Time::HiRes;
  use Plack::Util;
  
  sub call {
      my $self = shift;
      my($env) = @_;
  
      my $time = [Time::HiRes::gettimeofday];
      my $length = 0;
      my $logger = $self->logger || sub { $env->{'psgi.errors'}->print(@_) };
  
      my $res = $self->app->($env);
  
      return $self->response_cb($res, sub {
          my $res = shift;
          my($status, $header, $body) = @$res;
  
          if (!defined $body) {
              my $length;
  
              return sub {
                  my $line = shift;
                  
                  $length += length $line if defined $line;
  
                  unless( defined $line ) {
                      my $now = [Time::HiRes::gettimeofday];
                      $logger->( $self->log_line($status, $header, $env, { time => scalar Time::HiRes::tv_interval($time, $now) * 1_000_000, content_length => $length }) );
                  }
  
                  return $line;
              };
          }
  
          my $getline = ref $body eq 'ARRAY' ? sub { shift @$body } : sub { $body->getline };
  
          my $timer_body = Plack::Util::inline_object(
              getline => sub {
                  my $line = $getline->();
                  $length += length $line if defined $line;
                  return $line;
              },
              close => sub {
                  $body->close if ref $body ne 'ARRAY';
  
                  my $now = [Time::HiRes::gettimeofday];
                  $logger->( $self->log_line($status, $header, $env, { time => scalar Time::HiRes::tv_interval($time, $now) * 1_000_000, content_length => $length }) );
              },
          );
  
          @$res = ($status, $header, $timer_body);
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::AccessLog::Timed - Logs requests with time and accurate body size
  
  =head1 SYNOPSIS
  
    # in app.psgi
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::AccessLog::Timed",
            format => "%v %h %l %u %t \"%r\" %>s %b %D";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::AccessLog::Timed is a subclass of
  L<Plack::Middleware::AccessLog> but uses a wrapped body handle to get the
  actual response body size C<%b> (even if it's not a chunk of array or
  a real filehandle) and the time taken to serve the request: C<%T> or
  C<%D>.
  
  This wraps the response body output stream to capture the time taken
  for the PSGI server to read the whole response body.
  
  This would mean, if the middleware is in use, it will prevent some
  server-side optimizations like sendfile(2) from working, as well as
  middleware like L<Plack::Middleware::ContentLength> can't guess the
  body size out of the file handle.
  
  If all you want is to capture the time taken in your PSGI application
  and do not want the wrapped body behavior described above, consider instead
  applying L<Plack::Middleware::Runtime> and using L<Plack::Middleware::AccessLog>
  to log the C<X-Runtime> header.
  
  =head1 CONFIGURATION
  
  Same as L<Plack::Middleware::AccessLog>.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Middleware::AccessLog>
  
  L<Plack::Middleware::Runtime>
  
  =cut
PLACK_MIDDLEWARE_ACCESSLOG_TIMED

    $fatpacked{"Plack/Middleware/Auth/Basic.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_AUTH_BASIC';
  package Plack::Middleware::Auth::Basic;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw( realm authenticator );
  use Scalar::Util;
  use MIME::Base64;
  
  sub prepare_app {
      my $self = shift;
  
      my $auth = $self->authenticator or die 'authenticator is not set';
      if (Scalar::Util::blessed($auth) && $auth->can('authenticate')) {
          $self->authenticator(sub { $auth->authenticate(@_[0,1]) }); # because Authen::Simple barfs on 3 params
      } elsif (ref $auth ne 'CODE') {
          die 'authenticator should be a code reference or an object that responds to authenticate()';
      }
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $auth = $env->{HTTP_AUTHORIZATION}
          or return $self->unauthorized;
  
      # note the 'i' on the regex, as, according to RFC2617 this is a 
      # "case-insensitive token to identify the authentication scheme"
      if ($auth =~ /^Basic (.*)$/i) {
          my($user, $pass) = split /:/, (MIME::Base64::decode($1) || ":"), 2;
          $pass = '' unless defined $pass;
          if ($self->authenticator->($user, $pass, $env)) {
              $env->{REMOTE_USER} = $user;
              return $self->app->($env);
          }
      }
  
      return $self->unauthorized;
  }
  
  sub unauthorized {
      my $self = shift;
      my $body = 'Authorization required';
      return [
          401,
          [ 'Content-Type' => 'text/plain',
            'Content-Length' => length $body,
            'WWW-Authenticate' => 'Basic realm="' . ($self->realm || "restricted area") . '"' ],
          [ $body ],
      ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Auth::Basic - Simple basic authentication middleware
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
    my $app = sub { ... };
  
    builder {
        enable "Auth::Basic", authenticator => \&authen_cb;
        $app;
    };
  
    sub authen_cb {
        my($username, $password, $env) = @_;
        return $username eq 'admin' && $password eq 's3cr3t';
    }
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Auth::Basic is a basic authentication handler for Plack.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item authenticator
  
  A callback function that takes username, password and PSGI environment
  supplied and returns whether the authentication succeeds. Required.
  
  Authenticator can also be an object that responds to C<authenticate>
  method that takes username and password and returns boolean, so
  backends for L<Authen::Simple> is perfect to use:
  
    use Authen::Simple::LDAP;
    enable "Auth::Basic", authenticator => Authen::Simple::LDAP->new(...);
  
  =item realm
  
  Realm name to display in the basic authentication dialog. Defaults to I<restricted area>.
  
  =back
  
  =head1 LIMITATIONS
  
  This middleware expects that the application has a full access to the
  headers sent by clients in PSGI environment. That is normally the case
  with standalone Perl PSGI web servers such as L<Starman> or
  L<HTTP::Server::Simple::PSGI>.
  
  However, in a web server configuration where you can't achieve this
  (i.e. using your application via Apache's mod_cgi), this middleware
  does not work since your application can't know the value of
  C<Authorization:> header.
  
  If you use Apache as a web server and CGI to run your PSGI
  application, you can either a) compile Apache with
  C<-DSECURITY_HOLE_PASS_AUTHORIZATION> option, or b) use mod_rewrite to
  pass the Authorization header to the application with the rewrite rule
  like following.
  
    RewriteEngine on
    RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization},L]
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
PLACK_MIDDLEWARE_AUTH_BASIC

    $fatpacked{"Plack/Middleware/BufferedStreaming.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_BUFFEREDSTREAMING';
  package Plack::Middleware::BufferedStreaming;
  use strict;
  no warnings;
  use Carp;
  use Plack::Util;
  use Plack::Util::Accessor qw(force);
  use Scalar::Util qw(weaken);
  use parent qw(Plack::Middleware);
  
  sub call {
      my ( $self, $env ) = @_;
  
      my $caller_supports_streaming = $env->{'psgi.streaming'};
      $env->{'psgi.streaming'} = Plack::Util::TRUE;
  
      my $res = $self->app->($env);
      return $res if $caller_supports_streaming && !$self->force;
  
      if ( ref($res) eq 'CODE' ) {
          my $ret;
  
          $res->(sub {
              my $write = shift;
  
              if ( @$write == 2 ) {
                  my @body;
  
                  $ret = [ @$write, \@body ];
  
                  return Plack::Util::inline_object(
                      write => sub { push @body, $_[0] },
                      close => sub { },
                  );
              } else {
                  $ret = $write;
                  return;
              }
          });
  
          return $ret;
      } else {
          return $res;
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::BufferedStreaming - Enable buffering for non-streaming aware servers
  
  =head1 SYNOPSIS
  
    enable "BufferedStreaming";
  
  =head1 DESCRIPTION
  
  Plack::Middleware::BufferedStreaming is a PSGI middleware component
  that wraps the application that uses C<psgi.streaming> interface to
  run on the servers that do not support the interface, by buffering the
  writer output to a temporary buffer.
  
  This middleware doesn't do anything and bypass the application if the
  server supports C<psgi.streaming> interface, unless you set C<force>
  option (see below).
  
  =head1 OPTIONS
  
  =over 4
  
  =item force
  
  Force enable this middleware only if the container supports C<psgi.streaming>.
  
  =back
  
  =head1 AUTHOR
  
  Yuval Kogman
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_BUFFEREDSTREAMING

    $fatpacked{"Plack/Middleware/Chunked.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_CHUNKED';
  package Plack::Middleware::Chunked;
  use strict;
  use parent qw(Plack::Middleware);
  
  use Plack::Util;
  
  sub call {
      my($self, $env) = @_;
      my $res = $self->app->($env);
      $self->response_cb($res, sub {
          my $res = shift;
          my $h = Plack::Util::headers($res->[1]);
          if ($env->{'SERVER_PROTOCOL'} ne 'HTTP/1.0' and
              ! Plack::Util::status_with_no_entity_body($res->[0]) and
              ! $h->exists('Content-Length') and
              ! $h->exists('Transfer-Encoding')
          ) {
              $h->set('Transfer-Encoding' => 'chunked');
              my $done;
              return sub {
                  my $chunk = shift;
                  return if $done;
                  unless (defined $chunk) {
                      $done = 1;
                      return "0\015\012\015\012";
                  }
                  return '' unless length $chunk;
                  return sprintf('%x', length $chunk) . "\015\012$chunk\015\012";
              };
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Chunked - Applies chunked encoding to the response body
  
  =head1 SYNOPSIS
  
    # Mostly from server implementations
    $app = Plack::Middleware::Chunked->wrap($app);
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Chunked is a middleware, or rather a library for
  PSGI server to automatically add chunked encoding to the response body
  when Content-Length is not set in the response header.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  Rack::Chunked
  
  =cut
PLACK_MIDDLEWARE_CHUNKED

    $fatpacked{"Plack/Middleware/Conditional.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_CONDITIONAL';
  package Plack::Middleware::Conditional;
  use strict;
  use parent qw(Plack::Middleware);
  
  use Plack::Util::Accessor qw( condition middleware builder );
  
  sub prepare_app {
      my $self = shift;
      $self->middleware( $self->builder->($self->app) );
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $app = $self->condition->($env) ? $self->middleware : $self->app;
      return $app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Conditional - Conditional wrapper for Plack middleware
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    builder {
        enable_if { $_[0]->{REMOTE_ADDR} eq '127.0.0.1' } 'StackTrace', force => 1;
        $app;
    };
  
    # or using the OO interface:
    $app = Plack::Middleware::Conditional->wrap(
        $app,
        condition  => sub { $_[0]->{REMOTE_ADDR} eq '127.0.0.1' },
        builder => sub { Plack::Middleware::StackTrace->wrap($_[0], force => 1) },
    );
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Conditional is a piece of meta-middleware, to run a
  specific middleware component under runtime conditions. The goal of
  this middleware is to avoid baking runtime configuration options in
  individual middleware components, and rather share them as another
  middleware component.
  
  =head1 EXAMPLES
  
  Note that some of the middleware component names are just made up for
  the explanation and might not exist.
  
    # Minify JavaScript if the browser is Firefox
    enable_if { $_[0]->{HTTP_USER_AGENT} =~ /Firefox/ } 'JavaScriptMinifier';
  
    # Enable Stacktrace when being accessed from the local network
    enable_if { $_[0]->{REMOTE_ADDR} =~ /^10\.0\.1\.*/ } 'StackTrace';
  
    # Work with other conditional setter middleware:
    # Transcode Jpeg on the fly for mobile clients
    builder {
        enable 'MobileDetector';
        enable_if { $_[0]->{'plack.mobile_detected'} }
          'TranscodeJpeg', max_size => 30_000;
        $app;
    };
  
  Note that in the last example I<MobileDetector> should come first
  because the conditional check runs in I<pre-run> conditions, which is
  from outer to inner: that is, from the top to the bottom in the
  Builder DSL code.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Steve Cook
  
  =head1 SEE ALSO
  
  L<Plack::Builder>
  
  =cut
PLACK_MIDDLEWARE_CONDITIONAL

    $fatpacked{"Plack/Middleware/ConditionalGET.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_CONDITIONALGET';
  package Plack::Middleware::ConditionalGET;
  use strict;
  use parent qw( Plack::Middleware );
  use Plack::Util;
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $res = $self->app->($env);
      return $res unless $env->{REQUEST_METHOD} =~ /^(GET|HEAD)$/;
  
      $self->response_cb($res, sub {
          my $res = shift;
  
          my $h = Plack::Util::headers($res->[1]);
  
          # check both ETag and If-Modified-Since, and at least one should exist
          # and all present headers should match, not either.
          my @checks = ( $self->etag_matches($h, $env), $self->not_modified_since($h, $env) )
            or return;
  
          unless (grep !$_, @checks) {
              $res->[0] = 304;
              $h->remove($_) for qw( Content-Type Content-Length Content-Disposition );
              if ($res->[2]) {
                  $res->[2] = [];
              } else {
                  return sub {
                      return defined $_[0] ? '' : undef;
                  };
              }
          }
      });
  }
  
  no warnings 'uninitialized';
  
  # RFC 2616 14.25 says it's OK and expected to use 'eq' :)
  # > Note: When handling an If-Modified-Since header field, some
  # > servers will use an exact date comparison function, rather than a
  # > less-than function, for deciding whether to send a 304 ...
  
  sub etag_matches {
      my($self, $h, $env) = @_;
      return unless $h->exists('ETag');
      $h->get('ETag') eq _value($env->{HTTP_IF_NONE_MATCH});
  }
  
  sub not_modified_since {
      my($self, $h, $env) = @_;
      return unless $h->exists('Last-Modified');
      $h->get('Last-Modified') eq _value($env->{HTTP_IF_MODIFIED_SINCE});
  }
  
  sub _value {
      my $str = shift;
      # IE sends wrong formatted value(i.e. "Thu, 03 Dec 2009 01:46:32 GMT; length=17936")
      $str =~ s/;.*$//;
      return $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ConditionalGET - Middleware to enable conditional GET
  
  =head1 SYNOPSIS
  
    builder {
        enable "ConditionalGET";
        ....
    };
  
  =head1 DESCRIPTION
  
  This middleware enables conditional GET and HEAD using
  C<If-None-Match> and C<If-Modified-Since> header. The application
  should set either or both of C<Last-Modified> or C<ETag> response
  headers per RFC 2616. When either of the conditions is met, the
  response body is set to be zero length and the status is set to 304
  Not Modified.
  
  =head1 SEE ALSO
  
  Rack::ConditionalGet
  
  =cut
PLACK_MIDDLEWARE_CONDITIONALGET

    $fatpacked{"Plack/Middleware/ContentLength.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_CONTENTLENGTH';
  package Plack::Middleware::ContentLength;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use Plack::Util;
  
  sub call {
      my $self = shift;
      my $res  = $self->app->(@_);
  
      return $self->response_cb($res, sub {
          my $res = shift;
          my $h = Plack::Util::headers($res->[1]);
          if (!Plack::Util::status_with_no_entity_body($res->[0]) &&
              !$h->exists('Content-Length') &&
              !$h->exists('Transfer-Encoding') &&
              defined(my $content_length = Plack::Util::content_length($res->[2]))) {
              $h->push('Content-Length' => $content_length);
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ContentLength - Adds Content-Length header automatically
  
  =head1 SYNOPSIS
  
    # in app.psgi
  
    builder {
        enable "Plack::Middleware::ContentLength";
        $app;
    }
  
    # Or in Plack::Handler::*
    $app = Plack::Middleware::ContentLength->wrap($app);
  
  =head1 DESCRIPTION
  
  Plack::Middleware::ContentLength is a middleware that automatically
  adds C<Content-Length> header when it's appropriate i.e. the response
  has a content body with calculable size (array of chunks or a real
  filehandle).
  
  This middleware can also be used as a library from PSGI server
  implementations to automatically set C<Content-Length> rather than in
  the end user level.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  Rack::ContentLength
  
  =cut
  
PLACK_MIDDLEWARE_CONTENTLENGTH

    $fatpacked{"Plack/Middleware/ContentMD5.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_CONTENTMD5';
  package Plack::Middleware::ContentMD5;
  
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use Plack::Util;
  use Digest::MD5 qw/md5_hex/;
  
  sub call {
      my $self = shift;
      my $res  = $self->app->(@_);
      
      $self->response_cb($res, sub {
          my $res = shift;
  
          return unless defined $res->[2];
          return if (Plack::Util::status_with_no_entity_body($res->[0]));
          
          my $h = Plack::Util::headers($res->[1]);
          return if ( $h->exists('Content-MD5') );
          
          my $body = $res->[2];
          if (ref $body eq 'ARRAY') {
              $h->set('Content-MD5', md5_hex(@$body));
          }
          # Do we need support $fh?
  
          return;
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ContentMD5 - Automatically sets the Content-MD5 header on all String bodies
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    my $app = sub {
        return [ 200, [ 'Content-Type' => 'text/plain' ], [ 'Hello Foo' ] ];
    };
  
    builder {
        enable "Plack::Middleware::ContentMD5";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Automatically sets the Content-MD5 header on all String bodies
  
  =head1 AUTHOR
  
  Fayland Lam
  
  =cut
PLACK_MIDDLEWARE_CONTENTMD5

    $fatpacked{"Plack/Middleware/ErrorDocument.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_ERRORDOCUMENT';
  package Plack::Middleware::ErrorDocument;
  use strict;
  use warnings;
  use parent qw(Plack::Middleware);
  use Plack::MIME;
  use Plack::Util;
  use Plack::Util::Accessor qw( subrequest );
  
  use HTTP::Status qw(is_error);
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $r = $self->app->($env);
  
      $self->response_cb($r, sub {
          my $r = shift;
          unless (is_error($r->[0]) && exists $self->{$r->[0]}) {
              return;
          }
  
          my $path = $self->{$r->[0]};
          if ($self->subrequest) {
              for my $key (keys %$env) {
                  unless ($key =~ /^psgi/) {
                      $env->{'psgix.errordocument.' . $key} = $env->{$key};
                  }
              }
  
              # TODO: What if SCRIPT_NAME is not empty?
              $env->{REQUEST_METHOD} = 'GET';
              $env->{REQUEST_URI}    = $path;
              $env->{PATH_INFO}      = $path;
              $env->{QUERY_STRING}   = '';
              delete $env->{CONTENT_LENGTH};
  
              my $sub_r = $self->app->($env);
              if ($sub_r->[0] == 200) {
                  $r->[1] = $sub_r->[1];
                  if (@$r == 3) {
                      $r->[2] = $sub_r->[2];
                  }
                  else {
                      my $full_sub_response = '';
                      Plack::Util::foreach($sub_r->[2], sub {
                          $full_sub_response .= $_[0];
                      });
  
                      my $returned;
                      return sub {
                          if ($returned) {
                              return defined($_[0]) ? '' : undef;
                          }
                          $returned = 1;
                          return $full_sub_response;
                      }
                  }
              }
              # TODO: allow 302 here?
          } else {
              my $h = Plack::Util::headers($r->[1]);
              $h->remove('Content-Length');
              $h->remove('Content-Encoding');
              $h->remove('Transfer-Encoding');
              $h->set('Content-Type', Plack::MIME->mime_type($path));
  
              open my $fh, "<", $path or die "$path: $!";
              if ($r->[2]) {
                  $r->[2] = $fh;
              } else {
                  my $done;
                  return sub {
                      unless ($done) {
                          $done = 1;
                          return join '', <$fh>;
                      }
                      return defined $_[0] ? '' : undef;
                  };
              };
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ErrorDocument - Set Error Document based on HTTP status code
  
  =head1 SYNOPSIS
  
    # in app.psgi
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::ErrorDocument",
            500 => '/uri/errors/500.html', 404 => '/uri/errors/404.html',
            subrequest => 1;
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::ErrorDocument allows you to customize error screen
  by setting paths (file system path or URI path) of error pages per
  status code.
  
  =head1 CONFIGURATIONS
  
  =over 4
  
  =item subrequest
  
  A boolean flag to serve error pages using a new GET sub request.
  Defaults to false, which means it serves error pages using file
  system path.
  
    builder {
        enable "Plack::Middleware::ErrorDocument",
            502 => '/home/www/htdocs/errors/maint.html';
        enable "Plack::Middleware::ErrorDocument",
            404 => '/static/404.html', 403 => '/static/403.html', subrequest => 1;
        $app;
    };
  
  This configuration serves 502 error pages from file system directly
  assuming that's when you probably maintain database etc. but serves
  404 and 403 pages using a sub request so your application can do some
  logic there like logging or doing suggestions.
  
  When using a subrequest, the subrequest should return a regular '200' response.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  =cut
PLACK_MIDDLEWARE_ERRORDOCUMENT

    $fatpacked{"Plack/Middleware/HTTPExceptions.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_HTTPEXCEPTIONS';
  package Plack::Middleware::HTTPExceptions;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(rethrow);
  
  use Carp ();
  use Try::Tiny;
  use Scalar::Util 'blessed';
  use HTTP::Status ();
  
  sub prepare_app {
      my $self = shift;
      $self->rethrow(1) if ($ENV{PLACK_ENV} || '') eq 'development';
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $res = try {
          $self->app->($env);
      } catch {
          $self->transform_error($_, $env);
      };
  
      return $res if ref $res eq 'ARRAY';
  
      return sub {
          my $respond = shift;
  
          my $writer;
          try {
              $res->(sub { return $writer = $respond->(@_) });
          } catch {
              if ($writer) {
                  Carp::cluck $_;
                  $writer->close;
              } else {
                  my $res = $self->transform_error($_, $env);
                  $respond->($res);
              }
          };
      };
  }
  
  sub transform_error {
      my($self, $e, $env) = @_;
  
      my($code, $message);
      if (blessed $e && $e->can('as_psgi')) {
          return $e->as_psgi;
      }
      if (blessed $e && $e->can('code')) {
          $code = $e->code;
          $message =
              $e->can('as_string')       ? $e->as_string :
              overload::Method($e, '""') ? "$e"          : undef;
      } else {
          if ($self->rethrow) {
              die $e;
          }
          else {
              $code = 500;
              $env->{'psgi.errors'}->print($e);
          }
      }
  
      if ($code !~ /^[3-5]\d\d$/) {
          die $e; # rethrow
      }
  
      $message ||= HTTP::Status::status_message($code);
  
      my @headers = (
           'Content-Type'   => 'text/plain',
           'Content-Length' => length($message),
      );
  
      if ($code =~ /^3/ && (my $loc = eval { $e->location })) {
          push(@headers, Location => $loc);
      }
  
      return [ $code, \@headers, [ $message ] ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::HTTPExceptions - Catch HTTP exceptions
  
  =head1 SYNOPSIS
  
    use HTTP::Exception;
  
    my $app = sub {
        # ...
        HTTP::Exception::500->throw;
    };
  
    builder {
        enable "HTTPExceptions", rethrow => 1;
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::HTTPExceptions is a PSGI middleware component to
  catch exceptions from applications that can be translated into HTTP
  status codes.
  
  Your application is supposed to throw an object that implements a
  C<code> method which returns the HTTP status code, such as 501 or
  404. This middleware catches them and creates a valid response out of
  the code. If the C<code> method returns a code that is not an HTTP
  redirect or error code (3xx, 4xx, or 5xx), the exception will be
  rethrown.
  
  The exception object may also implement C<as_string> or overload
  stringification to represent the text of the error. The text defaults to
  the status message of the error code, such as I<Service Unavailable> for
  C<503>.
  
  Finally, the exception object may implement C<as_psgi>, and the result
  of this will be returned directly as the PSGI response.
  
  If the code is in the 3xx range and the exception implements the 'location'
  method (HTTP::Exception::3xx does), the Location header will be set in the
  response, so you can do redirects this way.
  
  There are CPAN modules L<HTTP::Exception> and L<HTTP::Throwable>, and
  they are perfect to throw from your application to let this middleware
  catch and display, but you can also implement your own exception class
  to throw.
  
  If the thrown exception is not an object that implements either a
  C<code> or an C<as_psgi> method, a 500 error will be returned, and the
  exception is printed to the psgi.errors stream.
  Alternatively, you can pass a true value for the C<rethrow> parameter
  for this middleware, and the exception will instead be rethrown. This is
  enabled by default when C<PLACK_ENV> is set to C<development>, so that
  the L<StackTrace|Plack::Middleware::StackTrace> middleware can catch it
  instead.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  paste.httpexceptions L<HTTP::Exception> L<HTTP::Throwable>
  
  =cut
PLACK_MIDDLEWARE_HTTPEXCEPTIONS

    $fatpacked{"Plack/Middleware/Head.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_HEAD';
  package Plack::Middleware::Head;
  use strict;
  use warnings;
  use parent qw(Plack::Middleware);
  
  sub call {
      my($self, $env) = @_;
  
      return $self->app->($env)
          unless $env->{REQUEST_METHOD} eq 'HEAD';
  
      $self->response_cb($self->app->($env), sub {
          my $res = shift;
          if ($res->[2]) {
              $res->[2] = [];
          } else {
              return sub {
                  return defined $_[0] ? '': undef;
              };
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Head - auto delete response body in HEAD requests
  
  =head1 SYNOPSIS
  
    enable "Head";
  
  =head1 DESCRIPTION
  
  This middleware deletes response body in HEAD requests.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  Rack::Head
  
  =cut
  
PLACK_MIDDLEWARE_HEAD

    $fatpacked{"Plack/Middleware/IIS6ScriptNameFix.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_IIS6SCRIPTNAMEFIX';
  package Plack::Middleware::IIS6ScriptNameFix;
  
  use strict;
  use parent 'Plack::Middleware';
  use Plack::Util::Accessor qw(force);
  
  sub call {
      my($self, $env) = @_;
  
      if ($self->force || ($env->{SERVER_SOFTWARE} && $env->{SERVER_SOFTWARE} =~ /IIS\/[6-9]\.[0-9]/)) {
          my @script_name = split(m!/!, $env->{PATH_INFO});
          my @path_translated = split(m!/|\\\\?!, $env->{PATH_TRANSLATED});
          my @path_info;
  
          while ($script_name[$#script_name] eq $path_translated[$#path_translated]) {
              pop(@path_translated);
              unshift(@path_info, pop(@script_name));
          }
  
          unshift(@path_info, '', '');
  
          $env->{PATH_INFO} = join('/', @path_info);
          $env->{SCRIPT_NAME} = join('/', @script_name);
      }
  
      return $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::IIS6ScriptNameFix - fixes wrong SCRIPT_NAME and PATH_INFO that IIS6 sets
  
  =head1 SYNOPSIS
  
    # in your app.psgi
    use Plack::Builder;
  
    builder {
      enable "IIS6ScriptNameFix";
      $app;
    };
  
    # Or from the command line
    plackup -s FCGI -e 'enable "IIS6ScriptNameFix"' /path/to/app.psgi
  
  =head1 DESCRIPTION
  
  This middleware fixes wrong C<SCRIPT_NAME> and C<PATH_INFO> set by IIS6.
  
  =head1 OPTIONS
  
  =over 4
  
  =item force
  
  By default, this middleware checks if C<SERVER_SOFTWARE> PSGI environment
  matches what Microsoft IIS server 6-9 would set for FastCGI. By setting C<force>
  to true (1), this middleware always applies the fix, regardless of the
  C<SERVER_SOFTWARE> string.
  
  Use this option if the environment is broken similar to IIS, or if the IIS is
  updated and the regular expression in this module doesn't match any more
  e.g. you're running IIS 10.
  
  =back
  
  =head1 AUTHORS
  
  Florian Ragwitz
  
  =cut
PLACK_MIDDLEWARE_IIS6SCRIPTNAMEFIX

    $fatpacked{"Plack/Middleware/IIS7KeepAliveFix.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_IIS7KEEPALIVEFIX';
  package Plack::Middleware::IIS7KeepAliveFix;
  
  use strict;
  use parent 'Plack::Middleware';
  use Plack::Util;
  
  sub call {
      my($self, $env) = @_;
          # Fixes buffer being cut off on redirect when keep-alive is active
          my $res  = $self->app->($env);
  
          Plack::Util::response_cb($res, sub {
              my $res = shift;
              if ($res->[0] =~ m!^30[123]$! ) {
                  Plack::Util::header_remove($res->[1], 'Content-Length');
                  Plack::Util::header_remove($res->[1], 'Content-Type');
                 return sub{ my $chunk; return unless defined $chunk; return ''; };
              }
  
              return;
          });
  
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Middleware::IIS7KeepAliveFix - fixes buffer being cut off on redirect when keep-alive is active on IIS.
  
  =head1 SYNOPSIS
  
    # in your app.psgi
    use Plack::Builder;
  
    builder {
      enable "IIS7KeepAliveFix";
      $app;
    };
  
    # Or from the command line
    plackup -s FCGI -e 'enable "IIS7KeepAliveFix"' /path/to/app.psgi
  
  =head1 DESCRIPTION
  
  This middleware fixes buffer being cut off on redirect when keep-alive is active on IIS7.
  
  =head1 AUTHORS
  
  KnowZeroX
  
  =cut
  
PLACK_MIDDLEWARE_IIS7KEEPALIVEFIX

    $fatpacked{"Plack/Middleware/JSONP.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_JSONP';
  package Plack::Middleware::JSONP;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util;
  use URI::Escape ();
  
  use Plack::Util::Accessor qw/callback_key/;
  
  sub prepare_app {
      my $self = shift;
      unless (defined $self->callback_key) {
          $self->callback_key('callback');
      }
  }
  
  sub call {
      my($self, $env) = @_;
      my $res = $self->app->($env);
      $self->response_cb($res, sub {
          my $res = shift;
          if (defined $res->[2]) {
              my $h = Plack::Util::headers($res->[1]);
              my $callback_key = $self->callback_key;
              if ($h->get('Content-Type') =~ m!/(?:json|javascript)! &&
                  $env->{QUERY_STRING} =~ /(?:^|&)$callback_key=([^&]+)/) {
                  my $cb = URI::Escape::uri_unescape($1);
                  if ($cb =~ /^[\w\.\[\]]+$/) {
                      my $body;
                      Plack::Util::foreach($res->[2], sub { $body .= $_[0] });
                      my $jsonp = "/**/$cb($body)";
                      $res->[2] = [ $jsonp ];
                      $h->set('Content-Length', length $jsonp);
                      $h->set('Content-Type', 'text/javascript');
                  }
              }
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::JSONP - Wraps JSON response in JSONP if callback parameter is specified
  
  =head1 SYNOPSIS
  
      enable "JSONP", callback_key => 'jsonp';
  
  =head1 DESCRIPTION
  
  Plack::Middleware::JSONP wraps JSON response, which has Content-Type
  value either C<text/javascript> or C<application/json> as a JSONP
  response which is specified with the C<callback> query parameter. The
  name of the parameter can be set while enabling the middleware.
  
  This middleware only works with a non-streaming response, and doesn't
  touch the response otherwise.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_MIDDLEWARE_JSONP

    $fatpacked{"Plack/Middleware/LighttpdScriptNameFix.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_LIGHTTPDSCRIPTNAMEFIX';
  package Plack::Middleware::LighttpdScriptNameFix;
  use strict;
  use parent qw/Plack::Middleware/;
  use Plack::Util::Accessor qw(script_name);
  
  sub prepare_app {
      my $self = shift;
  
      my $script_name = $self->script_name;
      $script_name = '' unless defined($script_name);
      $script_name =~ s!/$!!;
      $self->script_name($script_name);
  }
  
  sub call {
      my($self, $env) = @_;
  
      if ($env->{SERVER_SOFTWARE} && $env->{SERVER_SOFTWARE} =~ /lighttpd/) {
          $env->{PATH_INFO}   = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
          $env->{SCRIPT_NAME} = $self->script_name;
          $env->{PATH_INFO}  =~ s/^\Q$env->{SCRIPT_NAME}\E//;
      }
  
      return $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::LighttpdScriptNameFix - fixes wrong SCRIPT_NAME and PATH_INFO that lighttpd sets
  
  =head1 SYNOPSIS
  
    # in your app.psgi
    use Plack::Builder;
  
    builder {
      enable "LighttpdScriptNameFix";
      $app;
    };
  
    # Or from the command line
    plackup -s FCGI -e 'enable "LighttpdScriptNameFix"' /path/to/app.psgi
  
  =head1 DESCRIPTION
  
  This middleware fixes wrong C<SCRIPT_NAME> and C<PATH_INFO> set by
  lighttpd when you mount your app under the root path ("/"). If you use
  lighttpd 1.4.23 or later you can instead enable C<fix-root-scriptname>
  flag inside C<fastcgi.server> instead of using this middleware.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item script_name
  
  Even with C<fix-root-scriptname>, lighttpd I<still> sets weird
  C<SCRIPT_NAME> and C<PATH_INFO> if you mount your application at C<"">
  or something that ends with C</>. Setting C<script_name> option tells
  the middleware how to reconstruct the new correct C<SCRIPT_NAME> and
  C<PATH_INFO>.
  
  If you mount the app under C</something/>, you should set:
  
    enable "LighttpdScriptNameFix", script_name => "/something";
  
  and when a request for C</something/a/b?param=1> comes, C<SCRIPT_NAME>
  becomes C</something> and C<PATH_INFO> becomes C</a/b>.
  
  C<script_name> option is set to empty by default, which means all the
  request path is set to C<PATH_INFO> and it behaves like your fastcgi
  application is mounted in the root path.
  
  =back
  
  =head1 AUTHORS
  
  Yury Zavarin
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Handler::FCGI>
  L<http://github.com/plack/Plack/issues#issue/68>
  L<https://redmine.lighttpd.net/issues/729>
  
  =cut
  
PLACK_MIDDLEWARE_LIGHTTPDSCRIPTNAMEFIX

    $fatpacked{"Plack/Middleware/Lint.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_LINT';
  package Plack::Middleware::Lint;
  use strict;
  no warnings;
  use Carp ();
  use parent qw(Plack::Middleware);
  use Scalar::Util qw(blessed reftype);
  use Plack::Util;
  
  sub wrap {
      my($self, $app) = @_;
  
      unless (reftype $app eq 'CODE' or overload::Method($app, '&{}')) {
          die("PSGI app should be a code reference: ", (defined $app ? $app : "undef"));
      }
  
      $self->SUPER::wrap($app);
  }
  
  sub call {
      my $self = shift;
      my $env = shift;
  
      $self->validate_env($env);
      my $res = $self->app->($env);
      return $self->validate_res($res);
  }
  
  sub validate_env {
      my ($self, $env) = @_;
      unless ($env->{REQUEST_METHOD}) {
          die('Missing env param: REQUEST_METHOD');
      }
      unless ($env->{REQUEST_METHOD} =~ /^[A-Z]+$/) {
          die("Invalid env param: REQUEST_METHOD($env->{REQUEST_METHOD})");
      }
      unless (defined($env->{SCRIPT_NAME})) { # allows empty string
          die('Missing mandatory env param: SCRIPT_NAME');
      }
      if ($env->{SCRIPT_NAME} eq '/') {
          die('SCRIPT_NAME must not be /');
      }
      unless (defined($env->{PATH_INFO})) { # allows empty string
          die('Missing mandatory env param: PATH_INFO');
      }
      if ($env->{PATH_INFO} ne '' && $env->{PATH_INFO} !~ m!^/!) {
          die('PATH_INFO must begin with / ($env->{PATH_INFO})');
      }
      unless (defined($env->{SERVER_NAME})) {
          die('Missing mandatory env param: SERVER_NAME');
      }
      if ($env->{SERVER_NAME} eq '') {
          die('SERVER_NAME must not be empty string');
      }
      unless (defined($env->{SERVER_PORT})) {
          die('Missing mandatory env param: SERVER_PORT');
      }
      if ($env->{SERVER_PORT} eq '') {
          die('SERVER_PORT must not be empty string');
      }
      if (defined($env->{SERVER_PROTOCOL}) and $env->{SERVER_PROTOCOL} !~ m{^HTTP/\d}) {
          die("Invalid SERVER_PROTOCOL: $env->{SERVER_PROTOCOL}");
      }
      for my $param (qw/version url_scheme input errors multithread multiprocess/) {
          unless (exists $env->{"psgi.$param"}) {
              die("Missing psgi.$param");
          }
      }
      unless (ref($env->{'psgi.version'}) eq 'ARRAY') {
          die("psgi.version should be ArrayRef: $env->{'psgi.version'}");
      }
      unless (scalar(@{$env->{'psgi.version'}}) == 2) {
          die('psgi.version should contain 2 elements, not ', scalar(@{$env->{'psgi.version'}}));
      }
      unless ($env->{'psgi.url_scheme'} =~ /^https?$/) {
          die("psgi.url_scheme should be 'http' or 'https': ", $env->{'psgi.url_scheme'});
      }
      if ($env->{"psgi.version"}->[1] == 1) { # 1.1
          for my $param (qw(streaming nonblocking run_once)) {
              unless (exists $env->{"psgi.$param"}) {
                  die("Missing psgi.$param");
              }
          }
      }
      if ($env->{HTTP_CONTENT_TYPE}) {
          die('HTTP_CONTENT_TYPE should not exist');
      }
      if ($env->{HTTP_CONTENT_LENGTH}) {
          die('HTTP_CONTENT_LENGTH should not exist');
      }
  }
  
  sub is_possibly_fh {
      my $fh = shift;
  
      ref $fh eq 'GLOB' &&
      *{$fh}{IO} &&
      *{$fh}{IO}->can('getline');
  }
  
  sub validate_res {
      my ($self, $res, $streaming) = @_;
  
      unless (ref($res) eq 'ARRAY' or ref($res) eq 'CODE') {
          die("Response should be array ref or code ref: $res");
      }
  
      if (ref $res eq 'CODE') {
          return $self->response_cb($res, sub { $self->validate_res(@_, 1) });
      }
  
      unless (@$res == 3 || ($streaming && @$res == 2)) {
          die('Response needs to be 3 element array, or 2 element in streaming');
      }
  
      unless ($res->[0] =~ /^\d+$/ && $res->[0] >= 100) {
          die("Status code needs to be an integer greater than or equal to 100: $res->[0]");
      }
  
      unless (ref $res->[1] eq 'ARRAY') {
          die("Headers needs to be an array ref: $res->[1]");
      }
  
      my @copy = @{$res->[1]};
      unless (@copy % 2 == 0) {
          die('The number of response headers needs to be even, not odd(', scalar(@copy), ')');
      }
  
      while(my($key, $val) = splice(@copy, 0, 2)) {
          if (lc $key eq 'status') {
              die('Response headers MUST NOT contain a key named Status');
          }
          if ($key =~ /[:\r\n]|[-_]$/) {
              die("Response headers MUST NOT contain a key with : or newlines, or that end in - or _. Header: $key");
          }
          unless ($key =~ /^[a-zA-Z][0-9a-zA-Z\-_]*$/) {
              die("Response headers MUST consist only of letters, digits, _ or - and MUST start with a letter. Header: $key");
          }
          if ($val =~ /[\000-\037]/) {
              die("Response headers MUST NOT contain characters below octal \037. Header: $key. Value: $val");
          }
          unless (defined $val) {
              die("Response headers MUST be a defined string. Header: $key");
          }
      }
  
      # @$res == 2 is only right in psgi.streaming, and it's already checked.
      unless (@$res == 2 ||
              ref $res->[2] eq 'ARRAY' ||
              Plack::Util::is_real_fh($res->[2]) ||
              is_possibly_fh($res->[2]) ||
              (blessed($res->[2]) && $res->[2]->can('getline'))) {
          die("Body should be an array ref or filehandle: $res->[2]");
      }
  
      if (ref $res->[2] eq 'ARRAY' && grep _has_wide_char($_), @{$res->[2]}) {
          die("Body must be bytes and should not contain wide characters (UTF-8 strings)");
      }
  
      return $res;
  }
  
  # NOTE: Some modules like HTML:: or XML:: could possibly generate
  # ASCII/Latin-1 strings with utf8 flags on. They're actually safe to
  # print, so there's no need to give warnings about it.
  sub _has_wide_char {
      my $str = shift;
      utf8::is_utf8($str) && $str =~ /[^\x00-\xff]/;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Lint - Validate request and response
  
  =head1 SYNOPSIS
  
    use Plack::Middleware::Lint;
  
    my $app = sub { ... }; # your app or middleware
    $app = Plack::Middleware::Lint->wrap($app);
  
    # Or from plackup
    plackup -e 'enable "Lint"' myapp.psgi
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Lint is a middleware component to validate request
  and response environment formats. You are strongly suggested to use
  this middleware when you develop a new framework adapter or a new PSGI
  web server that implements the PSGI interface.
  
  This middleware is enabled by default when you run plackup or other
  launcher tools with the default environment I<development> value.
  
  =head1 DEBUGGING
  
  Because of how this middleware works, it may not be easy to debug Lint
  errors when you encounter one, unless you're writing a PSGI web server
  or a framework.
  
  For example, when you're an application developer (user of some
  framework) and see errors like:
  
    Body should be an array ref or filehandle at lib/Plack/Middleware/Lint.pm line XXXX
  
  there's no clue about which line of I<your application> produces that
  error.
  
  We're aware of the issue, and have a plan to spit out more helpful
  errors to diagnose the issue. But until then, currently there are some
  workarounds to make this easier. For now, the easiest one would be to
  enable L<Plack::Middleware::REPL> outside of the Lint middleware,
  like:
  
    plackup -e 'enable "REPL"; enable "Lint"' app.psgi
  
  so that the Lint errors are caught by the REPL shell, where you can
  inspect all the variables in the response.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Tokuhiro Matsuno
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_MIDDLEWARE_LINT

    $fatpacked{"Plack/Middleware/Log4perl.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_LOG4PERL';
  package Plack::Middleware::Log4perl;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(category logger conf);
  use Carp ();
  
  sub prepare_app {
      my $self = shift;
  
      if ($self->conf) {
          require Log::Log4perl;
          Log::Log4perl::init($self->conf);
      }
  
      # NOTICE: if category = '0' you must not change it by '' (root logger)
      $self->logger( Log::Log4perl->get_logger( defined $self->category ? $self->category : '' ) );
  }
  
  sub call {
      my($self, $env) = @_;
  
      $env->{'psgix.logger'} = sub {
          my $args = shift;
          my $level = $args->{level};
          local $Log::Log4perl::caller_depth
              = $Log::Log4perl::caller_depth + 1;
          $self->logger->$level($args->{message});
      };
  
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Log4perl - Uses Log::Log4perl to configure logger
  
  =head1 SYNOPSIS
  
    my $app = sub {
        my $env =  shift;
  
        $env->{'psgix.logger'}({ level => 'error', message => 'Hi' });
  
        return [
            '200',
            [ 'Content-Type' => 'text/plain' ],
            [ "Hello World" ],
        ];
    };
  
  
    # Use your own Log4perl configuration
    use Log::Log4perl;
    Log::Log4perl::init('/path/to/log4perl.conf');
  
    builder {
        # tell the logger to log with 'plack' category
        enable "Log4perl", category => "plack";
        $app;
    }
  
  
    # Configure with Log4perl middleware options
    builder {
        enable "Log4perl", category => "plack", conf => '/path/to/log4perl.conf';
        $app;
    }
  
  =head1 DESCRIPTION
  
  Log4perl is a L<Plack::Middleware> component that allows you to use
  L<Log::Log4perl> to configure the logging object C<psgix.logger> for a
  given category.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item category
  
  The C<log4perl> category to send logs to. Defaults to C<''> which means
  it send to the root logger.
  
  =item conf
  
  The configuration file path (or a scalar ref containing the config
  string) for L<Log::Log4perl> to automatically configure.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Log::Log4perl>
  
  L<Plack::Middleware::LogDispatch>
  
  =cut
  
PLACK_MIDDLEWARE_LOG4PERL

    $fatpacked{"Plack/Middleware/LogDispatch.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_LOGDISPATCH';
  package Plack::Middleware::LogDispatch;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(logger);
  use Carp ();
  
  sub prepare_app {
      my $self = shift;
      unless ($self->logger) {
          Carp::croak "logger is not defined";
      }
  }
  
  sub call {
      my($self, $env) = @_;
  
      $env->{'psgix.logger'} = sub {
          my $args = shift;
          $args->{level} = 'critical' if $args->{level} eq 'fatal';
  
          if ( ref $args->{message} && ref $args->{message} ne 'CODE' ) {
              $args->{message} .= q{};
          }
  
          $self->logger->log(%$args);
      };
  
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::LogDispatch - Uses Log::Dispatch to configure logger
  
  =head1 SYNOPSIS
  
    use Log::Dispatch;
  
    my $logger = Log::Dispatch->new;
    $logger->add( Log::Dispatch::File->new(...) );
    $logger->add( Log::Dispatch::DesktopNotification->new(...) );
  
    builder {
        enable "LogDispatch", logger => $logger;
        $app;
    }
  
    # use with Log::Dispatch::Config
    use Log::Dispatch::Config;
    Log::Dispatch::Config->configure('/path/to/log.conf');
  
    builder {
        enable "LogDispatch", logger => Log::Dispatch::Config->instance;
        ...
    }
  
  =head1 DESCRIPTION
  
  LogDispatch is a L<Plack::Middleware> component that allows you to use
  L<Log::Dispatch> to configure the logging object, C<psgix.logger>.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item logger
  
  L<Log::Dispatch> object to send logs to. Required.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Log::Dispatch>
  
  L<Plack::Middleware::Log4perl>
  
  =cut
  
PLACK_MIDDLEWARE_LOGDISPATCH

    $fatpacked{"Plack/Middleware/NullLogger.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_NULLLOGGER';
  package Plack::Middleware::NullLogger;
  use strict;
  use parent qw/Plack::Middleware/;
  
  sub call {
      my($self, $env) = @_;
      $env->{'psgix.logger'} = sub { };
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::NullLogger - Send logs to /dev/null
  
  =head1 SYNOPSIS
  
    enable "NullLogger";
  
  =head1 DESCRIPTION
  
  NullLogger is a middleware component that receives logs and does
  nothing but discarding them. Might be useful to shut up all the logs
  from frameworks in one shot.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_NULLLOGGER

    $fatpacked{"Plack/Middleware/Proxy/AddVia.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_PROXY_ADDVIA';
  package Plack::Middleware::Proxy::AddVia;
  use strict;
  use parent 'Plack::Middleware';
  
  use Plack::Util;
  
  our $VERSION = '0.01';
  
  sub add_via {
      my ( $self, $via, $protocol, $recieved_by ) = @_;
  
      $protocol =~ s|^HTTP/||;
      return join ', ', $via || (), "$protocol $recieved_by";
  }
  
  sub make_recieved_by_from_env {
      my ( $self, $env ) = @_;
      my $host = $env->{SERVER_NAME} . (
          $env->{SERVER_PORT} == 80 ? '' : ":$env->{SERVER_PORT}"
      ) ;
      return  $host . " (" . __PACKAGE__ . "/$VERSION)";
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $recieved_by = $self->make_recieved_by_from_env( $env );
  
      $env->{HTTP_VIA} = $self->add_via( 
          $env->{HTTP_VIA}, $env->{SERVER_PROTOCOL}, $recieved_by
      );
  
      return sub {
          my $orig_respond = shift;
  
          my $respond = sub {
              my $res = shift;
              my $via = Plack::Util::header_get($res->[1], 'Via');
              Plack::Util::header_set(
                  $res->[1], 'Via' => $self->add_via(
                      $via, $env->{'plack.proxy.last_protocol'}, $recieved_by
                  )
              );
              return $orig_respond->( $res );
          };
  
          my $res = $self->app->($env);
          ref $res eq 'CODE' ? $res->( $respond ) : $respond->( $res );
      };
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Proxy::AddVia - Adds the Via header for the current host.
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
    use Plack::App::Proxy;
  
    builder {
        enable "Proxy::AddVia";
        Plack::App::Proxy->new(host => "http://10.0.1.2:8080/")->to_app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Proxy::AddVia adds the C<Via> header to the request and 
  response, like mod_proxy's C<ProxyVia> option.
  
  =head1 AUTHOR
  
  Masahiro Honma E<lt>hiratara@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Plack::App::Proxy>
  
  =cut
PLACK_MIDDLEWARE_PROXY_ADDVIA

    $fatpacked{"Plack/Middleware/Proxy/Connect.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_PROXY_CONNECT';
  package Plack::Middleware::Proxy::Connect;
  use strict;
  use warnings;
  use parent 'Plack::Middleware';
  
  use AnyEvent::Socket;
  use AnyEvent::Handle;
  
  our $VERSION = '0.01';
  
  sub call {
      my($self, $env) = @_;
      return $self->app->( $env ) unless $env->{ REQUEST_METHOD } eq 'CONNECT';
  
      my $client_fh = $env->{'psgix.io'}
                        or return [ 501, [], ['Not implemented CONNECT method']];
      my ( $host, $port ) =
                       ( $env->{REQUEST_URI} =~ m{^(?:.+\@)?(.+?)(?::(\d+))?$} );
  
      sub {
          my $respond = shift;
  
          # Run the loop by myself when psgi.nonblocking is turend off.
          my $cv = $env->{'psgi.nonblocking'} ? undef : AE::cv;
  
          tcp_connect $host, $port, sub {
              my ( $origin_fh ) = @_;
              unless( $origin_fh ){
                  $respond->( [ 502, [], ['Bad Gateway'] ] );
                  $cv->send if $cv;
                  return;
              }
  
              my $writer = $respond->( [ 200, [] ] );
  
              my $client_hdl = AnyEvent::Handle->new( fh => $client_fh );
              my $origin_hdl = AnyEvent::Handle->new( fh => $origin_fh );
  
              # Join 2 handles by a tunnel
              $client_hdl->on_read(sub {
                  my $hdl = shift;
                  my $rbuf = delete $hdl->{rbuf};
                  $origin_hdl->push_write( $rbuf );
              } );
              $client_hdl->on_error( sub {
                  my ( $hdl, $fatal, $message ) = @_;
                  $! and warn "error($fatal): $message\n";
                  $origin_hdl->push_shutdown;
                  # Finish this request.
                  $writer->close;
                  $cv->send if $cv;
                  # Use $client_hdl to keep the handle by a cyclical reference.
                  $client_hdl->destroy;
              } );
  
              $origin_hdl->on_read(sub {
                  my $hdl = shift;
                  my $rbuf = delete $hdl->{rbuf};
                  $client_hdl->push_write( $rbuf );
              } );
              $origin_hdl->on_error( sub {
                  my ( $hdl, $fatal, $message ) = @_;
                  $! and warn "error($fatal): $message\n";
                  $client_hdl->push_shutdown;
                  # Use $origin_hdl to keep the handle by a cyclical reference.
                  $origin_hdl->destroy;
              } );
          };
  
          $cv->recv if $cv;
      };
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Proxy::Connect - Handles the CONNECT method.
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
    use Plack::App::Proxy;
  
    builder {
        enable "Proxy::Connect";
        enable sub {
            my $app = shift;
            return sub {
                my $env = shift;
                ($env->{'plack.proxy.url'} = $env->{REQUEST_URI}) =~ s|^/||;
                $app->( $env );
            };
        };
        Plack::App::Proxy->new->to_app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Proxy::Connect handles the C<CONNECT> method,
  like mod_proxy's C<AllowCONNECT> option.
  
  Plack::Middleware::Proxy::Connect runs on servers supporting I<psgix.io>;
  Twiggy, Plack::Server::Coro, and so on.
  
  =head1 AUTHOR
  
  Masahiro Honma E<lt>hiratara@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Plack::App::Proxy>
  
  =cut
  
PLACK_MIDDLEWARE_PROXY_CONNECT

    $fatpacked{"Plack/Middleware/Proxy/Connect/IO.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_PROXY_CONNECT_IO';
  package Plack::Middleware::Proxy::Connect::IO;
  
  =head1 NAME
  
  Plack::Middleware::Proxy::Connect::IO - CONNECT method
  
  =head1 SYNOPSIS
  
  =for markdown ```perl
  
      # In app.psgi
      use Plack::Builder;
      use Plack::App::Proxy;
  
      builder {
          enable "Proxy::Connect::IO", timeout => 30;
          enable "Proxy::Requests";
          Plack::App::Proxy->new->to_app;
      };
  
  =for markdown ```
  
  =head1 DESCRIPTION
  
  This middleware handles the C<CONNECT> method. It allows to connect to
  C<https> addresses.
  
  The middleware runs on servers supporting C<psgix.io> and provides own
  event loop so does not work correctly with C<psgi.nonblocking> servers.
  
  The middleware uses only Perl's core modules: L<IO::Socket::INET> and
  L<IO::Select>.
  
  =for readme stop
  
  =cut
  
  use 5.006;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.0305';
  
  use parent qw(Plack::Middleware);
  
  use Plack::Util::Accessor qw(
      timeout
  );
  
  use IO::Socket::INET;
  use IO::Select;
  use Socket qw(IPPROTO_TCP TCP_NODELAY);
  
  use constant CHUNKSIZE       => 64 * 1024;
  use constant DEFAULT_TIMEOUT => 60;
  use constant READ_TIMEOUT    => 0.5;
  use constant WRITE_TIMEOUT   => 0.5;
  
  sub prepare_app {
      my ($self) = @_;
  
      # the default values
      $self->timeout(DEFAULT_TIMEOUT) unless defined $self->timeout;
  }
  
  sub call {
      my ($self, $env) = @_;
  
      return $self->app->($env)
          unless $env->{REQUEST_METHOD} eq 'CONNECT';
  
      return [501, [], ['']]
          unless $env->{'psgi.streaming'} and $env->{'psgix.io'};
  
      return sub {
          my ($respond) = @_;
  
          my $client = $env->{'psgix.io'};
  
          my ($host, $port) = $env->{REQUEST_URI} =~ m{^(?:.+\@)?(.+?)(?::(\d+))?$};
  
          my $remote = IO::Socket::INET->new(
              PeerAddr => $host,
              PeerPort => $port,
              Blocking => 0,
              Timeout  => $self->timeout,
          );
  
          if (!$remote) {
              if ($! eq 'Operation timed out') {
                  return $respond->([504, [], ['']]);
              } else {
                  return $respond->([502, [], ['']]);
              }
          }
  
          $client->blocking(0);
  
          # missing on Android
          if (eval { TCP_NODELAY }) {
              $client->setsockopt(IPPROTO_TCP, TCP_NODELAY, 1);
              $remote->setsockopt(IPPROTO_TCP, TCP_NODELAY, 1);
          }
  
          my $ioset = IO::Select->new;
  
          $ioset->add($client);
          $ioset->add($remote);
  
          my $writer = $respond->([200, []]);
  
          my $bufin = '';
          my $bufout = '';
  
      IOLOOP: while (1) {
              for my $socket ($ioset->can_read(READ_TIMEOUT)) {
                  my $read = $socket->sysread(my $chunk, CHUNKSIZE);
  
                  if ($read) {
                      if ($socket == $client) {
                          $bufout .= $chunk;
                      } elsif ($socket == $remote) {
                          $bufin .= $chunk;
                      }
                  } else {
                      $client->syswrite($bufin);
                      $client->close;
                      $remote->syswrite($bufout);
                      $remote->close;
                      last IOLOOP;
                  }
              }
  
              for my $socket ($ioset->can_write(WRITE_TIMEOUT)) {
                  if ($socket == $client and length $bufin) {
                      my $write = $socket->syswrite($bufin);
                      substr $bufin, 0, $write, '';
                  } elsif ($socket == $remote and length $bufout) {
                      my $write = $socket->syswrite($bufout);
                      substr $bufout, 0, $write, '';
                  }
              }
          }
      };
  }
  
  1;
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item timeout
  
  Timeout for the socket. The default value is C<60> seconds.
  
  =back
  
  =for readme continue
  
  =head1 SEE ALSO
  
  L<Plack>, L<Plack::App::Proxy>, L<Plack::Middleware::Proxy::Connect>.
  
  =head1 BUGS
  
  If you find the bug or want to implement new features, please report it at
  L<https://github.com/dex4er/perl-Plack-Middleware-Proxy-Connect-IO/issues>
  
  The code repository is available at
  L<http://github.com/dex4er/perl-Plack-Middleware-Proxy-Connect-IO>
  
  =head1 AUTHOR
  
  Piotr Roszatycki <dexter@cpan.org>
  
  =head1 LICENSE
  
  Copyright (c) 2014, 2016, 2023 Piotr Roszatycki <dexter@cpan.org>.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as perl itself.
  
  See L<http://dev.perl.org/licenses/artistic.html>
PLACK_MIDDLEWARE_PROXY_CONNECT_IO

    $fatpacked{"Plack/Middleware/Proxy/LoadBalancer.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_PROXY_LOADBALANCER';
  package Plack::Middleware::Proxy::LoadBalancer;
  use strict;
  use warnings;
  use parent 'Plack::Middleware';
  
  use Plack::Util::Accessor qw/backends/;
  
  our $VERSION = '0.01';
  
  sub new {
      my $class = shift;
      my %param = ref $_[0] ? %{ $_[0] } : @_;
  
      my $backends = delete $param{backends};
  
      my $self = $class->SUPER::new( \%param );
      $self->_set_backends( $backends );
  
      $self;
  }
  
  sub _set_backends{
      my $self = shift;
      my ( $backends ) = @_;
  
      # A total of 'weight' should be 1.0
      if( ref $backends eq 'ARRAY'){
          my $weight = 1 / @$backends;
          $self->backends([
              map { {remote => $_, weight => $weight} } @$backends
          ]);
      }elsif( ref $backends eq 'HASH'){
          my $total = 0;
          $total += $_ for values %$backends;
          $self->backends([ map { 
              {remote => $_, weight => $backends->{$_} / $total}
          } keys %$backends ]);
      }else{
          $self->backends([ { remote => $backends, weight => 1 } ]);
      }
  }
  
  sub select_backend {
      my $self = shift;
      my $rand = rand;
  
      my $choice = undef;
      for( @{ $self->backends } ){
          $choice = $_->{remote};
          ($rand -= $_->{weight}) <= 0 and last;
      }
  
      return $choice;
  }
  
  sub call {
      my ( $self, $env ) = @_;
      $env->{'plack.proxy.remote'} = $self->select_backend;
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Proxy::LoadBalancer - Simple load balancer
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
    use Plack::App::Proxy;
  
    builder {
      enable "Proxy::LoadBalancer", backends => ['http://10.0.0.1:8080', 'http://10.0.0.1:8081'];
      Plack::App::Proxy->new()->to_app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Proxy::LoadBalancer allow you to define several backends.
  
  =head1 OPTIONS
  
  =over 4
  
  =item backends
  
    enable "Proxy::LoadBalancer", backends => 'http://10.0.0.1:8080';
  
  Or
  
    enable "Proxy::LoadBalancer", backends => ['http://10.0.0.1:8080', 'http://10.0.0.1:8081'];
  
  Or
  
    enable "Proxy::LoadBalancer", backends => {'http://10.0.0.1:8080' => 0.4, 'http://10.0.0.1:8081' => 0.5, 'http://10.0.0.1:8002' => 0.3};
  
  More than one backend can be defined. Weight can be given to backends.
  
  =back
  
  =head1 AUTHOR
  
  Franck Cuny
  
  =head1 SEE ALSO
  
  L<Plack::App::Proxy>
  
  =cut
  
  
PLACK_MIDDLEWARE_PROXY_LOADBALANCER

    $fatpacked{"Plack/Middleware/Proxy/Requests.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_PROXY_REQUESTS';
  package Plack::Middleware::Proxy::Requests;
  
  =head1 NAME
  
  Plack::Middleware::Proxy::Requests - Forward proxy server
  
  =head1 SYNOPSIS
  
  =for markdown ```perl
  
      # In app.psgi
      use Plack::Builder;
      use Plack::App::Proxy;
  
      builder {
          enable "Proxy::Connect";
          enable "Proxy::AddVia";
          enable "Proxy::Requests";
          Plack::App::Proxy->new->to_app;
      };
  
  =for markdown ```
  
  =for markdown ```sh
  
      # From shell
      plackup -s Twiggy -E Proxy -e 'enable q{AccessLog}' app.psgi
  
      # or
      twiggy -MPlack::App::Proxy \
              -e 'enable q{AccessLog}; enable q{Proxy::Connect}; \
                  enable q{Proxy::AddVia}; enable q{Proxy::Requests}; \
                  Plack::App::Proxy->new->to_app'
  
  =for markdown ```
  
  =head1 DESCRIPTION
  
  This module handles HTTP requests as a forward proxy server.
  
  Its job is to set a C<plack.proxy.url> environment variable based on
  C<REQUEST_URI> variable.
  
  The HTTP responses from the Internet might be invalid. In that case it
  is required to run the server without L<Plack::Middleware::Lint> module.
  This module is started by default and disabled if C<-E> or
  C<--no-default-middleware> option is used when starting L<plackup>
  script. Note that this disables also L<Plack::Middleware::AccessLog> so
  it has to be enabled explicitly if needed.
  
  The default server L<Plack::Server::PSGI> alias C<Standalone> can hang
  up on the stalled connection. It is better to run a proxy server with
  L<Starlet>, L<Starman> or L<Twiggy>.
  
  =for readme stop
  
  =cut
  
  use 5.006;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.0104';
  
  use parent qw(Plack::Middleware);
  
  sub call {
      my ($self, $env) = @_;
  
      $env->{'plack.proxy.url'} = $env->{REQUEST_URI};
  
      return $self->app->($env);
  }
  
  1;
  
  __END__
  
  =for readme continue
  
  =head1 SEE ALSO
  
  L<Plack>, L<Plack::App::Proxy>, L<Plack::Middleware::Proxy::Connect>,
  L<Plack::Middleware::Proxy::AddVia>, L<Starlet>, L<Starman>, L<Twiggy>.
  
  =head1 BUGS
  
  If you find the bug or want to implement new features, please report it at
  L<https://github.com/dex4er/perl-Plack-Middleware-Proxy-Requests/issues>
  
  The code repository is available at
  L<http://github.com/dex4er/perl-Plack-Middleware-Proxy-Requests>
  
  =head1 AUTHOR
  
  Piotr Roszatycki <dexter@cpan.org>
  
  =head1 LICENSE
  
  Copyright (c) 2012-2013, 2023 Piotr Roszatycki <dexter@cpan.org>.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as perl itself.
  
  See L<http://dev.perl.org/licenses/artistic.html>
PLACK_MIDDLEWARE_PROXY_REQUESTS

    $fatpacked{"Plack/Middleware/Proxy/RewriteLocation.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_PROXY_REWRITELOCATION';
  package Plack::Middleware::Proxy::RewriteLocation;
  use strict;
  use parent 'Plack::Middleware';
  
  use Plack::Util;
  use Plack::Util::Accessor 'url_map';
  use URI;
  
  sub _different_part($$) {
      my ($from, $to) = @_;
  
      while ($from =~ m{[^/]+(?:\://$|/$|$)}g) {
          my $last_part = $&;
          last unless $to =~ /\Q$last_part\E$/;
  
          $from =~ s!\Q$last_part\E$!!;
          $to   =~ s!\Q$last_part\E$!!;
      }
  
      $from => $to;
  }
  
  sub new {
      my $self = shift->SUPER::new( @_ );
  
      # regularize the remote URLs in the URL map
      if( my $m = $self->url_map ) {
          for( my $i = 1; $i < @$m; $i += 2 ) {
              $m->[$i] = $self->_regularize_url( $m->[$i] );
          }
      }
  
      return $self;
  }
  
  sub call {
      my($self, $env) = @_;
  
      return sub {
          my $respond = shift;
  
          my $cb = $self->app->($env);
          return $respond->( $cb ) unless ref $cb eq 'CODE';
  
          $cb->(sub {
              my $res = shift;
  
              if ( $env->{HTTP_HOST} and my $location = Plack::Util::header_get($res->[1], 'Location') ) {
  
                  my @map;
                  if ($self->url_map) {
                      # regularize the format of the location so we can
                      # compare it correctly (some apps print this
                      # non-canonically)
                      $location = $self->_regularize_url( $location );
  
                      my $proxy = "$env->{'psgi.url_scheme'}://$env->{HTTP_HOST}";
                      my @url_map = @{$self->url_map};
  
                      while(my ($proxy_path, $remote) = splice @url_map, 0, 2) {
                          push @map, "$proxy$proxy_path" => $remote;
                      }
                  } else {
                      # Auto-guessing url_map
                      my $original_url = "$env->{'psgi.url_scheme'}://" . 
                                         $env->{HTTP_HOST} .
                                         $env->{SCRIPT_NAME} .
                                         $env->{PATH_INFO};
                      $original_url .= '?' . $env->{QUERY_STRING}
                          if defined $env->{QUERY_STRING} && $env->{QUERY_STRING};
                      @map = _different_part(
                          $original_url => $env->{'plack.proxy.last_url'}
                      );
                  }
  
                  while(my ($proxy_url, $remote) = splice @map, 0, 2) {
                      last if $location =~ s!^$remote!$proxy_url!;
                  }
  
                  $location =~ s!//$!/!; #< avoid double slashes
  
                  Plack::Util::header_set( $res->[1], 'Location' => $location );
              }
  
              return $respond->( $res );
          });
      };
  }
  
  sub _regularize_url {
      '' . URI->new( $_[1] )->canonical
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Proxy::RewriteLocation - Rewrites redirect headers
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
    use Plack::App::Proxy;
  
    builder {
        enable "Proxy::RewriteLocation";
        Plack::App::Proxy->new(remote => "http://10.0.1.2:8080/")->to_app;
    };
  
    ### or, if mounting (i.e. URLMap) the proxied site at /foo
  
    builder {
        enable "Proxy::RewriteLocation", url_map => [ '/foo' => http://10.0.1.2:8080' ];
        mount '/foo' => Plack::App::Proxy->new(remote => "http://10.0.1.2:8080/")->to_app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Proxy::RewriteLocation rewrites the C<Location>
  header in the response when the remote host redirects using its own
  headers, like mod_proxy's C<ProxyPassReverse> option.
  
  =head1 OPTIONS
  
  =over 4
  
  =item url_map (arrayref)
  
  If given, will account for mounted (URLMapped) Proxy apps when
  rewriting C<Location> headers.  Will be applied in order, stopping at the
  first successful match with the remote C<Location>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  Robert Buels
  
  =head1 SEE ALSO
  
  L<Plack::App::Proxy>
  
  =cut
PLACK_MIDDLEWARE_PROXY_REWRITELOCATION

    $fatpacked{"Plack/Middleware/RearrangeHeaders.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_REARRANGEHEADERS';
  package Plack::Middleware::RearrangeHeaders;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use HTTP::Headers;
  
  sub call {
      my $self = shift;
  
      my $res = $self->app->(@_);
      $self->response_cb($res, sub {
          my $res = shift;
  
          my $h = HTTP::Headers->new(@{$res->[1]});
          my @new_headers;
          $h->scan(sub { push @new_headers, @_ });
  
          $res->[1] = \@new_headers;
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::RearrangeHeaders - Reorder HTTP headers for buggy clients
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    my $app = sub {
        return [ 200, [
            'Last-Modified' => 'Wed, 23 Sep 2009 13:36:33 GMT',
            'Content-Type' => 'text/plain',
            'ETag' => 'foo bar',
        ], [ 'Hello Foo' ] ];
    };
  
    builder {
        enable "Plack::Middleware::RearrangeHeaders";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::RearrangeHeaders sorts HTTP headers based on "Good Practice" i.e.:
  
    # "Good Practice" order of HTTP message headers:
    #    - Response-Headers
    #    - Entity-Headers
  
  to work around buggy clients like very old MSIE or broken HTTP proxy
  servers. Most clients today don't (and shouldn't) care about HTTP
  header order but if you're too pedantic or have some environments
  where you need to deal with buggy clients like above, this might be
  useful.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>
  
  =cut
PLACK_MIDDLEWARE_REARRANGEHEADERS

    $fatpacked{"Plack/Middleware/Recursive.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_RECURSIVE';
  package Plack::Middleware::Recursive;
  use strict;
  use parent qw(Plack::Middleware);
  
  use Try::Tiny;
  use Scalar::Util qw(blessed);
  
  open my $null_io, "<", \"";
  
  sub call {
      my($self, $env) = @_;
  
      $env->{'plack.recursive.include'} = $self->recurse_callback($env, 1);
  
      my $res = try {
          $self->app->($env);
      } catch {
          if (blessed $_ && $_->isa('Plack::Recursive::ForwardRequest')) {
              return $self->recurse_callback($env)->($_->path);
          } else {
              die $_; # rethrow
          }
      };
  
      return $res if ref $res eq 'ARRAY';
  
      return sub {
          my $respond = shift;
  
          my $writer;
          try {
              $res->(sub { return $writer = $respond->(@_) });
          } catch {
              if (!$writer && blessed $_ && $_->isa('Plack::Recursive::ForwardRequest')) {
                  $res = $self->recurse_callback($env)->($_->path);
                  return ref $res eq 'CODE' ? $res->($respond) : $respond->($res);
              } else {
                  die $_;
              }
          };
      };
  }
  
  sub recurse_callback {
      my($self, $env, $include) = @_;
  
      my $old_path_info = $env->{PATH_INFO};
  
      return sub {
          my $new_path_info = shift;
          my($path, $query) = split /\?/, $new_path_info, 2;
  
          Scalar::Util::weaken($env);
  
          $env->{PATH_INFO}      = $path;
          $env->{QUERY_STRING}   = $query;
          $env->{REQUEST_METHOD} = 'GET';
          $env->{CONTENT_LENGTH} = 0;
          $env->{CONTENT_TYPE}   = '';
          $env->{'psgi.input'}   = $null_io;
          push @{$env->{'plack.recursive.old_path_info'}}, $old_path_info;
  
          $include ? $self->app->($env) : $self->call($env);
      };
  }
  
  package Plack::Recursive::ForwardRequest;
  use overload q("") => \&as_string, fallback => 1;
  
  sub new {
      my($class, $path) = @_;
      bless { path => $path }, $class;
  }
  
  sub path { $_[0]->{path} }
  
  sub throw {
      my($class, @args) = @_;
      die $class->new(@args);
  }
  
  sub as_string {
      my $self = shift;
      return "Forwarding to $self->{path}: Your application should be wrapped with Plack::Middleware::Recursive.";
  }
  
  package Plack::Middleware::Recursive;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Recursive - Allows PSGI apps to include or forward requests recursively
  
  =head1 SYNOPSIS
  
    # with Builder
    enable "Recursive";
  
    # in apps
    my $res = $env->{'plack.recursive.include'}->("/new_path");
  
    # Or, use exceptions
    my $app = sub {
        # ...
        Plack::Recursive::ForwardRequest->throw("/new_path");
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Recursive allows PSGI applications to recursively
  include or forward requests to other paths. Applications can make use
  of callbacks stored in C<< $env->{'plack.recursive.include'} >> to
  I<include> another path to get the response (whether it's an array ref
  or a code ref depending on your application), or throw an exception
  Plack::Recursive::ForwardRequest anywhere in the code to I<forward>
  the current request (i.e. abort the current and redo the request).
  
  =head1 EXCEPTIONS
  
  This middleware passes through unknown exceptions to the outside
  middleware stack, so if you use this middleware with other exception
  handlers such as L<Plack::Middleware::StackTrace> or
  L<Plack::Middleware::HTTPExceptions>, be sure to wrap this so
  L<Plack::Middleware::Recursive> gets as inner as possible.
  
  =head1 AUTHORS
  
  Tatsuhiko Miyagawa
  
  Masahiro Honma
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Middleware::HTTPExceptions>
  
  The idea, code and interface are stolen from Rack::Recursive and paste.recursive.
  
  =cut
  
  
PLACK_MIDDLEWARE_RECURSIVE

    $fatpacked{"Plack/Middleware/Refresh.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_REFRESH';
  package Plack::Middleware::Refresh;
  use strict;
  use parent qw(Plack::Middleware);
  use Module::Refresh;
  use Plack::Util::Accessor qw(last cooldown);
  
  sub prepare_app {
      my $self = shift;
      $self->cooldown(10) unless defined $self->cooldown;
  
      Module::Refresh->new;
      $self->last(time - $self->cooldown);
  }
  
  sub call {
      my($self, $env) = @_;
  
      if (time > $self->last + $self->cooldown) {
          Module::Refresh->refresh;
          $self->last(time);
      }
  
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Refresh - Refresh all modules in %INC
  
  =head1 SYNOPSIS
  
    enable "Refresh", cooldown => 3;
    $app;
  
  =head1 DESCRIPTION
  
  This is I<yet another> approach to refresh modules in C<%INC> during
  the development cycle, without the need to have a forking process to
  watch for filesystem updates. This middleware, in a request time,
  compares the last refresh time and the current time and if the
  difference is bigger than I<cooldown> seconds which defaults to 10,
  call L<Module::Refresh> to reload all Perl modules in C<%INC> if the
  files have been modified.
  
  Note that this only reloads modules and not other files such as
  templates.
  
  This middleware is quite similar to what Rack::Reoader does. If you
  have issues with this reloading technique, for instance when you have
  in-file templates that needs to be recompiled, or Moose classes that
  has C<make_immutable>, take a look at L<plackup>'s default -r option
  or L<Plack::Loader::Shotgun> instead.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Module::Refresh> Rack::Reloader
  
  =cut
  
PLACK_MIDDLEWARE_REFRESH

    $fatpacked{"Plack/Middleware/Runtime.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_RUNTIME';
  package Plack::Middleware::Runtime;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util;
  use Plack::Util::Accessor qw(header_name);
  use Time::HiRes;
  
  sub call {
      my($self, $env) = @_;
  
      my $start = [ Time::HiRes::gettimeofday ];
      my $res = $self->app->($env);
      my $header = $self->header_name || 'X-Runtime';
  
      $self->response_cb($res, sub {
          my $res = shift;
          my $req_time = sprintf '%.6f', Time::HiRes::tv_interval($start);
          Plack::Util::header_set($res->[1], $header, $req_time);
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Runtime - Sets an X-Runtime response header
  
  =head1 SYNOPSIS
  
    enable "Runtime";
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Runtime is a Plack middleware component that sets
  the application's response time (in seconds) in the I<X-Runtime> HTTP response
  header.
  
  =head1 OPTIONS
  
  =over 4
  
  =item header_name
  
  Name of the header. Defaults to I<X-Runtime>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Time::HiRes> Rack::Runtime
  
  =cut
PLACK_MIDDLEWARE_RUNTIME

    $fatpacked{"Plack/Middleware/SimpleContentFilter.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_SIMPLECONTENTFILTER';
  package Plack::Middleware::SimpleContentFilter;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use Plack::Util;
  use Plack::Util::Accessor qw( filter );
  
  sub call {
      my $self = shift;
  
      my $res = $self->app->(@_);
      $self->response_cb($res, sub {
          my $res = shift;
          my $h = Plack::Util::headers($res->[1]);
          return unless $h->get('Content-Type');
          if ($h->get('Content-Type') =~ m!^text/!) {
              return sub {
                  my $chunk = shift;
                  return unless defined $chunk;
                  local $_ = $chunk;
                  $self->filter->();
                  return $_;
              };
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::SimpleContentFilter - Filters response content
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    my $app = sub {
        return [ 200, [ 'Content-Type' => 'text/plain' ], [ 'Hello Foo' ] ];
    };
  
    builder {
        enable "Plack::Middleware::SimpleContentFilter",
            filter => sub { s/Foo/Bar/g; };
        $app;
    };
  
  =head1 DESCRIPTION
  
  B<This middleware should be considered as a demo. Running this against
  your application might break your HTML unless you code the filter
  callback carefully>.
  
  Plack::Middleware::SimpleContentFilter is a simple content text filter
  to run against response body. This middleware is only enabled against
  responses with C<text/*> Content-Type.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_SIMPLECONTENTFILTER

    $fatpacked{"Plack/Middleware/SimpleLogger.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_SIMPLELOGGER';
  package Plack::Middleware::SimpleLogger;
  use strict;
  use parent qw(Plack::Middleware);
  use Config ();
  use Plack::Util::Accessor qw(level);
  use POSIX ();
  use Scalar::Util ();
  
  # Should this be in Plack::Util?
  my $i = 0;
  my %level_numbers = map { $_ => $i++ } qw(debug info warn error fatal);
  
  sub call {
      my($self, $env) = @_;
  
      my $min = $level_numbers{ $self->level || "debug" };
  
      my $env_ref = $env;
      Scalar::Util::weaken($env_ref);
  
      $env->{'psgix.logger'} = sub {
          my $args = shift;
  
          if ($level_numbers{$args->{level}} >= $min) {
              $env_ref->{'psgi.errors'}->print($self->format_message($args->{level}, $args->{message}));
          }
      };
  
      $self->app->($env);
  }
  
  sub format_time {
      my $old_locale;
      if ( $Config::config{d_setlocale} ) {
          $old_locale = POSIX::setlocale(&POSIX::LC_ALL);
          POSIX::setlocale(&POSIX::LC_ALL, 'C');
      }
      my $out = POSIX::strftime(@_);
      if ( $Config::config{d_setlocale} ) {
          POSIX::setlocale(&POSIX::LC_ALL, $old_locale);
      };
      return $out;
  }
  
  sub format_message {
      my($self, $level, $message) = @_;
  
      my $time = format_time("%Y-%m-%dT%H:%M:%S", localtime);
      sprintf "%s [%s #%d] %s: %s\n", uc substr($level, 0, 1), $time, $$, uc $level, $message;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::SimpleLogger - Simple logger that prints to psgi.errors
  
  =head1 SYNOPSIS
  
    enable "SimpleLogger", level => "warn";
  
  =head1 DESCRIPTION
  
  SimpleLogger is a middleware component that formats the log message
  with information such as the time and PID and prints them to
  I<psgi.errors> stream, which is mostly STDERR or server log output.
  
  =head1 SEE ALSO
  
  L<Plack::Middleware::LogErrors>, essentially the opposite of this module
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_SIMPLELOGGER

    $fatpacked{"Plack/Middleware/StackTrace.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_STACKTRACE';
  package Plack::Middleware::StackTrace;
  use strict;
  use warnings;
  use parent qw/Plack::Middleware/;
  use Devel::StackTrace;
  use Devel::StackTrace::AsHTML;
  use Scalar::Util qw( refaddr );
  use Try::Tiny;
  use Plack::Util::Accessor qw( force no_print_errors );
  
  our $StackTraceClass = "Devel::StackTrace";
  
  # Optional since it needs PadWalker
  if (try { require Devel::StackTrace::WithLexicals; Devel::StackTrace::WithLexicals->VERSION(0.08); 1 }) {
      $StackTraceClass = "Devel::StackTrace::WithLexicals";
  }
  
  sub call {
      my($self, $env) = @_;
  
      my ($trace, %string_traces, %ref_traces);
      local $SIG{__DIE__} = sub {
          $trace = $StackTraceClass->new(
              indent => 1, message => munge_error($_[0], [ caller ]),
              ignore_package => __PACKAGE__, no_refs => 1,
          );
          if (ref $_[0]) {
              $ref_traces{refaddr($_[0])} ||= $trace;
          }
          else {
              $string_traces{$_[0]} ||= $trace;
          }
          die @_;
      };
  
      my $caught;
      my $res = try {
          $self->app->($env);
      } catch {
          $caught = $_;
          [ 500, [ "Content-Type", "text/plain; charset=utf-8" ], [ no_trace_error(utf8_safe($caught)) ] ];
      };
  
      if ($caught) {
          # Try to find the correct trace for the caught exception
          my $caught_trace;
          if (ref $caught) {
              $caught_trace = $ref_traces{refaddr($caught)};
          }
          else {
              # This is not guaranteed to work if multiple exceptions with
              # the same message are thrown.
              $caught_trace = $string_traces{$caught};
          }
          $trace = $caught_trace if $caught_trace;
      }
  
      if ($trace && ($caught || ($self->force && ref $res eq 'ARRAY' && $res->[0] == 500)) ) {
          my $text = $trace->as_string;
          my $html = $trace->as_html;
          $env->{'plack.stacktrace.text'} = $text;
          $env->{'plack.stacktrace.html'} = $html;
          $env->{'psgi.errors'}->print($text) unless $self->no_print_errors;
          if (($env->{HTTP_ACCEPT} || '*/*') =~ /html/) {
              $res = [500, ['Content-Type' => 'text/html; charset=utf-8'], [ utf8_safe($html) ]];
          } else {
              $res = [500, ['Content-Type' => 'text/plain; charset=utf-8'], [ utf8_safe($text) ]];
          }
      }
  
      # break $trace here since $SIG{__DIE__} holds the ref to it, and
      # $trace has refs to Standalone.pm's args ($conn etc.) and
      # prevents garbage collection to be happening.
      undef $trace;
  
      return $res;
  }
  
  sub no_trace_error {
      my $msg = shift;
      chomp($msg);
  
      return <<EOF;
  The application raised the following error:
  
    $msg
  
  and the StackTrace middleware couldn't catch its stack trace, possibly because your application overrides \$SIG{__DIE__} by itself, preventing the middleware from working correctly. Remove the offending code or module that does it: known examples are CGI::Carp and Carp::Always.
  EOF
  }
  
  sub munge_error {
      my($err, $caller) = @_;
      return $err if ref $err;
  
      # Ugly hack to remove " at ... line ..." automatically appended by perl
      # If there's a proper way to do this, please let me know.
      $err =~ s/ at \Q$caller->[1]\E line $caller->[2]\.\n$//;
  
      return $err;
  }
  
  sub utf8_safe {
      my $str = shift;
  
      # NOTE: I know messing with utf8:: in the code is WRONG, but
      # because we're running someone else's code that we can't
      # guarantee which encoding an exception is encoded, there's no
      # better way than doing this. The latest Devel::StackTrace::AsHTML
      # (0.08 or later) encodes high-bit chars as HTML entities, so this
      # path won't be executed.
      if (utf8::is_utf8($str)) {
          utf8::encode($str);
      }
  
      $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::StackTrace - Displays stack trace when your app dies
  
  =head1 SYNOPSIS
  
    enable "StackTrace";
  
  =head1 DESCRIPTION
  
  This middleware uses C<$SIG{__DIE__}> to intercept I<all> exceptions
  (run-time errors) happening in your application, even those that are caught.
  For each exception it builds a detailed stack trace.
  
  If the applications aborts by throwing an exception it will be caught and matched
  against the saved stack traces. If a match is found it will be displayed as a nice
  stack trace screen, if not then the exception will be reported without a stack trace.
  
  The stack trace is also stored in the environment as a plaintext and HTML under the key
  C<plack.stacktrace.text> and C<plack.stacktrace.html> respectively, so
  that middleware further up the stack can reference it.
  
  This middleware is enabled by default when you run L<plackup> in the
  default I<development> mode.
  
  You're recommended to use this middleware during the development and
  use L<Plack::Middleware::HTTPExceptions> in the deployment mode as a
  replacement, so that all the exceptions thrown from your application
  still get caught and rendered as a 500 error response, rather than
  crashing the web server.
  
  Catching errors in streaming response is not supported.
  
  =head2 Stack Trace Module
  
  The L<Devel::StackTrace::WithLexicals> module will be used to capture the stack trace
  if the installed version is 0.08 or later. Otherwise L<Devel::StackTrace> is used.
  
  =head2 Performance
  
  Gathering the information for a stack trace via L<Devel::StackTrace> is slow,
  and L<Devel::StackTrace::WithLexicals> is significantly slower still.
  This is not usually a concern in development and when exceptions are rare.
  However, your application may include code that's throwing and catching exceptions
  that you're not aware of. Such code will run I<significantly> slower with this module.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item force
  
    enable "StackTrace", force => 1;
  
  Force display the stack trace when an error occurs within your
  application and the response code from your application is
  500. Defaults to off.
  
  The use case of this option is that when your framework catches all
  the exceptions in the main handler and returns all failures in your
  code as a normal 500 PSGI error response. In such cases, this
  middleware would never have a chance to display errors because it
  can't tell if it's an application error or just random C<eval> in your
  code. This option enforces the middleware to display stack trace even
  if it's not the direct error thrown by the application.
  
  =item no_print_errors
  
    enable "StackTrace", no_print_errors => 1;
  
  Skips printing the text stacktrace to console
  (C<psgi.errors>). Defaults to 0, which means the text version of the
  stack trace error is printed to the errors handle, which usually is a
  standard error.
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Devel::StackTrace::AsHTML> L<Plack::Middleware> L<Plack::Middleware::HTTPExceptions>
  
  =cut
  
PLACK_MIDDLEWARE_STACKTRACE

    $fatpacked{"Plack/Middleware/Static.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_STATIC';
  package Plack::Middleware::Static;
  use strict;
  use warnings;
  use parent qw/Plack::Middleware/;
  use Plack::App::File;
  
  use Plack::Util::Accessor qw( path root encoding pass_through content_type );
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $res = $self->_handle_static($env);
      if ($res && not ($self->pass_through and $res->[0] == 404)) {
          return $res;
      }
  
      return $self->app->($env);
  }
  
  sub _handle_static {
      my($self, $env) = @_;
  
      my $path_match = $self->path or return;
      my $path = $env->{PATH_INFO};
  
      for ($path) {
          my $matched = 'CODE' eq ref $path_match ? $path_match->($_, $env) : $_ =~ $path_match;
          return unless $matched;
      }
  
      $self->{file} ||= Plack::App::File->new({ root => $self->root || '.', encoding => $self->encoding, content_type => $self->content_type });
      local $env->{PATH_INFO} = $path; # rewrite PATH
      return $self->{file}->call($env);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Static - serve static files with Plack
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::Static",
            path => qr{^/(images|js|css)/}, root => './htdocs/';
        $app;
    };
  
  =head1 DESCRIPTION
  
  This middleware allows your Plack-based application to serve static files.
  
  Note that if you are building an app using L<Plack::App::URLMap>, you should
  consider using L<Plack::App::File> to serve static files instead. This makes
  the overall routing of your application simpler to understand.
  
  With this middleware, if a static file exists for the requested path, it will
  be served. If it does not exist, by default this middleware returns a 404, but
  you can set the C<pass_through> option to change this behavior.
  
  If the requested document is not within the C<root> or the file is there but
  not readable, this middleware will return a 403 Forbidden response.
  
  The content type returned will be determined from the file extension by using
  L<Plack::MIME> or using C<content_type>.
  
  =head1 CONFIGURATIONS
  
  =over 4
  
  =item path, root
  
    enable "Plack::Middleware::Static",
        path => qr{^/static/}, root => 'htdocs/';
  
  The C<path> option specifies the URL pattern (regular expression) or a
  callback to match against requests. If the <path> option matches, the
  middleware looks in C<root> to find the static files to serve. The default
  value of C<root> is the current directory.
  
  This example configuration serves C</static/foo.jpg> from
  C<htdocs/static/foo.jpg>. Note that the matched portion of the path,
  C</static/>, still appears in the locally mapped path under C<root>. If you
  don't want this to happen, you can use a callback to munge the path as you
  match it:
  
    enable "Plack::Middleware::Static",
        path => sub { s!^/static/!! }, root => 'static-files/';
  
  The callback should operate on C<$_> and return a true or false value. Any
  changes it makes to C<$_> are used when looking for the static file in the
  C<root>.
  
  The configuration above serves C</static/foo.png> from
  C<static-files/foo.png>, not C<static-files/static/foo.png>. The callback
  specified in the C<path> option matches against C<$_> munges this value using
  C<s///>. The substitution operator returns the number of matches it made, so it
  will return true when the path matches C<^/static>.
  
  For more complex static handling in the C<path> callback, in addition
  to C<$_> being set the callback receives two arguments, C<PATH_INFO>
  (same as C<$_>) and C<$env>.
  
  If you want to map multiple static directories from different roots, simply
  add this middleware multiple times with different configuration options.
  
  =item pass_through
  
  When this option is set to a true value, then this middleware will never
  return a 404 if it cannot find a matching file. Instead, it will simply pass
  the request on to the application it is wrapping.
  
  =item content_type
  
  The C<content_type> option can be used to provide access to a different MIME 
  database than L<Plack::MIME>.
  L<Plack::MIME> works fast and good for a list of well known file endings, 
  but if you need a more accurate content based checking you can use modules
  like L<File::MimeInfo> or L<File::MMagic> for example.
  The callback should work on $_[0] which is the filename of the file.
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno, Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Middleware> L<Plack::Builder>
  
  =cut
  
  
PLACK_MIDDLEWARE_STATIC

    $fatpacked{"Plack/Middleware/TrafficLog.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_TRAFFICLOG';
  package Plack::Middleware::TrafficLog;
  
  =head1 NAME
  
  Plack::Middleware::TrafficLog - Log headers and body of HTTP traffic
  
  =head1 SYNOPSIS
  
    # In app.psgi
    use Plack::Builder;
  
    builder {
        enable "TrafficLog", with_body => 1;
    };
  
  =head1 DESCRIPTION
  
  This middleware logs the request and response messages with detailed
  information about headers and body.
  
  The example log:
  
    [08/Aug/2012:16:59:47 +0200] [164836368] [127.0.0.1 -> 0:5000] [Request ]
    |GET / HTTP/1.1|Connection: TE, close|Host: localhost:5000|TE: deflate,gzi
    p;q=0.3|User-Agent: lwp-request/6.03 libwww-perl/6.03||
    [08/Aug/2012:16:59:47 +0200] [164836368] [127.0.0.1 <- 0:5000] [Response]
    |HTTP/1.0 200 OK|Content-Type: text/plain||Hello World
  
  This module works also with applications which have delayed response. In that
  case each chunk is logged separately and shares the same unique ID number and
  headers.
  
  The body of request and response is not logged by default. For streaming
  responses only first chunk is logged by default.
  
  =for readme stop
  
  =cut
  
  
  use 5.008;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.0401';
  
  
  use parent 'Plack::Middleware';
  
  use Plack::Util::Accessor qw(
      with_request with_response with_date with_body with_all_chunks eol body_eol logger
      _counter _call_id _strftime
  );
  
  
  use Plack::Util;
  
  use Plack::Request;
  use Plack::Response;
  
  use POSIX ();
  use POSIX::strftime::Compiler ();
  use Scalar::Util ();
  
  
  sub prepare_app {
      my ($self) = @_;
  
      # the default values
      $self->with_request(Plack::Util::TRUE)     unless defined $self->with_request;
      $self->with_response(Plack::Util::TRUE)    unless defined $self->with_response;
      $self->with_date(Plack::Util::TRUE)        unless defined $self->with_date;
      $self->with_body(Plack::Util::FALSE)       unless defined $self->with_body;
      $self->with_all_chunks(Plack::Util::FALSE) unless defined $self->with_all_chunks;
      $self->body_eol(defined $self->eol ? $self->eol : ' ') unless defined $self->body_eol;
      $self->eol('|')         unless defined $self->eol;
  
      $self->_strftime(POSIX::strftime::Compiler->new('%d/%b/%Y:%H:%M:%S %z'));
  
      $self->_counter(0);
  };
  
  
  sub _log_message {
      my ($self, $type, $env, $status, $headers, $body) = @_;
  
      my $logger = $self->logger || sub { $env->{'psgi.errors'}->print(@_) };
  
      my $server_addr = sprintf '%s:%s', $env->{SERVER_NAME}, $env->{SERVER_PORT};
      my $remote_addr = defined $env->{REMOTE_PORT}
          ? sprintf '%s:%s', $env->{REMOTE_ADDR}, $env->{REMOTE_PORT}
          : $env->{REMOTE_ADDR};
  
      my $eol = $self->eol;
      my $body_eol = $self->body_eol;
      $body =~ s/\015?\012/$body_eol/gs if defined $body_eol;
  
      my $date = $self->with_date
          ? ('['. $self->_strftime->to_string(localtime) . '] ')
          : '';
  
      $logger->( sprintf "%s[%s] [%s %s %s] [%s] %s%s%s%s%s%s\n",
          $date,
          $self->_call_id,
  
          $remote_addr,
          $type eq 'Request ' ? '->' : $type eq 'Response' ? '<-' : '--',
          $server_addr,
  
          $type,
  
          $eol,
          $status,
          $eol,
          $headers->as_string($eol),
          $eol,
          $body,
      );
  };
  
  
  sub _log_request {
      my ($self, $env) = @_;
  
      my $req = Plack::Request->new($env);
  
      my $status = sprintf '%s %s %s', $req->method, $req->request_uri, $req->protocol;
      my $headers = $req->headers;
      my $body = $self->with_body ? $req->content : '';
  
      $self->_log_message('Request ', $env, $status, $headers, $body);
  };
  
  
  sub _log_response {
      my ($self, $env, $ret) = @_;
  
      my $res = Plack::Response->new(@$ret);
  
      my $status_code = $res->status;
      my $status_message = HTTP::Status::status_message($status_code);
  
      my $status = sprintf 'HTTP/1.0 %s %s', $status_code, defined $status_message ? $status_message : '';
      my $headers = $res->headers;
      my $body = '';
      if ($self->with_body) {
          $body = $res->content;
          $body = '' unless defined $body;
          $body = join '', grep { defined $_ } @$body if ref $body eq 'ARRAY';
      }
  
      $self->_log_message('Response', $env, $status, $headers, $body);
  };
  
  
  sub call {
      my ($self, $env) = @_;
  
      $self->_call_id(sprintf '%015d',
          time % 2**16 * 2**32 +
          (Scalar::Util::looks_like_number $env->{REMOTE_PORT} ? $env->{REMOTE_PORT} : int rand 2**16) % 2**16 * 2**16 +
          $self->_counter % 2**16);
      $self->_counter($self->_counter + 1);
  
      # Preprocessing
      $self->_log_request($env) if $self->with_request;
  
      # $self->app is the original app
      my $res = $self->app->($env);
  
      # Postprocessing
      return $self->with_response ? $self->response_cb($res, sub {
          my ($ret) = @_;
          my $seen;
          return sub {
              my ($chunk) = @_;
              return if $seen and not defined $chunk;
              return $chunk if $seen and not $self->with_all_chunks;
              $self->_log_response($env, [ $ret->[0], $ret->[1], [$chunk] ]);
              $seen = Plack::Util::TRUE;
              return $chunk;
          };
      }) : $res;
  };
  
  
  1;
  
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item logger
  
    # traffic.l4p
    log4perl.logger.traffic = DEBUG, LogfileTraffic
    log4perl.appender.LogfileTraffic = Log::Log4perl::Appender::File
    log4perl.appender.LogfileTraffic.filename = traffic.log
    log4perl.appender.LogfileTraffic.layout = PatternLayout
    log4perl.appender.LogfileTraffic.layout.ConversionPattern = %m{chomp}%n
  
    # app.psgi
    use Log::Log4perl qw(:levels get_logger);
    Log::Log4perl->init('traffic.l4p');
    my $logger = get_logger('traffic');
  
    enable "Plack::Middleware::TrafficLog",
        logger => sub { $logger->log($INFO, join '', @_) };
  
  Sets a callback to print log message to. It prints to C<psgi.errors> output
  stream by default.
  
  =item with_request
  
  The false value disables logging of request message.
  
  =item with_response
  
  The false value disables logging of response message.
  
  =item with_date
  
  The false value disables logging of current date.
  
  =item with_body
  
  The true value enables logging of message's body.
  
  =item with_all_chunks
  
  The true value enables logging of every chunk for streaming responses.
  
  =item eol
  
  Sets the line separator for message's headers and body. The default value is
  the pipe character C<|>.
  
  =item body_eol
  
  Sets the line separator for message's body only. The default is the space
  character C< >. The default value is used only if B<eol> is also undefined.
  
  =back
  
  =for readme continue
  
  =head1 SEE ALSO
  
  L<Plack>, L<Plack::Middleware::AccessLog>.
  
  =head1 BUGS
  
  This module has unstable API and it can be changed in future.
  
  The log file can contain the binary data if the PSGI server provides binary
  files.
  
  If you find the bug or want to implement new features, please report it at
  L<http://github.com/dex4er/perl-Plack-Middleware-TrafficLog/issues>
  
  The code repository is available at
  L<http://github.com/dex4er/perl-Plack-Middleware-TrafficLog>
  
  =head1 AUTHOR
  
  Piotr Roszatycki <dexter@cpan.org>
  
  =head1 LICENSE
  
  Copyright (c) 2012, 2014-2015 Piotr Roszatycki <dexter@cpan.org>.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as perl itself.
  
  See L<http://dev.perl.org/licenses/artistic.html>
PLACK_MIDDLEWARE_TRAFFICLOG

    $fatpacked{"Plack/Middleware/XFramework.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_XFRAMEWORK';
  package Plack::Middleware::XFramework;
  use strict;
  use warnings;
  use parent qw/Plack::Middleware/;
  
  use Plack::Util;
  use Plack::Util::Accessor qw( framework );
  
  sub call {
      my $self = shift;
  
      my $res = $self->app->( @_ );
      $self->response_cb($res, sub {
          my $res = shift;
          if ($self->framework) {
              Plack::Util::header_set $res->[1], 'X-Framework' => $self->framework;
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::XFramework - Sample middleware to add X-Framework
  
  =head1 SYNOPSIS
  
    enable "Plack::Middleware::XFramework", framework => "Catalyst";
  
  =head1 DESCRIPTION
  
  This middleware adds C<X-Framework> header to the HTTP response.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item framework
  
  Sets the string value of C<X-Framework> header. If not set, the header is not set to the response.
  
  =back
  
  =head1 SEE ALSO
  
  L<Plack::Middleware>
  
  =cut
  
PLACK_MIDDLEWARE_XFRAMEWORK

    $fatpacked{"Plack/Middleware/XSendfile.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_MIDDLEWARE_XSENDFILE';
  package Plack::Middleware::XSendfile;
  use strict;
  use warnings;
  use parent qw(Plack::Middleware);
  
  use Plack::Util;
  use Scalar::Util;
  use Plack::Util::Accessor qw( variation );
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $res = $self->app->($env);
      $self->response_cb($res, sub {
          my $res = shift;
          my($status, $headers, $body) = @$res;
          return unless defined $body;
  
          if (Scalar::Util::blessed($body) && $body->can('path')) {
              my $type = $self->_variation($env) || '';
              my $h = Plack::Util::headers($headers);
              if ($type && !$h->exists($type)) {
                  if ($type eq 'X-Accel-Redirect') {
                      my $path = $body->path;
                      my $url = $self->map_accel_path($env, $path);
                      $h->set($type => $url) if $url;
                      $h->set('Content-Length', 0);
                      $body = [];
                  } elsif ($type eq 'X-Sendfile' or $type eq 'X-Lighttpd-Send-File') {
                      my $path = $body->path;
                      $h->set($type => $path) if defined $path;
                      $h->set('Content-Length', 0);
                      $body = [];
                  } else {
                      $env->{'psgi.errors'}->print("Unknown x-sendfile variation: $type");
                  }
              }
          }
  
          @$res = ( $status, $headers, $body );
      });
  }
  
  sub map_accel_path {
      my($self, $env, $path) = @_;
  
      if (my $mapping = $env->{HTTP_X_ACCEL_MAPPING}) {
          my($internal, $external) = split /=/, $mapping, 2;
          $path =~ s!^\Q$internal\E!$external!i;
      }
  
      return $path;
  }
  
  sub _variation {
      my($self, $env) = @_;
      $self->variation || $env->{'plack.xsendfile.type'} || $env->{HTTP_X_SENDFILE_TYPE};
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::XSendfile - Sets X-Sendfile (or a like) header for frontends
  
  =head1 SYNOPSIS
  
    enable "Plack::Middleware::XSendfile";
  
  =head1 DESCRIPTION
  
  When the body is a blessed reference with a C<path> method, then the
  return value of that method is used to set the X-Sendfile header.
  
  The body is set to an empty list, and the Content-Length header is
  set to 0.
  
  If the X-Sendfile header is already set, then the body and
  Content-Length will be untouched.
  
  You should use L<IO::File::WithPath> or L<Plack::Util>'s
  C<set_io_path> to add C<path> method to an IO object in the body.
  
  See L<http://github.com/rack/rack-contrib/blob/master/lib/rack/contrib/sendfile.rb>
  for the frontend configuration.
  
  Plack::Middleware::XSendfile does not set the Content-Type header.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item variation
  
  The header tag to use. If unset, the environment key
  C<plack.xsendfile.type> will be used, then the C<HTTP_X_SENDFILE_TYPE>
  header.
  
  Supported values are:
  
  =over
  
  =item * C<X-Accel-Redirect>
  
  =item * C<X-Lighttpd-Send-File>
  
  =item * C<X-Sendfile>.
  
  =back
  
  An unsupport value will log an error.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_XSENDFILE

    $fatpacked{"Plack/Request.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_REQUEST';
  package Plack::Request;
  use strict;
  use warnings;
  use 5.008_001;
  our $VERSION = '1.0050';
  
  use HTTP::Headers::Fast;
  use Carp ();
  use Hash::MultiValue;
  
  use Plack::Request::Upload;
  use Stream::Buffered;
  use URI;
  use URI::Escape ();
  use Cookie::Baker ();
  
  use HTTP::Entity::Parser;
  use WWW::Form::UrlEncoded qw/parse_urlencoded_arrayref/;
  
  sub new {
      my($class, $env) = @_;
      Carp::croak(q{$env is required})
          unless defined $env && ref($env) eq 'HASH';
  
      bless { env => $env }, $class;
  }
  
  sub env { $_[0]->{env} }
  
  sub address     { $_[0]->env->{REMOTE_ADDR} }
  sub remote_host { $_[0]->env->{REMOTE_HOST} }
  sub protocol    { $_[0]->env->{SERVER_PROTOCOL} }
  sub method      { $_[0]->env->{REQUEST_METHOD} }
  sub port        { $_[0]->env->{SERVER_PORT} }
  sub user        { $_[0]->env->{REMOTE_USER} }
  sub request_uri { $_[0]->env->{REQUEST_URI} }
  sub path_info   { $_[0]->env->{PATH_INFO} }
  sub path        { $_[0]->env->{PATH_INFO} || '/' }
  sub query_string{ $_[0]->env->{QUERY_STRING} }
  sub script_name { $_[0]->env->{SCRIPT_NAME} }
  sub scheme      { $_[0]->env->{'psgi.url_scheme'} }
  sub secure      { $_[0]->scheme eq 'https' }
  sub body        { $_[0]->env->{'psgi.input'} }
  sub input       { $_[0]->env->{'psgi.input'} }
  
  sub content_length   { $_[0]->env->{CONTENT_LENGTH} }
  sub content_type     { $_[0]->env->{CONTENT_TYPE} }
  
  sub session         { $_[0]->env->{'psgix.session'} }
  sub session_options { $_[0]->env->{'psgix.session.options'} }
  sub logger          { $_[0]->env->{'psgix.logger'} }
  
  sub cookies {
      my $self = shift;
  
      return {} unless $self->env->{HTTP_COOKIE};
  
      # HTTP_COOKIE hasn't changed: reuse the parsed cookie
      if (   $self->env->{'plack.cookie.parsed'}
          && $self->env->{'plack.cookie.string'} eq $self->env->{HTTP_COOKIE}) {
          return $self->env->{'plack.cookie.parsed'};
      }
  
      $self->env->{'plack.cookie.string'} = $self->env->{HTTP_COOKIE};
      $self->env->{'plack.cookie.parsed'} = Cookie::Baker::crush_cookie($self->env->{'plack.cookie.string'});
  }
  
  sub content {
      my $self = shift;
  
      unless ($self->env->{'psgix.input.buffered'}) {
          $self->_parse_request_body;
      }
  
      my $fh = $self->input                 or return '';
      my $cl = $self->env->{CONTENT_LENGTH} or return '';
  
      $fh->seek(0, 0); # just in case middleware/apps read it without seeking back
      $fh->read(my($content), $cl, 0);
      $fh->seek(0, 0);
  
      return $content;
  }
  
  sub raw_body { $_[0]->content }
  
  # XXX you can mutate headers with ->headers but it's not written through to the env
  
  sub headers {
      my $self = shift;
      if (!defined $self->{headers}) {
          my $env = $self->env;
          $self->{headers} = HTTP::Headers::Fast->new(
              map {
                  (my $field = $_) =~ s/^HTTPS?_//;
                  ( lc($field) => $env->{$_} );
              }
                  grep { /^(?:HTTP|CONTENT)/i } keys %$env
              );
      }
      $self->{headers};
  }
  
  sub content_encoding { shift->headers->content_encoding(@_) }
  sub header           { shift->headers->header(@_) }
  sub referer          { shift->headers->referer(@_) }
  sub user_agent       { shift->headers->user_agent(@_) }
  
  sub _body_parameters {
      my $self = shift;
      unless ($self->env->{'plack.request.body_parameters'}) {
          $self->_parse_request_body;
      }
      return $self->env->{'plack.request.body_parameters'};
  }
  
  sub _query_parameters {
      my $self = shift;
      $self->env->{'plack.request.query_parameters'} ||= parse_urlencoded_arrayref($self->env->{'QUERY_STRING'});
  }
  
  sub query_parameters {
      my $self = shift;
      $self->env->{'plack.request.query'} ||= Hash::MultiValue->new(@{$self->_query_parameters});
  }
  
  sub body_parameters {
      my $self = shift;
      $self->env->{'plack.request.body'} ||= Hash::MultiValue->new(@{$self->_body_parameters});
  }
  
  # contains body + query
  sub parameters {
      my $self = shift;
  
      $self->env->{'plack.request.merged'} ||= do {
          Hash::MultiValue->new(
              @{$self->_query_parameters},
              @{$self->_body_parameters}
          );
      };
  }
  
  sub uploads {
      my $self = shift;
  
      if ($self->env->{'plack.request.upload'}) {
          return $self->env->{'plack.request.upload'};
      }
  
      $self->_parse_request_body;
      return $self->env->{'plack.request.upload'};
  }
  
  sub param {
      my $self = shift;
  
      return keys %{ $self->parameters } if @_ == 0;
  
      my $key = shift;
      return $self->parameters->{$key} unless wantarray;
      return $self->parameters->get_all($key);
  }
  
  sub upload {
      my $self = shift;
  
      return keys %{ $self->uploads } if @_ == 0;
  
      my $key = shift;
      return $self->uploads->{$key} unless wantarray;
      return $self->uploads->get_all($key);
  }
  
  sub uri {
      my $self = shift;
  
      my $base = $self->_uri_base;
  
      # We have to escape back PATH_INFO in case they include stuff like
      # ? or # so that the URI parser won't be tricked. However we should
      # preserve '/' since encoding them into %2f doesn't make sense.
      # This means when a request like /foo%2fbar comes in, we recognize
      # it as /foo/bar which is not ideal, but that's how the PSGI PATH_INFO
      # spec goes and we can't do anything about it. See PSGI::FAQ for details.
  
      # See RFC 3986 before modifying.
      my $path_escape_class = q{^/;:@&=A-Za-z0-9\$_.+!*'(),-};
  
      my $path = URI::Escape::uri_escape($self->env->{PATH_INFO} || '', $path_escape_class);
      $path .= '?' . $self->env->{QUERY_STRING}
          if defined $self->env->{QUERY_STRING} && $self->env->{QUERY_STRING} ne '';
  
      $base =~ s!/$!! if $path =~ m!^/!;
  
      return URI->new($base . $path)->canonical;
  }
  
  sub base {
      my $self = shift;
      URI->new($self->_uri_base)->canonical;
  }
  
  sub _uri_base {
      my $self = shift;
  
      my $env = $self->env;
  
      my $uri = ($env->{'psgi.url_scheme'} || "http") .
          "://" .
          ($env->{HTTP_HOST} || (($env->{SERVER_NAME} || "") . ":" . ($env->{SERVER_PORT} || 80))) .
          ($env->{SCRIPT_NAME} || '/');
  
      return $uri;
  }
  
  sub new_response {
      my $self = shift;
      require Plack::Response;
      Plack::Response->new(@_);
  }
  
  sub request_body_parser {
      my $self = shift;
      $self->{request_body_parser} ||= $self->_build_body_parser;
  }
  
  sub _build_body_parser {
      my $self = shift;
  
      my $len = $self->_buffer_length_for($self->env);
  
      my $parser = HTTP::Entity::Parser->new(buffer_length => $len);
      $parser->register('application/x-www-form-urlencoded', 'HTTP::Entity::Parser::UrlEncoded');
      $parser->register('multipart/form-data', 'HTTP::Entity::Parser::MultiPart');
  
      $parser;
  }
  
  sub _buffer_length_for {
      my($self, $env) = @_;
  
      return $ENV{PLACK_BUFFER_LENGTH} if defined $ENV{PLACK_BUFFER_LENGTH};
  
      if ($env->{'psgix.input.buffered'}) {
          return 1024 * 1024; # 1MB for buffered
      } else {
          return 1024 * 64; # 64K for unbuffered
      }
  }
  
  sub _parse_request_body {
      my $self = shift;
  
      my ($params,$uploads) = $self->request_body_parser->parse($self->env);
      $self->env->{'plack.request.body_parameters'} = $params;
  
      my $upload_hash = Hash::MultiValue->new();
      while ( my ($k,$v) = splice @$uploads, 0, 2 ) {
          my %copy = %$v;
          $copy{headers} = HTTP::Headers::Fast->new(@{$v->{headers}});
          $upload_hash->add($k, Plack::Request::Upload->new(%copy));
      }
      $self->env->{'plack.request.upload'} = $upload_hash;
      1;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Request - Portable HTTP request object from PSGI env hash
  
  =head1 SYNOPSIS
  
    use Plack::Request;
  
    my $app_or_middleware = sub {
        my $env = shift; # PSGI env
  
        my $req = Plack::Request->new($env);
  
        my $path_info = $req->path_info;
        my $query     = $req->parameters->{query};
  
        my $res = $req->new_response(200); # new Plack::Response
        $res->finalize;
    };
  
  =head1 DESCRIPTION
  
  L<Plack::Request> provides a consistent API for request objects across
  web server environments.
  
  =head1 CAVEAT
  
  Note that this module is intended to be used by Plack middleware
  developers and web application framework developers rather than
  application developers (end users).
  
  Writing your web application directly using Plack::Request is
  certainly possible but not recommended: it's like doing so with
  mod_perl's Apache::Request: yet too low level.
  
  If you're writing a web application, not a framework, then you're
  encouraged to use one of the web application frameworks that support
  PSGI (L<http://plackperl.org/#frameworks>), or see modules like
  L<HTTP::Engine> to provide higher level Request and Response API on
  top of PSGI.
  
  If you're looking for an easy-to-use API to convert existing CGI
  applications to run on PSGI, consider using L<CGI::PSGI> or
  L<CGI::Emulate::PSGI> as well. L<CGI::Emulate::PSGI> documentation has
  a good summary of using them to convert existing CGI scripts to adapt
  to PSGI.
  
  =head1 METHODS
  
  Some of the methods defined in the earlier versions are deprecated in
  version 0.99. Take a look at L</"INCOMPATIBILITIES">.
  
  Unless otherwise noted, all methods and attributes are B<read-only>,
  and passing values to the method like an accessor doesn't work like
  you expect it to.
  
  =head2 new
  
      Plack::Request->new( $env );
  
  Creates a new request object.
  
  =head1 ATTRIBUTES
  
  =over 4
  
  =item env
  
  Returns the shared PSGI environment hash reference. This is a
  reference, so writing to this environment passes through during the
  whole PSGI request/response cycle.
  
  =item address
  
  Returns the IP address of the client (C<REMOTE_ADDR>).
  
  =item remote_host
  
  Returns the remote host (C<REMOTE_HOST>) of the client. It may be
  empty, in which case you have to get the IP address using C<address>
  method and resolve on your own.
  
  =item method
  
  Contains the request method (C<GET>, C<POST>, C<HEAD>, etc).
  
  =item protocol
  
  Returns the protocol (HTTP/1.0 or HTTP/1.1) used for the current request.
  
  =item request_uri
  
  Returns the raw, undecoded request URI path. You probably do B<NOT>
  want to use this to dispatch requests.
  
  =item path_info
  
  Returns B<PATH_INFO> in the environment. Use this to get the local
  path for the requests.
  
  =item path
  
  Similar to C<path_info> but returns C</> in case it is empty. In other
  words, it returns the virtual path of the request URI after C<<
  $req->base >>. See L</"DISPATCHING"> for details.
  
  =item query_string
  
  Returns B<QUERY_STRING> in the environment. This is the undecoded
  query string in the request URI.
  
  =item script_name
  
  Returns B<SCRIPT_NAME> in the environment. This is the absolute path
  where your application is hosted.
  
  =item scheme
  
  Returns the scheme (C<http> or C<https>) of the request.
  
  =item secure
  
  Returns true or false, indicating whether the connection is secure (https).
  
  =item body, input
  
  Returns C<psgi.input> handle.
  
  =item session
  
  Returns (optional) C<psgix.session> hash. When it exists, you can
  retrieve and store per-session data from and to this hash.
  
  =item session_options
  
  Returns (optional) C<psgix.session.options> hash.
  
  =item logger
  
  Returns (optional) C<psgix.logger> code reference. When it exists,
  your application is supposed to send the log message to this logger,
  using:
  
    $req->logger->({ level => 'debug', message => "This is a debug message" });
  
  =item cookies
  
  Returns a reference to a hash containing the cookies. Values are
  strings that are sent by clients and are URI decoded.
  
  If there are multiple cookies with the same name in the request, this
  method will ignore the duplicates and return only the first value. If
  that causes issues for you, you may have to use modules like
  CGI::Simple::Cookie to parse C<< $request->header('Cookie') >> by
  yourself.
  
  =item query_parameters
  
  Returns a reference to a hash containing query string (GET)
  parameters. This hash reference is L<Hash::MultiValue> object.
  
  =item body_parameters
  
  Returns a reference to a hash containing posted parameters in the
  request body (POST). As with C<query_parameters>, the hash
  reference is a L<Hash::MultiValue> object.
  
  =item parameters
  
  Returns a L<Hash::MultiValue> hash reference containing (merged) GET
  and POST parameters.
  
  =item content, raw_body
  
  Returns the request content in an undecoded byte string for POST requests.
  
  =item uri
  
  Returns an URI object for the current request. The URI is constructed
  using various environment values such as C<SCRIPT_NAME>, C<PATH_INFO>,
  C<QUERY_STRING>, C<HTTP_HOST>, C<SERVER_NAME> and C<SERVER_PORT>.
  
  Every time this method is called it returns a new, cloned URI object.
  
  =item base
  
  Returns an URI object for the base path of current request. This is
  like C<uri> but only contains up to C<SCRIPT_NAME> where your
  application is hosted at.
  
  Every time this method is called it returns a new, cloned URI object.
  
  =item user
  
  Returns C<REMOTE_USER> if it's set.
  
  =item headers
  
  Returns an L<HTTP::Headers::Fast> object containing the headers for the current request.
  
  =item uploads
  
  Returns a reference to a hash containing uploads. The hash reference
  is a L<Hash::MultiValue> object and values are L<Plack::Request::Upload>
  objects.
  
  =item content_encoding
  
  Shortcut to $req->headers->content_encoding.
  
  =item content_length
  
  Returns the raw value of the Content-Length header.
  
  Before version 0.9925, this method was a shortcut for
  C<< $req->headers->content_length >>.
  
  =item content_type
  
  Returns the raw value of the Content-Type header.
  
  If you want just the MIME type, without any attributes like charset, use
  C<< $req->headers->content_type >>.  See also L<HTTP::Headers/content_type>.
  
  Before version 0.9925, this method was a shortcut for
  C<< $req->headers->content_type >>.
  
  =item header
  
  Shortcut to $req->headers->header.
  
  =item referer
  
  Shortcut to $req->headers->referer.
  
  =item user_agent
  
  Shortcut to $req->headers->user_agent.
  
  =item param
  
  Returns GET and POST parameters with a CGI.pm-compatible param
  method. This is an alternative method for accessing parameters in
  $req->parameters just in case you want the compatibility with
  CGI.pm objects.
  
  You are B<not recommended> to use this method since it is easy to
  misuse in a list context such as inside a hash constructor or method
  arguments. Use C<parameters> and Hash::MultiValue instead.
  
  Unlike CGI.pm, it does I<not> allow setting or modifying query
  parameters.
  
      $value  = $req->param( 'foo' );
      @values = $req->param( 'foo' );
      @params = $req->param;
  
  =item upload
  
  A convenient method to access $req->uploads.
  
      $upload  = $req->upload('field');
      @uploads = $req->upload('field');
      @fields  = $req->upload;
  
      for my $upload ( $req->upload('field') ) {
          print $upload->filename;
      }
  
  =item new_response
  
    my $res = $req->new_response;
  
  Creates a new L<Plack::Response> object. Handy to remove dependency on
  L<Plack::Response> in your code for easy subclassing and duck typing
  in web application frameworks, as well as overriding Response
  generation in middlewares.
  
  =back
  
  =head2 Hash::MultiValue parameters
  
  Parameters that can take one or multiple values (i.e. C<parameters>,
  C<query_parameters>, C<body_parameters> and C<uploads>) store the
  hash reference as a L<Hash::MultiValue> object. This means you can use
  the hash reference as a plain hash where values are B<always> scalars
  (B<NOT> array references), so you don't need to code ugly and unsafe
  C<< ref ... eq 'ARRAY' >> anymore.
  
  And if you explicitly want to get multiple values of the same key, you
  can call the C<get_all> method on it, such as:
  
    my @foo = $req->query_parameters->get_all('foo');
  
  You can also call C<get_one> to always get one parameter independent
  of the context (unlike C<param>), and even call C<mixed> (with
  Hash::MultiValue 0.05 or later) to get the I<traditional> hash
  reference,
  
    my $params = $req->parameters->mixed;
  
  where values are either a scalar or an array reference depending on
  input, so it might be useful if you already have the code to deal with
  that ugliness.
  
  =head2 PARSING POST BODY and MULTIPLE OBJECTS
  
  The methods to parse request body (C<content>, C<body_parameters> and
  C<uploads>) are carefully coded to save the parsed body in the
  environment hash as well as in the temporary buffer, so you can call
  them multiple times and create Plack::Request objects multiple times
  in a request and they should work safely, and won't parse request body
  more than twice for the efficiency.
  
  =head1 DISPATCHING
  
  If your application or framework wants to dispatch (or route) actions
  based on request paths, be sure to use C<< $req->path_info >> not C<<
  $req->uri->path >>.
  
  This is because C<path_info> gives you the virtual path of the request,
  regardless of how your application is mounted. If your application is
  hosted with mod_perl or CGI scripts, or even multiplexed with tools
  like L<Plack::App::URLMap>, request's C<path_info> always gives you
  the action path.
  
  Note that C<path_info> might give you an empty string, in which case
  you should assume that the path is C</>.
  
  You will also want to use C<< $req->base >> as a base prefix when
  building URLs in your templates or in redirections. It's a good idea
  for you to subclass Plack::Request and define methods such as:
  
    sub uri_for {
        my($self, $path, $args) = @_;
        my $uri = $self->base;
        $uri->path($uri->path . $path);
        $uri->query_form(@$args) if $args;
        $uri;
    }
  
  So you can say:
  
    my $link = $req->uri_for('/logout', [ signoff => 1 ]);
  
  and if C<< $req->base >> is C</app> you'll get the full URI for
  C</app/logout?signoff=1>.
  
  =head1 INCOMPATIBILITIES
  
  In version 0.99, many utility methods are removed or deprecated, and
  most methods are made read-only. These methods were deleted in version
  1.0001.
  
  All parameter-related methods such as C<parameters>,
  C<body_parameters>, C<query_parameters> and C<uploads> now contains
  L<Hash::MultiValue> objects, rather than I<scalar or an array
  reference depending on the user input> which is insecure. See
  L<Hash::MultiValue> for more about this change.
  
  C<< $req->path >> method had a bug, where the code and the document
  was mismatching. The document was suggesting it returns the sub
  request path after C<< $req->base >> but the code was always returning
  the absolute URI path. The code is now updated to be an alias of C<<
  $req->path_info >> but returns C</> in case it's empty. If you need
  the older behavior, just call C<< $req->uri->path >> instead.
  
  Cookie handling is simplified, and doesn't use L<CGI::Simple::Cookie>
  anymore, which means you B<CAN NOT> set array reference or hash
  reference as a cookie value and expect it be serialized. You're always
  required to set string value, and encoding or decoding them is totally
  up to your application or framework. Also, C<cookies> hash reference
  now returns I<strings> for the cookies rather than CGI::Simple::Cookie
  objects, which means you no longer have to write a wacky code such as:
  
    $v = $req->cookies->{foo} ? $req->cookies->{foo}->value : undef;
  
  and instead, simply do:
  
    $v = $req->cookies->{foo};
  
  =head1 AUTHORS
  
  Tatsuhiko Miyagawa
  
  Kazuhiro Osawa
  
  Tokuhiro Matsuno
  
  =head1 SEE ALSO
  
  L<Plack::Response> L<HTTP::Request>, L<Catalyst::Request>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK_REQUEST

    $fatpacked{"Plack/Request/Upload.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_REQUEST_UPLOAD';
  package Plack::Request::Upload;
  use strict;
  use warnings;
  use Carp ();
  
  sub new {
      my($class, %args) = @_;
  
      bless {
          headers  => $args{headers},
          tempname => $args{tempname},
          size     => $args{size},
          filename => $args{filename},
      }, $class;
  }
  
  sub filename { $_[0]->{filename} }
  sub headers  { $_[0]->{headers} }
  sub size     { $_[0]->{size} }
  sub tempname { $_[0]->{tempname} }
  sub path     { $_[0]->{tempname} }
  
  sub content_type {
      my $self = shift;
      $self->{headers}->content_type(@_);
  }
  
  sub type { shift->content_type(@_) }
  
  sub basename {
      my $self = shift;
      unless (defined $self->{basename}) {
          require File::Spec::Unix;
          my $basename = $self->{filename};
          $basename =~ s|\\|/|g;
          $basename = ( File::Spec::Unix->splitpath($basename) )[2];
          $basename =~ s|[^\w\.-]+|_|g;
          $self->{basename} = $basename;
      }
      $self->{basename};
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Request::Upload - handles file upload requests
  
  =head1 SYNOPSIS
  
    # $req is Plack::Request
    my $upload = $req->uploads->{field};
  
    $upload->size;
    $upload->path;
    $upload->content_type;
    $upload->basename;
  
  =head1 METHODS
  
  =over 4
  
  =item size
  
  Returns the size of Uploaded file.
  
  =item path
  
  Returns the path to the temporary file where uploaded file is saved.
  
  =item content_type
  
  Returns the content type of the uploaded file.
  
  =item filename
  
  Returns the original filename in the client.
  
  =item basename
  
  Returns basename for "filename".
  
  =back
  
  =head1 AUTHORS
  
  Kazuhiro Osawa
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Request>, L<Catalyst::Request::Upload>
  
  =cut
PLACK_REQUEST_UPLOAD

    $fatpacked{"Plack/Response.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_RESPONSE';
  package Plack::Response;
  use strict;
  use warnings;
  our $VERSION = '1.0050';
  
  use Plack::Util::Accessor qw(body status);
  use Carp ();
  use Cookie::Baker ();
  use Scalar::Util ();
  use HTTP::Headers::Fast;
  use URI::Escape ();
  
  sub code    { shift->status(@_) }
  sub content { shift->body(@_)   }
  
  sub new {
      my($class, $rc, $headers, $content) = @_;
  
      my $self = bless {}, $class;
      $self->status($rc)       if defined $rc;
      $self->headers($headers) if defined $headers;
      $self->body($content)    if defined $content;
  
      $self;
  }
  
  sub headers {
      my $self = shift;
  
      if (@_) {
          my $headers = shift;
          if (ref $headers eq 'ARRAY') {
              Carp::carp("Odd number of headers") if @$headers % 2 != 0;
              $headers = HTTP::Headers::Fast->new(@$headers);
          } elsif (ref $headers eq 'HASH') {
              $headers = HTTP::Headers::Fast->new(%$headers);
          }
          return $self->{headers} = $headers;
      } else {
          return $self->{headers} ||= HTTP::Headers::Fast->new();
      }
  }
  
  sub cookies {
      my $self = shift;
      if (@_) {
          $self->{cookies} = shift;
      } else {
          return $self->{cookies} ||= +{ };
      }
  }
  
  sub header { shift->headers->header(@_) } # shortcut
  
  sub content_length {
      shift->headers->content_length(@_);
  }
  
  sub content_type {
      shift->headers->content_type(@_);
  }
  
  sub content_encoding {
      shift->headers->content_encoding(@_);
  }
  
  sub location {
      my $self = shift;
      return $self->headers->header('Location' => @_);
  }
  
  sub redirect {
      my $self = shift;
  
      if (@_) {
          my $url = shift;
          my $status = shift || 302;
          $self->location($url);
          $self->status($status);
      }
  
      return $self->location;
  }
  
  sub finalize {
      my $self = shift;
      Carp::croak "missing status" unless $self->status();
  
      my $headers = $self->headers;
      my @headers;
      $headers->scan(sub{
          my ($k,$v) = @_;
          $v =~ s/\015\012[\040|\011]+/chr(32)/ge; # replace LWS with a single SP
          $v =~ s/\015|\012//g; # remove CR and LF since the char is invalid here
          push @headers, $k, $v;
      });
  
      $self->_finalize_cookies(\@headers);
  
      return [
          $self->status,
          \@headers,
          $self->_body,
      ];
  }
  
  sub to_app {
      my $self = shift;
      return sub { $self->finalize };
  }
  
  
  sub _body {
      my $self = shift;
      my $body = $self->body;
         $body = [] unless defined $body;
      if (!ref $body or Scalar::Util::blessed($body) && overload::Method($body, q("")) && !$body->can('getline')) {
          return [ $body ];
      } else {
          return $body;
      }
  }
  
  sub _finalize_cookies {
      my($self, $headers) = @_;
  
      foreach my $name ( keys %{ $self->cookies } ) {
          my $val = $self->cookies->{$name};
  
          my $cookie = Cookie::Baker::bake_cookie( $name, $val );
          push @$headers, 'Set-Cookie' => $cookie;
      }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Response - Portable HTTP Response object for PSGI response
  
  =head1 SYNOPSIS
  
    use Plack::Response;
  
    sub psgi_handler {
        my $env = shift;
  
        my $res = Plack::Response->new(200);
        $res->content_type('text/html');
        $res->body("Hello World");
  
        return $res->finalize;
    }
  
  =head1 DESCRIPTION
  
  Plack::Response allows you a way to create PSGI response array ref through a simple API.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $res = Plack::Response->new;
    $res = Plack::Response->new($status);
    $res = Plack::Response->new($status, $headers);
    $res = Plack::Response->new($status, $headers, $body);
  
  Creates a new Plack::Response object.
  
  =item status
  
    $res->status(200);
    $status = $res->status;
  
  Sets and gets HTTP status code. C<code> is an alias.
  
  =item headers
  
    $headers = $res->headers;
    $res->headers([ 'Content-Type' => 'text/html' ]);
    $res->headers({ 'Content-Type' => 'text/html' });
    $res->headers( HTTP::Headers::Fast->new );
  
  Sets and gets HTTP headers of the response. Setter can take either an
  array ref, a hash ref or L<HTTP::Headers::Fast> object containing a list of
  headers.
  
  =item body
  
    $res->body($body_str);
    $res->body([ "Hello", "World" ]);
    $res->body($io);
  
  Gets and sets HTTP response body. Setter can take either a string, an
  array ref, or an IO::Handle-like object. C<content> is an alias.
  
  Note that this method doesn't automatically set I<Content-Length> for
  the response. You have to set it manually if you want, with the
  C<content_length> method (see below).
  
  =item header
  
    $res->header('X-Foo' => 'bar');
    my $val = $res->header('X-Foo');
  
  Shortcut for C<< $res->headers->header >>.
  
  =item content_type, content_length, content_encoding
  
    $res->content_type('text/plain');
    $res->content_length(123);
    $res->content_encoding('gzip');
  
  Shortcut for the equivalent get/set methods in C<< $res->headers >>.
  
  =item redirect
  
    $res->redirect($url);
    $res->redirect($url, 301);
  
  Sets redirect URL with an optional status code, which defaults to 302.
  
  Note that this method doesn't normalize the given URI string. Users of
  this module have to be responsible about properly encoding URI paths
  and parameters.
  
  =item location
  
  Gets and sets C<Location> header.
  
  Note that this method doesn't normalize the given URI string in the
  setter. See above in C<redirect> for details.
  
  =item cookies
  
    $res->cookies->{foo} = 123;
    $res->cookies->{foo} = { value => '123' };
  
  Returns a hash reference containing cookies to be set in the
  response. The keys of the hash are the cookies' names, and their
  corresponding values are a plain string (for C<value> with everything
  else defaults) or a hash reference that can contain keys such as
  C<value>, C<domain>, C<expires>, C<path>, C<httponly>, C<secure>,
  C<max-age>.
  
  C<expires> can take a string or an integer (as an epoch time) and
  B<does not> convert string formats such as C<+3M>.
  
    $res->cookies->{foo} = {
        value => 'test',
        path  => "/",
        domain => '.example.com',
        expires => time + 24 * 60 * 60,
    };
  
  =item finalize
  
    $res->finalize;
  
  Returns the status code, headers, and body of this response as a PSGI
  response array reference.
  
  =item to_app
  
    $app = $res->to_app;
  
  A helper shortcut for C<< sub { $res->finalize } >>.
  
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Request>
  
  =cut
PLACK_RESPONSE

    $fatpacked{"Plack/Runner.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_RUNNER';
  package Plack::Runner;
  use strict;
  use warnings;
  use Carp ();
  use Plack::Util;
  use Try::Tiny;
  
  sub new {
      my $class = shift;
      bless {
          env      => $ENV{PLACK_ENV},
          loader   => 'Plack::Loader',
          includes => [],
          modules  => [],
          default_middleware => 1,
          @_,
      }, $class;
  }
  
  # delay the build process for reloader
  sub build(&;$) {
      my $block = shift;
      my $app   = shift || sub { };
      return sub { $block->($app->()) };
  }
  
  sub parse_options {
      my $self = shift;
  
      local @ARGV = @_;
  
      # From 'prove': Allow cuddling the paths with -I, -M and -e
      @ARGV = map { /^(-[IMe])(.+)/ ? ($1,$2) : $_ } @ARGV;
  
      my($host, $port, $socket, @listen);
  
      require Getopt::Long;
      my $parser = Getopt::Long::Parser->new(
          config => [ "no_auto_abbrev", "no_ignore_case", "pass_through" ],
      );
  
      $parser->getoptions(
          "a|app=s"      => \$self->{app},
          "o|host=s"     => \$host,
          "p|port=i"     => \$port,
          "s|server=s"   => \$self->{server},
          "S|socket=s"   => \$socket,
          'l|listen=s@'  => \@listen,
          'D|daemonize'  => \$self->{daemonize},
          "E|env=s"      => \$self->{env},
          "e=s"          => \$self->{eval},
          'I=s@'         => $self->{includes},
          'M=s@'         => $self->{modules},
          'r|reload'     => sub { $self->{loader} = "Restarter" },
          'R|Reload=s'   => sub { $self->{loader} = "Restarter"; $self->loader->watch(split ",", $_[1]) },
          'L|loader=s'   => \$self->{loader},
          "access-log=s" => \$self->{access_log},
          "path=s"       => \$self->{path},
          "h|help"       => \$self->{help},
          "v|version"    => \$self->{version},
          "default-middleware!" => \$self->{default_middleware},
      );
  
      my(@options, @argv);
      while (defined(my $arg = shift @ARGV)) {
          if ($arg =~ s/^--?//) {
              my @v = split '=', $arg, 2;
              $v[0] =~ tr/-/_/;
              if (@v == 2) {
                  push @options, @v;
              } elsif ($v[0] =~ s/^(disable|enable)_//) {
                  push @options, $v[0], $1 eq 'enable';
              } else {
                  push @options, $v[0], shift @ARGV;
              }
          } else {
              push @argv, $arg;
          }
      }
  
      push @options, $self->mangle_host_port_socket($host, $port, $socket, @listen);
      push @options, daemonize => 1 if $self->{daemonize};
  
      $self->{options} = \@options;
      $self->{argv}    = \@argv;
  }
  
  sub set_options {
      my $self = shift;
      push @{$self->{options}}, @_;
  }
  
  sub mangle_host_port_socket {
      my($self, $host, $port, $socket, @listen) = @_;
  
      for my $listen (reverse @listen) {
          if ($listen =~ /:\d+$/) {
              ($host, $port) = split /:/, $listen, 2;
              $host = undef if $host eq '';
          } else {
              $socket ||= $listen;
          }
      }
  
      unless (@listen) {
          if ($socket) {
              @listen = ($socket);
          } else {
              $port ||= 5000;
              @listen = ($host ? "$host:$port" : ":$port");
          }
      }
  
      return host => $host, port => $port, listen => \@listen, socket => $socket;
  }
  
  sub version_cb {
      my $self = shift;
      $self->{version_cb} || sub {
          require Plack;
          print "Plack $Plack::VERSION\n";
      };
  }
  
  sub setup {
      my $self = shift;
  
      if ($self->{help}) {
          require Pod::Usage;
          Pod::Usage::pod2usage(0);
      }
  
      if ($self->{version}) {
          $self->version_cb->();
          exit;
      }
  
      if (@{$self->{includes}}) {
          require lib;
          lib->import(@{$self->{includes}});
      }
  
      if ($self->{eval}) {
          push @{$self->{modules}}, 'Plack::Builder';
      }
  
      for (@{$self->{modules}}) {
          my($module, @import) = split /[=,]/;
          eval "require $module" or die $@;
          $module->import(@import);
      }
  }
  
  sub locate_app {
      my($self, @args) = @_;
  
      my $psgi = $self->{app} || $args[0];
  
      if (ref $psgi eq 'CODE') {
          return sub { $psgi };
      }
  
      if ($self->{eval}) {
          $self->loader->watch("lib") if -e "lib";
          return build {
              no strict;
              no warnings;
              my $eval = "builder { $self->{eval};";
              $eval .= "Plack::Util::load_psgi(\$psgi);" if $psgi;
              $eval .= "}";
              eval $eval or die $@;
          };
      }
  
      $psgi ||= "app.psgi";
  
      require File::Basename;
      my $lib = File::Basename::dirname($psgi) . "/lib";
      $self->loader->watch($lib) if -e $lib;
      $self->loader->watch($psgi);
      build { Plack::Util::load_psgi $psgi };
  }
  
  sub watch {
      my($self, @dir) = @_;
  
      push @{$self->{watch}}, @dir
          if $self->{loader} eq 'Restarter';
  }
  
  sub apply_middleware {
      my($self, $app, $class, @args) = @_;
  
      my $mw_class = Plack::Util::load_class($class, 'Plack::Middleware');
      build { $mw_class->wrap($_[0], @args) } $app;
  }
  
  sub prepare_devel {
      my($self, $app) = @_;
  
      if ($self->{default_middleware}) {
          $app = $self->apply_middleware($app, 'Lint');
          $app = $self->apply_middleware($app, 'StackTrace');
          if (!$ENV{GATEWAY_INTERFACE} and !$self->{access_log}) {
              $app = $self->apply_middleware($app, 'AccessLog');
          }
      }
  
      push @{$self->{options}}, server_ready => sub {
          my($args) = @_;
          my $name  = $args->{server_software} || ref($args); # $args is $server
          my $host  = $args->{host} || 0;
          my $proto = $args->{proto} || 'http';
          print STDERR "$name: Accepting connections at $proto://$host:$args->{port}/\n";
      };
  
      $app;
  }
  
  sub loader {
      my $self = shift;
      $self->{_loader} ||= Plack::Util::load_class($self->{loader}, 'Plack::Loader')->new;
  }
  
  sub load_server {
      my($self, $loader) = @_;
  
      if ($self->{server}) {
          return $loader->load($self->{server}, @{$self->{options}});
      } else {
          return $loader->auto(@{$self->{options}});
      }
  }
  
  sub run {
      my $self = shift;
  
      unless (ref $self) {
          $self = $self->new;
          $self->parse_options(@_);
          return $self->run;
      }
  
      unless ($self->{options}) {
          $self->parse_options();
      }
  
      my @args = @_ ? @_ : @{$self->{argv}};
  
      $self->setup;
  
      my $app = $self->locate_app(@args);
  
      if ($self->{path}) {
          require Plack::App::URLMap;
          $app = build {
              my $urlmap = Plack::App::URLMap->new;
              $urlmap->mount($self->{path} => $_[0]);
              $urlmap->to_app;
          } $app;
      }
  
      $ENV{PLACK_ENV} ||= $self->{env} || 'development';
      if ($ENV{PLACK_ENV} eq 'development') {
          $app = $self->prepare_devel($app);
      }
  
      if ($self->{access_log}) {
          open my $logfh, ">>", $self->{access_log}
              or die "open($self->{access_log}): $!";
          $logfh->autoflush(1);
          $app = $self->apply_middleware($app, 'AccessLog', logger => sub { $logfh->print( @_ ) });
      }
  
      my $loader = $self->loader;
      $loader->preload_app($app);
  
      my $server = $self->load_server($loader);
      $loader->run($server);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Runner - plackup core
  
  =head1 SYNOPSIS
  
    # Your bootstrap script
    use Plack::Runner;
    my $app = sub { ... };
  
    my $runner = Plack::Runner->new;
    $runner->parse_options(@ARGV);
    $runner->run($app);
  
  =head1 DESCRIPTION
  
  Plack::Runner is the core of L<plackup> runner script. You can create
  your own frontend to run your application or framework, munge command
  line options and pass that to C<run> method of this class.
  
  C<run> method does exactly the same thing as the L<plackup> script
  does, but one notable addition is that you can pass a PSGI application
  code reference directly to the method, rather than via C<.psgi>
  file path or with C<-e> switch. This would be useful if you want to
  make an installable PSGI application.
  
  Also, when C<-h> or C<--help> switch is passed, the usage text is
  automatically extracted from your own script using L<Pod::Usage>.
  
  =head1 NOTES
  
  Do not directly call this module from your C<.psgi>, since that makes
  your PSGI application unnecessarily depend on L<plackup> and won't run
  other backends like L<Plack::Handler::Apache2> or mod_psgi.
  
  If you I<really> want to make your C<.psgi> runnable as a standalone
  script, you can do this:
  
    my $app = sub { ... };
  
    unless (caller) {
        require Plack::Runner;
        my $runner = Plack::Runner->new;
        $runner->parse_options(@ARGV);
        $runner->run($app);
        exit 0;
    }
  
    return $app;
  
  B<WARNING>: this section used to recommend C<if (__FILE__ eq $0)> but
  it's known to be broken since Plack 0.9971, since C<$0> is now
  I<always> set to the .psgi file path even when you run it from
  plackup.
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
  
  
PLACK_RUNNER

    $fatpacked{"Plack/TempBuffer.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_TEMPBUFFER';
  package Plack::TempBuffer;
  use strict;
  use warnings;
  
  use parent 'Stream::Buffered';
  
  sub new {
      my $class = shift;
  
      if (defined $Plack::TempBuffer::MaxMemoryBufferSize) {
          warn "Setting \$Plack::TempBuffer::MaxMemoryBufferSize is deprecated. "
             . "You should set \$Stream::Buffered::MaxMemoryBufferSize instead.";
          $Stream::Buffered::MaxMemoryBufferSize = $Plack::TempBuffer::MaxMemoryBufferSize;
      }
  
      return $class->SUPER::new(@_);
  }
  
  1;
PLACK_TEMPBUFFER

    $fatpacked{"Plack/Test.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_TEST';
  package Plack::Test;
  use strict;
  use warnings;
  use Carp;
  use parent qw(Exporter);
  our @EXPORT = qw(test_psgi);
  
  our $Impl;
  $Impl ||= $ENV{PLACK_TEST_IMPL} || "MockHTTP";
  
  sub create {
      my($class, $app, @args) = @_;
  
      my $subclass = "Plack::Test::$Impl";
      eval "require $subclass";
      die $@ if $@;
  
      no strict 'refs';
      if (defined &{"Plack::Test::$Impl\::test_psgi"}) {
          return \&{"Plack::Test::$Impl\::test_psgi"};
      }
  
      $subclass->new($app, @args);
  }
  
  sub test_psgi {
      if (ref $_[0] && @_ == 2) {
          @_ = (app => $_[0], client => $_[1]);
      }
      my %args = @_;
  
      my $app    = delete $args{app}; # Backward compat: some implementations don't need app
      my $client = delete $args{client} or Carp::croak "client test code needed";
  
      my $tester = Plack::Test->create($app, %args);
      return $tester->(@_) if ref $tester eq 'CODE'; # compatibility
  
      $client->(sub { $tester->request(@_) });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Test - Test PSGI applications with various backends
  
  =head1 SYNOPSIS
  
    use Plack::Test;
    use HTTP::Request::Common;
  
    # Simple OO interface
    my $app = sub { return [ 200, [], [ "Hello" ] ] };
    my $test = Plack::Test->create($app);
  
    my $res = $test->request(GET "/");
    is $res->content, "Hello";
  
    # traditional - named params
    test_psgi
        app => sub {
            my $env = shift;
            return [ 200, [ 'Content-Type' => 'text/plain' ], [ "Hello World" ] ],
        },
        client => sub {
            my $cb  = shift;
            my $req = HTTP::Request->new(GET => "http://localhost/hello");
            my $res = $cb->($req);
            like $res->content, qr/Hello World/;
        };
  
    # positional params (app, client)
    my $app = sub { return [ 200, [], [ "Hello" ] ] };
    test_psgi $app, sub {
        my $cb  = shift;
        my $res = $cb->(GET "/");
        is $res->content, "Hello";
    };
  
  =head1 DESCRIPTION
  
  Plack::Test is a unified interface to test PSGI applications using
  L<HTTP::Request> and L<HTTP::Response> objects. It also allows you to run PSGI
  applications in various ways. The default backend is C<Plack::Test::MockHTTP>,
  but you may also use any L<Plack::Handler> implementation to run live HTTP
  requests against a web server.
  
  =head1 METHODS
  
  =over 4
  
  =item create
  
    $test = Plack::Test->create($app, %options);
  
  creates an instance of Plack::Test implementation class. C<$app> has
  to be a valid PSGI application code reference.
  
  =item request
  
    $res = $test->request($request);
  
  takes an HTTP::Request object, runs it through the PSGI application to
  test and returns an HTTP::Response object.
  
  =back
  
  =head1 FUNCTIONS
  
  Plack::Test also provides a functional interface that takes two
  callbacks, each of which represents PSGI application and HTTP client
  code that tests the application.
  
  =over 4
  
  =item test_psgi
  
    test_psgi $app, $client;
    test_psgi app => $app, client => $client;
  
  Runs the client test code C<$client> against a PSGI application
  C<$app>. The client callback gets one argument C<$cb>, a
  callback that accepts an C<HTTP::Request> object and returns an
  C<HTTP::Response> object.
  
  Use L<HTTP::Request::Common> to import shortcuts for creating requests for
  C<GET>, C<POST>, C<DELETE>, and C<PUT> operations.
  
  For your convenience, the C<HTTP::Request> given to the callback automatically
  uses the HTTP protocol and the localhost (I<127.0.0.1> by default), so the
  following code just works:
  
    use HTTP::Request::Common;
    test_psgi $app, sub {
        my $cb  = shift;
        my $res = $cb->(GET "/hello");
    };
  
  Note that however, it is not a good idea to pass an arbitrary
  (i.e. user-input) string to C<GET> or even C<<
  HTTP::Request->new >> by assuming that it always represents a path,
  because:
  
    my $req = GET "//foo/bar";
  
  would represent a request for a URL that has no scheme, has a hostname
  I<foo> and a path I</bar>, instead of a path I<//foo/bar> which you
  might actually want.
  
  =back
  
  =head1 OPTIONS
  
  Specify the L<Plack::Test> backend using the environment
  variable C<PLACK_TEST_IMPL> or C<$Plack::Test::Impl> package variable.
  
  The available values for the backend are:
  
  =over 4
  
  =item MockHTTP
  
  (Default) Creates a PSGI env hash out of HTTP::Request object, runs
  the PSGI application in-process and returns HTTP::Response.
  
  =item Server
  
  Runs one of Plack::Handler backends (C<Standalone> by default) and
  sends live HTTP requests to test.
  
  =item ExternalServer
  
  Runs tests against an external server specified in the
  C<PLACK_TEST_EXTERNALSERVER_URI> environment variable instead of spawning the
  application in a server locally.
  
  =back
  
  For instance, test your application with the C<HTTP::Server::ServerSimple>
  server backend with:
  
    > env PLACK_TEST_IMPL=Server PLACK_SERVER=HTTP::Server::ServerSimple \
      prove -l t/test.t
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_TEST

    $fatpacked{"Plack/Test/MockHTTP.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_TEST_MOCKHTTP';
  package Plack::Test::MockHTTP;
  use strict;
  use warnings;
  
  use Carp;
  use HTTP::Request;
  use HTTP::Response;
  use HTTP::Message::PSGI;
  use Try::Tiny;
  
  sub new {
      my($class, $app) = @_;
      bless { app => $app }, $class;
  }
  
  sub request {
      my($self, $req) = @_;
  
      $req->uri->scheme('http')    unless defined $req->uri->scheme;
      $req->uri->host('localhost') unless defined $req->uri->host;
      my $env = $req->to_psgi;
  
      my $res = try {
          HTTP::Response->from_psgi($self->{app}->($env));
      } catch {
          HTTP::Response->from_psgi([ 500, [ 'Content-Type' => 'text/plain' ], [ $_ ] ]);
      };
  
      $res->request($req);
      return $res;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Test::MockHTTP - Run mocked HTTP tests through PSGI applications
  
  =head1 DESCRIPTION
  
  Plack::Test::MockHTTP is a utility to run PSGI application given
  HTTP::Request objects and return HTTP::Response object out of PSGI
  application response. See L<Plack::Test> how to use this module.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Test>
  
  =cut
  
  
PLACK_TEST_MOCKHTTP

    $fatpacked{"Plack/Test/Server.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_TEST_SERVER';
  package Plack::Test::Server;
  use strict;
  use warnings;
  use Carp;
  use HTTP::Request;
  use HTTP::Response;
  use Test::TCP;
  use Plack::Loader;
  use Plack::LWPish;
  
  sub new {
      my($class, $app, %args) = @_;
  
      my $host = $args{host} || '127.0.0.1';
      my $server = Test::TCP->new(
          listen => $args{listen},
          host => $host,
          code => sub {
              my $sock_or_port = shift;
              my $server = Plack::Loader->auto(
                  ($args{listen} ? (
                      listen_sock => $sock_or_port,
                  ):(
                      port => $sock_or_port,
                      host => $host,
                  ))
              );
              $server->run($app);
              exit;
          },
      );
  
      bless { server => $server, %args }, $class;
  }
  
  sub port {
      my $self = shift;
      $self->{server}->port;
  }
  
  sub request {
      my($self, $req) = @_;
  
      my $ua = $self->{ua} || Plack::LWPish->new( no_proxy => [qw/127.0.0.1/] );
  
      $req->uri->scheme('http');
      $req->uri->host($self->{host} || '127.0.0.1');
      $req->uri->port($self->port);
  
      return $ua->request($req);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Test::Server - Run HTTP tests through live Plack servers
  
  =head1 DESCRIPTION
  
  Plack::Test::Server is a utility to run PSGI application with Plack
  server implementations, and run the live HTTP tests with the server
  using a callback. See L<Plack::Test> how to use this module.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Tokuhiro Matsuno
  
  =head1 SEE ALSO
  
  L<Plack::Loader> L<Test::TCP> L<Plack::Test>
  
  =cut
  
PLACK_TEST_SERVER

    $fatpacked{"Plack/Test/Suite.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_TEST_SUITE';
  package Plack::Test::Suite;
  use strict;
  use warnings;
  use Digest::MD5;
  use File::ShareDir;
  use HTTP::Request;
  use HTTP::Request::Common;
  use Test::More;
  use Test::TCP;
  use Plack::Loader;
  use Plack::Middleware::Lint;
  use Plack::Util;
  use Plack::Request;
  use Try::Tiny;
  use Plack::LWPish;
  
  my $share_dir = try { File::ShareDir::dist_dir('Plack') } || 'share';
  
  $ENV{PLACK_TEST_SCRIPT_NAME} = '';
  
  # 0: test name
  # 1: request generator coderef.
  # 2: request handler
  # 3: test case for response
  our @TEST = (
      [
          'SCRIPT_NAME',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->content, "script_name=$ENV{PLACK_TEST_SCRIPT_NAME}";
          },
          sub {
              my $env = shift;
              return [ 200, ["Content-Type", "text/plain"], [ "script_name=$env->{SCRIPT_NAME}" ] ];
          },
      ],
      [
          'GET',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/?name=miyagawa");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=miyagawa';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ 'Hello, ' . $env->{QUERY_STRING} ],
              ];
          },
      ],
      [
          'POST',
          sub {
              my $cb = shift;
              my $res = $cb->(POST "http://127.0.0.1/", [name => 'tatsuhiko']);
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('Client-Content-Length'), 14;
              is $res->header('Client-Content-Type'), 'application/x-www-form-urlencoded';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=tatsuhiko';
          },
          sub {
              my $env = shift;
              my $body;
              $env->{'psgi.input'}->read($body, $env->{CONTENT_LENGTH});
              return [
                  200,
                  [ 'Content-Type' => 'text/plain',
                    'Client-Content-Length' => $env->{CONTENT_LENGTH},
                    'Client-Content-Type' => $env->{CONTENT_TYPE},
                ],
                  [ 'Hello, ' . $body ],
              ];
          },
      ],
      [
          'big POST',
          sub {
              my $cb = shift;
              my $chunk = "abcdefgh" x 12000;
              my $req = HTTP::Request->new(POST => "http://127.0.0.1/");
              $req->content_length(length $chunk);
              $req->content_type('application/octet-stream');
              $req->content($chunk);
  
              my $res = $cb->($req);
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('Client-Content-Length'), length $chunk;
              is length $res->content, length $chunk;
              is Digest::MD5::md5_hex($res->content), Digest::MD5::md5_hex($chunk);
          },
          sub {
              my $env = shift;
              my $len = $env->{CONTENT_LENGTH};
              my $body = '';
              my $spin;
              while ($len > 0) {
                  my $rc = $env->{'psgi.input'}->read($body, $env->{CONTENT_LENGTH}, length $body);
                  $len -= $rc;
                  last if $spin++ > 2000;
              }
              return [
                  200,
                  [ 'Content-Type' => 'text/plain',
                    'Client-Content-Length' => $env->{CONTENT_LENGTH},
                    'Client-Content-Type' => $env->{CONTENT_TYPE},
                ],
                  [ $body ],
              ];
          },
      ],
      [
          'psgi.url_scheme',
          sub {
              my $cb = shift;
              my $res = $cb->(POST "http://127.0.0.1/");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'http';
          },
          sub {
              my $env = $_[0];
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{'psgi.url_scheme'} ],
              ];
          },
      ],
      [
          'return glob',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              like $res->content, qr/^package /;
              like $res->content, qr/END_MARK_FOR_TESTING$/;
          },
          sub {
              my $env = shift;
              open my $fh, '<', __FILE__ or die $!;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  $fh,
              ];
          },
      ],
      [
          'filehandle',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo.jpg");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'image/jpeg';
              is length $res->content, 2898;
          },
          sub {
              my $env = shift;
              open my $fh, '<', "$share_dir/face.jpg";
              return [
                  200,
                  [ 'Content-Type' => 'image/jpeg', 'Content-Length' => -s $fh ],
                  $fh
              ];
          },
      ],
      [
          'bigger file',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/baybridge.jpg");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'image/jpeg';
              is length $res->content, 14750;
              is Digest::MD5::md5_hex($res->content), '70546a79c7abb9c497ca91730a0686e4';
          },
          sub {
              my $env = shift;
              open my $fh, '<', "$share_dir/baybridge.jpg";
              binmode $fh;
              return [
                  200,
                  [ 'Content-Type' => 'image/jpeg', 'Content-Length' => -s $fh ],
                  $fh
              ];
          },
      ],
      [
          'handle HTTP-Header',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan", Foo => "Bar");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Bar';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$env->{HTTP_FOO}],
              ];
          },
      ],
      [
          'handle HTTP-Cookie',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan", Cookie => "foo");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'foo';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$env->{HTTP_COOKIE}],
              ];
          },
      ],
      [
          'validate env',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, join("\n",
                  'REQUEST_METHOD:GET',
                  "SCRIPT_NAME:$ENV{PLACK_TEST_SCRIPT_NAME}",
                  'PATH_INFO:/foo/',
                  'QUERY_STRING:dankogai=kogaidan',
                  'SERVER_NAME:127.0.0.1',
                  "SERVER_PORT:" . $res->request->uri->port,
              )."\n";
          },
          sub {
              my $env = shift;
              my $body;
              $body .= $_ . ':' . $env->{$_} . "\n" for qw/REQUEST_METHOD SCRIPT_NAME PATH_INFO QUERY_STRING SERVER_NAME SERVER_PORT/;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$body],
              ];
          },
      ],
      [
          '% encoding in PATH_INFO',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/bar%2cbaz");
              is $res->content, "/foo/bar,baz", "PATH_INFO should be decoded per RFC 3875";
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
      [
          '% double encoding in PATH_INFO',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/bar%252cbaz");
              is $res->content, "/foo/bar%2cbaz", "PATH_INFO should be decoded only once, per RFC 3875";
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
      [
          '% encoding in PATH_INFO (outside of URI characters)',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo%E3%81%82");
              is $res->content, "/foo\x{e3}\x{81}\x{82}";
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
      [
          'SERVER_PROTOCOL is required',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              like $res->content, qr{^HTTP/1\.[01]$};
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$env->{SERVER_PROTOCOL}],
              ];
          },
      ],
      [
          'SCRIPT_NAME should not be undef',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is $res->content, 1;
          },
          sub {
              my $env = shift;
              my $cont = defined $env->{'SCRIPT_NAME'};
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$cont],
              ];
          },
      ],
      [
          'call close after read IO::Handle-like',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/call_close");
              is($res->content, '1234');
          },
          sub {
              my $env = shift;
              {
                  our $closed = -1;
                  sub CalledClose::new { $closed = 0; my $i=0; bless \$i, 'CalledClose' }
                  sub CalledClose::getline {
                      my $self = shift;
                      return $$self++ < 4 ? $$self : undef;
                  }
                  sub CalledClose::close { ::ok(1, 'closed') if defined &::ok }
              }
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  CalledClose->new(),
              ];
          },
      ],
      [
          'has errors',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/has_errors");
              is $res->content, 1;
          },
          sub {
              my $env = shift;
              my $err = $env->{'psgi.errors'};
              my $has_errors = defined $err;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$has_errors]
              ];
          },
      ],
      [
          'status line',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is($res->status_line, '200 OK');
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [1]
              ];
          },
      ],
      [
          'Do not crash when the app dies',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 500;
              is $res->message, 'Internal Server Error';
          },
          sub {
              my $env = shift;
              open my $io, '>', \my $error;
              $env->{'psgi.errors'} = $io;
              die "Throwing an exception from app handler. Server shouldn't crash.";
          },
      ],
      [
          'multi headers (request)',
          sub {
              my $cb  = shift;
              my $req = HTTP::Request->new(
                  GET => "http://127.0.0.1/",
              );
              $req->push_header(Foo => "bar");
              $req->push_header(Foo => "baz");
              my $res = $cb->($req);
              like($res->content, qr/^bar,\s*baz$/);
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{HTTP_FOO} ]
              ];
          },
      ],
      [
          'multi headers (response)',
          sub {
              my $cb  = shift;
              my $res = $cb->(HTTP::Request->new(GET => "http://127.0.0.1/"));
              my $foo = $res->header('X-Foo');
              like $foo, qr/foo,\s*bar,\s*baz/;
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', 'X-Foo', 'foo', 'X-Foo', 'bar, baz' ],
                  [ 'hi' ]
              ];
          },
      ],
      [
          'Do not set $env->{COOKIE}',
          sub {
              my $cb  = shift;
              my $req = HTTP::Request->new(
                  GET => "http://127.0.0.1/",
              );
              $req->push_header(Cookie => "foo=bar");
              my $res = $cb->($req);
              is($res->header('X-Cookie'), 0);
              is $res->content, 'foo=bar';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', 'X-Cookie' => $env->{COOKIE} ? 1 : 0 ],
                  [ $env->{HTTP_COOKIE} ]
              ];
          },
      ],
      [
          'no entity headers on 304',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 304;
              is $res->message, 'Not Modified';
              is $res->content, '';
              ok ! defined $res->header('content_type'), "No Content-Type";
              ok ! defined $res->header('content_length'), "No Content-Length";
              ok ! defined $res->header('transfer_encoding'), "No Transfer-Encoding";
          },
          sub {
              my $env = shift;
              return [ 304, [], [] ];
          },
      ],
      [
          'REQUEST_URI is set',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/bar%20baz%73?x=a");
              is $res->content, $ENV{PLACK_TEST_SCRIPT_NAME} . "/foo/bar%20baz%73?x=a";
          },
          sub {
              my $env = shift;
              return [ 200, [ 'Content-Type' => 'text/plain' ], [ $env->{REQUEST_URI} ] ];
          },
      ],
      [
          'filehandle with path()',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo.jpg");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'image/jpeg';
              is length $res->content, 2898;
          },
          sub {
              my $env = shift;
              open my $fh, '<', "$share_dir/face.jpg";
              Plack::Util::set_io_path($fh, "$share_dir/face.jpg");
              return [
                  200,
                  [ 'Content-Type' => 'image/jpeg', 'Content-Length' => -s $fh ],
                  $fh
              ];
          },
      ],
      [
          'a big header value > 128 bytes',
          sub {
              my $cb  = shift;
              my $req = GET "http://127.0.0.1/";
              my $v = ("abcdefgh" x 16);
              $req->header('X-Foo' => $v);
              my $res = $cb->($req);
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->content, $v;
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain' ],
                  [ $env->{HTTP_X_FOO} ],
              ];
          },
      ],
      [
          'coderef res',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/?name=miyagawa");
              return if $res->code == 501;
  
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=miyagawa';
          },
          sub {
              my $env = shift;
              $env->{'psgi.streaming'} or return [ 501, ['Content-Type','text/plain'], [] ];
              return sub {
                  my $respond = shift;
                  $respond->([
                      200,
                      [ 'Content-Type' => 'text/plain', ],
                      [ 'Hello, ' . $env->{QUERY_STRING} ],
                  ]);
              }
          },
      ],
      [
          'coderef streaming',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/?name=miyagawa");
              return if $res->code == 501;
  
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=miyagawa';
          },
          sub {
              my $env = shift;
              $env->{'psgi.streaming'} or return [ 501, ['Content-Type','text/plain'], [] ];
  
              return sub {
                  my $respond = shift;
  
                  my $writer = $respond->([
                      200,
                      [ 'Content-Type' => 'text/plain', ],
                  ]);
  
                  $writer->write("Hello, ");
                  $writer->write($env->{QUERY_STRING});
                  $writer->close();
              }
          },
      ],
      [
          'CRLF output and FCGI parse bug',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
  
              is $res->header("Foo"), undef;
              is $res->content, "Foo: Bar\r\n\r\nHello World";
          },
          sub {
              return [ 200, [ "Content-Type", "text/plain" ], [ "Foo: Bar\r\n\r\nHello World" ] ];
          },
      ],
      [
          'newlines',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is length($res->content), 7;
          },
          sub {
              return [ 200, [ "Content-Type", "text/plain" ], [ "Bar\nBaz" ] ];
          },
      ],
      [
          'test 404',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 404;
              is $res->message, 'Not Found';
              is $res->content, 'Not Found';
          },
          sub {
              return [ 404, [ "Content-Type", "text/plain" ], [ "Not Found" ] ];
          },
      ],
      [
          'request->input seekable',
          sub {
              my $cb = shift;
              my $req = HTTP::Request->new(POST => "http://127.0.0.1/");
              $req->content("body");
              $req->content_type('text/plain');
              $req->content_length(4);
              my $res = $cb->($req);
              is $res->content, 'body';
          },
          sub {
              my $req = Plack::Request->new(shift);
              return [ 200, [ "Content-Type", "text/plain" ], [ $req->content ] ];
          },
      ],
      [
          'request->content on GET',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              ok $res->is_success;
          },
          sub {
              my $req = Plack::Request->new(shift);
              $req->content;
              return [ 200, [ "Content-Type", "text/plain" ], [ "OK" ] ];
          },
      ],
      [
          'handle Authorization header',
          sub {
              my $cb  = shift;
              SKIP: {
                  skip "Authorization header is unsupported under CGI", 4 if ($ENV{PLACK_TEST_HANDLER} || "") eq "CGI";
  
                  {
                      my $req = HTTP::Request->new(
                          GET => "http://127.0.0.1/",
                      );
                      $req->push_header(Authorization => 'Basic XXXX');
                      my $res = $cb->($req);
                      is $res->header('X-AUTHORIZATION'), 1;
                      is $res->content, 'Basic XXXX';
                  };
  
                  {
                      my $req = HTTP::Request->new(
                          GET => "http://127.0.0.1/",
                      );
                      my $res = $cb->($req);
                      is $res->header('X-AUTHORIZATION'), 0;
                      is $res->content, 'no_auth';
                  };
              };
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', 'X-AUTHORIZATION' => exists($env->{HTTP_AUTHORIZATION}) ? 1 : 0 ],
                  [ $env->{HTTP_AUTHORIZATION} || 'no_auth' ],
              ];
          },
      ],
      [
          'repeated slashes',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1//foo///bar/baz");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, '//foo///bar/baz';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
  );
  
  sub runtests {
      my($class, $runner) = @_;
      for my $test (@TEST) {
          $runner->(@$test);
      }
  }
  
  sub run_server_tests {
      my($class, $server, $server_port, $http_port, %args) = @_;
  
      if (ref $server ne 'CODE') {
          my $server_class = $server;
          $server = sub {
              my($port, $app) = @_;
              my $server = Plack::Loader->load($server_class, port => $port, host => "127.0.0.1", %args);
              $app = Plack::Middleware::Lint->wrap($app);
              $server->run($app);
          }
      }
  
      test_tcp(
          client => sub {
              my $port = shift;
              my $ua = Plack::LWPish->new( no_proxy => [qw/127.0.0.1/] );
              for my $i (0..$#TEST) {
                  my $test = $TEST[$i];
                  note $test->[0];
                  my $cb = sub {
                      my $req = shift;
                      $req->uri->port($http_port || $port);
                      $req->uri->path(($ENV{PLACK_TEST_SCRIPT_NAME}||"") . $req->uri->path);
                      $req->header('X-Plack-Test' => $i);
                      return $ua->request($req);
                  };
  
                  $test->[1]->($cb);
              }
          },
          server => sub {
              my $port = shift;
              my $app  = $class->test_app_handler;
              $server->($port, $app);
              exit(0); # for Test::TCP
          },
          port => $server_port,
      );
  }
  
  sub test_app_handler {
      return sub {
          my $env = shift;
          $TEST[$env->{HTTP_X_PLACK_TEST}][2]->($env);
      };
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Test::Suite - Test suite for Plack handlers
  
  =head1 SYNOPSIS
  
    use Test::More;
    use Plack::Test::Suite;
    Plack::Test::Suite->run_server_tests('Your::Handler');
    done_testing;
  
  =head1 DESCRIPTION
  
  Plack::Test::Suite is a test suite to test a new PSGI server
  implementation. It automatically loads a new handler environment and
  uses LWP to send HTTP requests to the local server to make sure your
  handler implements the PSGI specification correctly.
  
  Note that the handler name doesn't include the C<Plack::Handler::>
  prefix, i.e. if you have a new Plack handler Plack::Handler::Foo, your
  test script would look like:
  
    Plack::Test::Suite->run_server_tests('Foo');
  
  Developers writing Plack applications should look at C<Plack::Test> for testing,
  as subclassing C<Plack::Handler> is for developing server implementations.
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno
  
  Tatsuhiko Miyagawa
  
  Kazuho Oku
  
  =cut
  
  END_MARK_FOR_TESTING
PLACK_TEST_SUITE

    $fatpacked{"Plack/Util.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_UTIL';
  package Plack::Util;
  use strict;
  use Carp ();
  use Scalar::Util;
  use IO::Handle;
  use overload ();
  use File::Spec ();
  
  sub TRUE()  { 1==1 }
  sub FALSE() { !TRUE }
  
  # there does not seem to be a relevant RT or perldelta entry for this
  use constant _SPLICE_SAME_ARRAY_SEGFAULT => $] < '5.008007';
  
  sub load_class {
      my($class, $prefix) = @_;
  
      if ($prefix) {
          unless ($class =~ s/^\+// || $class =~ /^$prefix/) {
              $class = "$prefix\::$class";
          }
      }
  
      my $file = $class;
      $file =~ s!::!/!g;
      require "$file.pm"; ## no critic
  
      return $class;
  }
  
  sub is_real_fh ($) {
      my $fh = shift;
  
      {
          no warnings 'uninitialized';
          return FALSE if -p $fh or -c _ or -b _;
      }
  
      my $reftype = Scalar::Util::reftype($fh) or return;
      if (   $reftype eq 'IO'
          or $reftype eq 'GLOB' && *{$fh}{IO}
      ) {
          # if it's a blessed glob make sure to not break encapsulation with
          # fileno($fh) (e.g. if you are filtering output then file descriptor
          # based operations might no longer be valid).
          # then ensure that the fileno *opcode* agrees too, that there is a
          # valid IO object inside $fh either directly or indirectly and that it
          # corresponds to a real file descriptor.
          my $m_fileno = $fh->fileno;
          return FALSE unless defined $m_fileno;
          return FALSE unless $m_fileno >= 0;
  
          my $f_fileno = fileno($fh);
          return FALSE unless defined $f_fileno;
          return FALSE unless $f_fileno >= 0;
          return TRUE;
      } else {
          # anything else, including GLOBS without IO (even if they are blessed)
          # and non GLOB objects that look like filehandle objects cannot have a
          # valid file descriptor in fileno($fh) context so may break.
          return FALSE;
      }
  }
  
  sub set_io_path {
      my($fh, $path) = @_;
      bless $fh, 'Plack::Util::IOWithPath';
      $fh->path($path);
  }
  
  sub content_length {
      my $body = shift;
  
      return unless defined $body;
  
      if (ref $body eq 'ARRAY') {
          my $cl = 0;
          for my $chunk (@$body) {
              $cl += length $chunk;
          }
          return $cl;
      } elsif ( is_real_fh($body) ) {
          return (-s $body) - tell($body);
      }
  
      return;
  }
  
  sub foreach {
      my($body, $cb) = @_;
  
      if (ref $body eq 'ARRAY') {
          for my $line (@$body) {
              $cb->($line) if length $line;
          }
      } else {
          local $/ = \65536 unless ref $/;
          while (defined(my $line = $body->getline)) {
              $cb->($line) if length $line;
          }
          $body->close;
      }
  }
  
  sub class_to_file {
      my $class = shift;
      $class =~ s!::!/!g;
      $class . ".pm";
  }
  
  sub _load_sandbox {
      my $_file = shift;
  
      my $_package = $_file;
      $_package =~ s/([^A-Za-z0-9_])/sprintf("_%2x", unpack("C", $1))/eg;
  
      local $0 = $_file; # so FindBin etc. works
      local @ARGV = ();  # Some frameworks might try to parse @ARGV
  
      return eval sprintf <<'END_EVAL', $_package;
  package Plack::Sandbox::%s;
  {
      my $app = do $_file;
      if ( !$app && ( my $error = $@ || $! )) { die $error; }
      $app;
  }
  END_EVAL
  }
  
  sub load_psgi {
      my $stuff = shift;
  
      local $ENV{PLACK_ENV} = $ENV{PLACK_ENV} || 'development';
  
      my $file = $stuff =~ /^[a-zA-Z0-9\_\:]+$/ ? class_to_file($stuff) : File::Spec->rel2abs($stuff);
      my $app = _load_sandbox($file);
      die "Error while loading $file: $@" if $@;
  
      return $app;
  }
  
  sub run_app($$) {
      my($app, $env) = @_;
  
      return eval { $app->($env) } || do {
          my $body = "Internal Server Error";
          $env->{'psgi.errors'}->print($@);
          [ 500, [ 'Content-Type' => 'text/plain', 'Content-Length' => length($body) ], [ $body ] ];
      };
  }
  
  sub headers {
      my $headers = shift;
      inline_object(
          iter   => sub { header_iter($headers, @_) },
          get    => sub { header_get($headers, @_) },
          set    => sub { header_set($headers, @_) },
          push   => sub { header_push($headers, @_) },
          exists => sub { header_exists($headers, @_) },
          remove => sub { header_remove($headers, @_) },
          headers => sub { $headers },
      );
  }
  
  sub header_iter {
      my($headers, $code) = @_;
  
      my @headers = @$headers; # copy
      while (my($key, $val) = splice @headers, 0, 2) {
          $code->($key, $val);
      }
  }
  
  sub header_get {
      my($headers, $key) = (shift, lc shift);
  
      return () if not @$headers;
  
      my $i = 0;
  
      if (wantarray) {
          return map {
              $key eq lc $headers->[$i++] ? $headers->[$i++] : ++$i && ();
          } 1 .. @$headers/2;
      }
  
      while ($i < @$headers) {
          return $headers->[$i+1] if $key eq lc $headers->[$i];
          $i += 2;
      }
  
      ();
  }
  
  sub header_set {
      my($headers, $key, $val) = @_;
  
      @$headers = ($key, $val), return if not @$headers;
  
      my ($i, $_key) = (0, lc $key);
  
      # locate and change existing header
      while ($i < @$headers) {
          $headers->[$i+1] = $val, last if $_key eq lc $headers->[$i];
          $i += 2;
      }
  
      if ($i > $#$headers) { # didn't find it?
          push @$headers, $key, $val;
          return;
      }
  
      $i += 2; # found and changed it; so, first, skip that pair
  
      return if $i > $#$headers; # anything left?
  
      # yes... so do the same thing as header_remove
      # but for the tail of the array only, starting at $i
  
      my $keep;
      my @keep = grep {
          $_ & 1 ? $keep : ($keep = $_key ne lc $headers->[$_]);
      } $i .. $#$headers;
  
      my $remainder = @$headers - $i;
      return if @keep == $remainder; # if we're not changing anything...
  
      splice @$headers, $i, $remainder, ( _SPLICE_SAME_ARRAY_SEGFAULT
          ? @{[ @$headers[@keep] ]} # force different source array
          :     @$headers[@keep]
      );
      ();
  }
  
  sub header_push {
      my($headers, $key, $val) = @_;
      push @$headers, $key, $val;
  }
  
  sub header_exists {
      my($headers, $key) = (shift, lc shift);
  
      my $check;
      for (@$headers) {
          return 1 if ($check = not $check) and $key eq lc;
      }
  
      return !1;
  }
  
  sub header_remove {
      my($headers, $key) = (shift, lc shift);
  
      return if not @$headers;
  
      my $keep;
      my @keep = grep {
          $_ & 1 ? $keep : ($keep = $key ne lc $headers->[$_]);
      } 0 .. $#$headers;
  
      @$headers = @$headers[@keep] if @keep < @$headers;
      ();
  }
  
  sub status_with_no_entity_body {
      my $status = shift;
      return $status < 200 || $status == 204 || $status == 304;
  }
  
  sub encode_html {
      my $str = shift;
      $str =~ s/&/&amp;/g;
      $str =~ s/>/&gt;/g;
      $str =~ s/</&lt;/g;
      $str =~ s/"/&quot;/g;
      $str =~ s/'/&#39;/g;
      return $str;
  }
  
  sub inline_object {
      my %args = @_;
      bless \%args, 'Plack::Util::Prototype';
  }
  
  sub response_cb {
      my($res, $cb) = @_;
  
      my $body_filter = sub {
          my($cb, $res) = @_;
          my $filter_cb = $cb->($res);
          # If response_cb returns a callback, treat it as a $body filter
          if (defined $filter_cb && ref $filter_cb eq 'CODE') {
              Plack::Util::header_remove($res->[1], 'Content-Length');
              if (defined $res->[2]) {
                  if (ref $res->[2] eq 'ARRAY') {
                      for my $line (@{$res->[2]}) {
                          $line = $filter_cb->($line);
                      }
                      # Send EOF.
                      my $eof = $filter_cb->( undef );
                      push @{ $res->[2] }, $eof if defined $eof;
                  } else {
                      my $body    = $res->[2];
                      my $getline = sub { $body->getline };
                      $res->[2] = Plack::Util::inline_object
                          getline => sub { $filter_cb->($getline->()) },
                          close => sub { $body->close };
                  }
              } else {
                  return $filter_cb;
              }
          }
      };
  
      if (ref $res eq 'ARRAY') {
          $body_filter->($cb, $res);
          return $res;
      } elsif (ref $res eq 'CODE') {
          return sub {
              my $respond = shift;
              my $cb = $cb;  # To avoid the nested closure leak for 5.8.x
              $res->(sub {
                  my $res = shift;
                  my $filter_cb = $body_filter->($cb, $res);
                  if ($filter_cb) {
                      my $writer = $respond->($res);
                      if ($writer) {
                          return Plack::Util::inline_object
                              write => sub { $writer->write($filter_cb->(@_)) },
                              close => sub {
                                  my $chunk = $filter_cb->(undef);
                                  $writer->write($chunk) if defined $chunk;
                                  $writer->close;
                              };
                      }
                  } else {
                      return $respond->($res);
                  }
              });
          };
      }
  
      return $res;
  }
  
  package Plack::Util::Prototype;
  
  our $AUTOLOAD;
  sub can {
      return $_[0]->{$_[1]} if Scalar::Util::blessed($_[0]);
      goto &UNIVERSAL::can;
  }
  
  sub AUTOLOAD {
      my $self = shift;
      my $attr = $AUTOLOAD;
      $attr =~ s/.*://;
      if (ref($self->{$attr}) eq 'CODE') {
          $self->{$attr}->(@_);
      } else {
          Carp::croak(qq/Can't locate object method "$attr" via package "Plack::Util::Prototype"/);
      }
  }
  
  sub DESTROY { }
  
  package Plack::Util::IOWithPath;
  use parent qw(IO::Handle);
  
  sub path {
      my $self = shift;
      if (@_) {
          ${*$self}{+__PACKAGE__} = shift;
      }
      ${*$self}{+__PACKAGE__};
  }
  
  package Plack::Util;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Util - Utility subroutines for Plack server and framework developers
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item TRUE, FALSE
  
    my $true  = Plack::Util::TRUE;
    my $false = Plack::Util::FALSE;
  
  Utility constants to include when you specify boolean variables in C<$env> hash (e.g. C<psgi.multithread>).
  
  =item load_class
  
    my $class = Plack::Util::load_class($class [, $prefix ]);
  
  Constructs a class name and C<require> the class. Throws an exception
  if the .pm file for the class is not found, just with the built-in
  C<require>.
  
  If C<$prefix> is set, the class name is prepended to the C<$class>
  unless C<$class> begins with C<+> sign, which means the class name is
  already fully qualified.
  
    my $class = Plack::Util::load_class("Foo");                   # Foo
    my $class = Plack::Util::load_class("Baz", "Foo::Bar");       # Foo::Bar::Baz
    my $class = Plack::Util::load_class("+XYZ::ZZZ", "Foo::Bar"); # XYZ::ZZZ
  
  Note that this function doesn't validate (or "sanitize") the passed
  string, hence if you pass a user input to this function (which is an
  insecure thing to do in the first place) it might lead to unexpected
  behavior of loading files outside your C<@INC> path. If you want a
  generic module loading function, you should check out CPAN modules
  such as L<Module::Runtime>.
  
  =item is_real_fh
  
    if ( Plack::Util::is_real_fh($fh) ) { }
  
  returns true if a given C<$fh> is a real file handle that has a file
  descriptor. It returns false if C<$fh> is PerlIO handle that is not
  really related to the underlying file etc.
  
  =item content_length
  
    my $cl = Plack::Util::content_length($body);
  
  Returns the length of content from body if it can be calculated. If
  C<$body> is an array ref it's a sum of length of each chunk, if
  C<$body> is a real filehandle it's a remaining size of the filehandle,
  otherwise returns undef.
  
  =item set_io_path
  
    Plack::Util::set_io_path($fh, "/path/to/foobar.txt");
  
  Sets the (absolute) file path to C<$fh> filehandle object, so you can
  call C<< $fh->path >> on it. As a side effect C<$fh> is blessed to an
  internal package but it can still be treated as a normal file
  handle.
  
  This module doesn't normalize or absolutize the given path, and is
  intended to be used from Server or Middleware implementations. See
  also L<IO::File::WithPath>.
  
  =item foreach
  
    Plack::Util::foreach($body, $cb);
  
  Iterate through I<$body> which is an array reference or
  IO::Handle-like object and pass each line (which is NOT really
  guaranteed to be a I<line>) to the callback function.
  
  It internally sets the buffer length C<$/> to 65536 in case it reads
  the binary file, unless otherwise set in the caller's code.
  
  =item load_psgi
  
    my $app = Plack::Util::load_psgi $psgi_file_or_class;
  
  Load C<app.psgi> file or a class name (like C<MyApp::PSGI>) and
  require the file to get PSGI application handler. If the file can't be
  loaded (e.g. file doesn't exist or has a perl syntax error), it will
  throw an exception.
  
  Since version 1.0006, this function would not load PSGI files from
  include paths (C<@INC>) unless it looks like a class name that only
  consists of C<[A-Za-z0-9_:]>. For example:
  
    Plack::Util::load_psgi("app.psgi");          # ./app.psgi
    Plack::Util::load_psgi("/path/to/app.psgi"); # /path/to/app.psgi
    Plack::Util::load_psgi("MyApp::PSGI");       # MyApp/PSGI.pm from @INC
  
  B<Security>: If you give this function a class name or module name
  that is loadable from your system, it will load the module. This could
  lead to a security hole:
  
    my $psgi = ...; # user-input: consider "Moose"
    $app = Plack::Util::load_psgi($psgi); # this would lead to 'require "Moose.pm"'!
  
  Generally speaking, passing an external input to this function is
  considered very insecure. If you really want to do that, validate that
  a given file name contains dots (like C<foo.psgi>) and also turn it
  into a full path in your caller's code.
  
  =item run_app
  
    my $res = Plack::Util::run_app $app, $env;
  
  Runs the I<$app> by wrapping errors with I<eval> and if an error is
  found, logs it to C<< $env->{'psgi.errors'} >> and returns the
  template 500 Error response.
  
  =item header_get, header_exists, header_set, header_push, header_remove
  
    my $hdrs = [ 'Content-Type' => 'text/plain' ];
  
    my $v = Plack::Util::header_get($hdrs, $key); # First found only
    my @v = Plack::Util::header_get($hdrs, $key);
    my $bool = Plack::Util::header_exists($hdrs, $key);
    Plack::Util::header_set($hdrs, $key, $val);   # overwrites existent header
    Plack::Util::header_push($hdrs, $key, $val);
    Plack::Util::header_remove($hdrs, $key);
  
  Utility functions to manipulate PSGI response headers array
  reference. The methods that read existent header value handles header
  name as case insensitive.
  
    my $hdrs = [ 'Content-Type' => 'text/plain' ];
    my $v = Plack::Util::header_get($hdrs, 'content-type'); # 'text/plain'
  
  =item headers
  
    my $headers = [ 'Content-Type' => 'text/plain' ];
  
    my $h = Plack::Util::headers($headers);
    $h->get($key);
    if ($h->exists($key)) { ... }
    $h->set($key => $val);
    $h->push($key => $val);
    $h->remove($key);
    $h->headers; # same reference as $headers
  
  Given a header array reference, returns a convenient object that has
  an instance methods to access C<header_*> functions with an OO
  interface. The object holds a reference to the original given
  C<$headers> argument and updates the reference accordingly when called
  write methods like C<set>, C<push> or C<remove>. It also has C<headers>
  method that would return the same reference.
  
  =item status_with_no_entity_body
  
    if (status_with_no_entity_body($res->[0])) { }
  
  Returns true if the given status code doesn't have any Entity body in
  HTTP response, i.e. it's 100, 101, 204 or 304.
  
  =item inline_object
  
    my $o = Plack::Util::inline_object(
        write => sub { $h->push_write(@_) },
        close => sub { $h->push_shutdown },
    );
    $o->write(@stuff);
    $o->close;
  
  Creates an instant object that can react to methods passed in the
  constructor. Handy to create when you need to create an IO stream
  object for input or errors.
  
  =item encode_html
  
    my $encoded_string = Plack::Util::encode_html( $string );
  
  Entity encodes C<<>, C<< > >>, C<&>, C<"> and C<'> in the input string
  and returns it.
  
  =item response_cb
  
  See L<Plack::Middleware/RESPONSE CALLBACK> for details.
  
  =back
  
  =cut
  
  
  
PLACK_UTIL

    $fatpacked{"Plack/Util/Accessor.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PLACK_UTIL_ACCESSOR';
  package Plack::Util::Accessor;
  use strict;
  use warnings;
  
  sub import {
      shift;
      return unless @_;
      my $package = caller();
      mk_accessors( $package, @_ );
  }
  
  sub mk_accessors {
      my $package = shift;
      no strict 'refs';
      foreach my $field ( @_ ) {
          *{ $package . '::' . $field } = sub {
              return $_[0]->{ $field } if scalar( @_ ) == 1;
              return $_[0]->{ $field }  = scalar( @_ ) == 2 ? $_[1] : [ @_[1..$#_] ];
          };
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Util::Accessor - Accessor generation utility for Plack
  
  =head1 DESCRIPTION
  
  This module is just a simple accessor generator for Plack to replace
  the Class::Accessor::Fast usage and so our classes don't have to inherit
  from their accessor generator.
  
  =head1 SEE ALSO
  
  L<PSGI> L<http://plackperl.org/>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK_UTIL_ACCESSOR

    $fatpacked{"Starlight.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'STARLIGHT';
  package Starlight;
  
  =head1 NAME
  
  Starlight - Light and pure-Perl PSGI/Plack HTTP server with pre-forks
  
  =head1 SYNOPSIS
  
  =for markdown ```console
  
      $ plackup -s Starlight --port=80 [options] your-app.psgi
  
      $ plackup -s Starlight --port=443 --ssl=1 --ssl-key-file=file.key
                              --ssl-cert-file=file.crt [options] your-app.psgi
  
      $ plackup -s Starlight --port=80 --ipv6 [options] your-app.psgi
  
      $ plackup -s Starlight --socket=/tmp/starlight.sock [options] your-app.psgi
  
      $ starlight your-app.psgi
  
      $ starlight --help
  
  =for markdown ```
  
  =head1 DESCRIPTION
  
  Starlight is a standalone HTTP/1.1 server with keep-alive support. It uses
  pre-forking. It is pure-Perl implementation which doesn't require any XS
  package.
  
  See L<plackup> and L<starlight> (lower case) for available command line
  options.
  
  =for readme stop
  
  =cut
  
  use 5.008_001;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.0501';
  
  1;
  
  __END__
  
  =head1 SEE ALSO
  
  L<starlight>,
  L<Thrall>,
  L<Starlet>,
  L<Starman>
  
  =head1 AUTHORS
  
  Piotr Roszatycki <dexter@cpan.org>
  
  Based on Thrall by:
  
  Piotr Roszatycki <dexter@cpan.org>
  
  Based on Starlet by:
  
  Kazuho Oku
  
  miyagawa
  
  kazeburo
  
  Some code based on Plack:
  
  Tatsuhiko Miyagawa
  
  =head1 LICENSE
  
  Copyright (c) 2013-2016, 2020, 2023 Piotr Roszatycki <dexter@cpan.org>.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as perl itself.
  
  See L<http://dev.perl.org/licenses/artistic.html>
STARLIGHT

    $fatpacked{"Starlight/Server.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'STARLIGHT_SERVER';
  package Starlight::Server;
  
  =head1 NAME
  
  Starlight::Server - Core class for a Starlight server
  
  =head1 SYNOPSIS
  
  =for markdown ```perl
  
      use Starlight::Server;
  
      my $server = Starlight::Server->new(port  => $port);
      $server->run(sub { [200, ['Content-Type', 'text/plain'], ['PSGI app']] });
  
  =for markdown ```
  
  =head1 DESCRIPTION
  
  This is a core class for a Starlight server. It should be used by a
  L<Plack::Handler::Starlight> handler when started with `plackup` command.
  
  =cut
  
  use strict;
  use warnings;
  
  our $VERSION = '0.0501';
  
  use Config;
  
  use English '-no_match_vars';
  use Errno ();
  use File::Spec;
  use Plack;
  use Plack::HTTPParser qw( parse_http_request );
  use IO::Socket::INET;
  use HTTP::Date;
  use HTTP::Status;
  use List::Util qw(max sum);
  use Plack::Util;
  use Plack::TempBuffer;
  use Socket qw(IPPROTO_TCP TCP_NODELAY);
  
  use Try::Tiny;
  
  BEGIN {
      try { require Time::HiRes; Time::HiRes->import(qw(time)) }
  }
  
  use constant DEBUG            => $ENV{PERL_STARLIGHT_DEBUG};
  use constant CHUNKSIZE        => 64 * 1024;
  use constant MAX_REQUEST_SIZE => 131072;
  
  use constant HAS_INET6        => eval { AF_INET6 && socket my $ipv6_socket, AF_INET6, SOCK_DGRAM, 0 } && 1;
  use constant HAS_IO_SOCKET_IP => eval { require IO::Socket::IP; 1 }                                   && 1;
  
  use constant EINTR       => exists &Errno::EINTR       ? &Errno::EINTR       : -1;    ## no critic
  use constant EAGAIN      => exists &Errno::EAGAIN      ? &Errno::EAGAIN      : -1;    ## no critic
  use constant EWOULDBLOCK => exists &Errno::EWOULDBLOCK ? &Errno::EWOULDBLOCK : -1;    ## no critic
  
  ## no critic(InputOutput::RequireBriefOpen InputOutput::RequireCheckedOpen)
  my $null_io = do { open my $io, "<", \""; $io };
  
  sub new {
      my ($class, %args) = @_;
  
      my $self = bless {
          host               => $args{host},
          port               => $args{port},
          socket             => $args{socket},
          listen             => $args{listen},
          listen_sock        => $args{listen_sock},
          timeout            => $args{timeout}            || 300,
          keepalive_timeout  => $args{keepalive_timeout}  || 2,
          max_keepalive_reqs => $args{max_keepalive_reqs} || 1,
          server_software    => $args{server_software}    || "Starlight/$VERSION ($^O)",
          server_ready       => $args{server_ready}       || sub { },
          ssl                => $args{ssl},
          ipv6               => $args{ipv6} || HAS_IO_SOCKET_IP,
          ssl_key_file       => $args{ssl_key_file},
          ssl_cert_file      => $args{ssl_cert_file},
          ssl_ca_file        => $args{ssl_ca_file},
          ssl_client_ca_file => $args{ssl_client_ca_file},
          ssl_verify_mode    => $args{ssl_verify_mode},
          user               => $args{user},
          group              => $args{group},
          umask              => $args{umask},
          daemonize          => $args{daemonize},
          pid                => $args{pid},
          error_log          => $args{error_log},
          quiet              => $args{quiet} || $args{q} || $ENV{PLACK_QUIET},
          min_reqs_per_child => (
              defined $args{min_reqs_per_child} ? $args{min_reqs_per_child} : undef,
          ),
          max_reqs_per_child => (
              $args{max_reqs_per_child} || $args{max_requests} || 1000,
          ),
          spawn_interval       => $args{spawn_interval} || 0,
          err_respawn_interval => (
              defined $args{err_respawn_interval} ? $args{err_respawn_interval} : undef,
          ),
          main_process_delay  => $args{main_process_delay} || 0.1,
          is_multithread      => Plack::Util::FALSE,
          is_multiprocess     => Plack::Util::FALSE,
          _using_defer_accept => undef,
          _unlink             => [],
          _sigint             => 'INT',
      }, $class;
  
      # Windows 7 and previous have bad SIGINT handling
      if ($^O eq 'MSWin32') {
          require Win32;
          my @v = Win32::GetOSVersion();
          if ($v[1] * 1000 + $v[2] < 6_002) {
              $self->{_sigint} = 'TERM';
          }
      }
  
      if ($args{max_workers} && $args{max_workers} > 1) {
          die(
              "Forking in $class is deprecated. Falling back to the single process mode. ",
              "If you need more workers, use Starlight instead and run like `plackup -s Starlight`\n",
          );
      }
  
      $self;
  }
  
  sub run {
      my ($self, $app) = @_;
      $self->setup_listener();
      $self->accept_loop($app);
  }
  
  sub prepare_socket_class {
      my ($self, $args) = @_;
  
      if ($self->{socket} and $self->{port}) {
          die "UNIX socket and ether IPv4 or IPv6 are not supported at the same time.\n";
      }
  
      if ($self->{socket} and $self->{ssl}) {
          die "UNIX socket and SSL are not supported at the same time.\n";
      }
  
      if ($self->{socket}) {
          try { require IO::Socket::UNIX; 1 }
              or die "UNIX socket suport requires IO::Socket::UNIX\n";
          $args->{Local} =~ s/^@/\0/;    # abstract socket address
          return "IO::Socket::UNIX";
      }
  
      if ($self->{ipv6}) {
          die "IPv6 support requires IO::Socket::IP\n" unless HAS_IO_SOCKET_IP;
      }
  
      if ($self->{ssl}) {
          try { require IO::Socket::SSL; 1 }
              or die "SSL suport requires IO::Socket::SSL\n";
          $args->{SSL_key_file} = $self->{ssl_key_file};
          $args->{SSL_cert_file} = $self->{ssl_cert_file};
          $args->{SSL_ca_file} = $self->{ssl_ca_file};
          $args->{SSL_client_ca_file} = $self->{ssl_client_ca_file};
          $args->{SSL_startHandshake} = 0;
      }
  
      return "IO::Socket::SSL" if $self->{ssl};
      return "IO::Socket::IP"  if $self->{ipv6};
      return "IO::Socket::INET";
  }
  
  sub setup_listener {
      my ($self) = @_;
  
      my %args = $self->{socket}
          ? (
          Listen => Socket::SOMAXCONN,
          Local  => $self->{socket},
          )
          : (
          Listen    => Socket::SOMAXCONN,
          LocalPort => $self->{port} || 5000,
          LocalAddr => $self->{host},
          Proto     => 'tcp',
          ReuseAddr => 1,
          );
  
      my $proto = $self->{ssl} ? 'https' : 'http';
      my $listening = $self->{socket} ? "socket $self->{socket}" : "port $self->{port}";
  
      my $class = $self->prepare_socket_class(\%args);
      $self->{listen_sock} ||= $class->new(%args)
          or do {
          die "failed to listen to $listening: $!\n";
          };
  
      print STDERR "Starting $self->{server_software} $proto server listening at $listening\n"
          unless $self->{quiet};
  
      my $family = Socket::sockaddr_family(getsockname($self->{listen_sock}));
      $self->{_listen_sock_is_unix} = $family == AF_UNIX;
      $self->{_listen_sock_is_tcp} = $family != AF_UNIX;
  
      # set defer accept
      if ($^O eq 'linux' && $self->{_listen_sock_is_tcp}) {
          setsockopt($self->{listen_sock}, IPPROTO_TCP, 9, 1)
              and $self->{_using_defer_accept} = 1;
      }
  
      if ($self->{_listen_sock_is_unix} && not $args{Local} =~ /^\0/) {
          $self->_add_to_unlink(File::Spec->rel2abs($args{Local}));
      }
  
      $self->{server_ready}->({ %$self, proto => $proto });
  }
  
  sub accept_loop {
  
      # TODO handle $max_reqs_per_child
      my ($self, $app, $max_reqs_per_child) = @_;
      my $proc_req_count = 0;
  
      $self->{can_exit} = 1;
      my $is_keepalive = 0;
      my $sigint = $self->{_sigint};
      local $SIG{$sigint} = local $SIG{TERM} = sub {
          my ($sig) = @_;
          warn "*** SIG$sig received in process $$" if DEBUG;
          exit 0                                    if $self->{can_exit};
          $self->{term_received}++;
          exit 0
              if ($is_keepalive && $self->{can_exit}) || $self->{term_received} > 1;
  
          # warn "server termination delayed while handling current HTTP request";
      };
  
      local $SIG{PIPE} = 'IGNORE';
  
      while (!defined $max_reqs_per_child || $proc_req_count < $max_reqs_per_child) {
          my ($conn, $peer) = $self->{listen_sock}->accept or do {
              warn "failed to accept: $!\n";
              next;
          };
  
          my ($peerport, $peerhost, $peeraddr) = (0, undef, undef);
          if ($self->{_listen_sock_is_tcp}) {
              if (HAS_INET6 && Socket::sockaddr_family(getsockname($conn)) == AF_INET6) {
                  ($peerport, $peerhost) = Socket::unpack_sockaddr_in6($peer);
                  $peeraddr = Socket::inet_ntop(AF_INET6, $peerhost);
              } else {
                  ($peerport, $peerhost) = Socket::unpack_sockaddr_in($peer);
                  $peeraddr = Socket::inet_ntoa($peerhost);
              }
              if (try { TCP_NODELAY }) {
                  $conn->setsockopt(IPPROTO_TCP, TCP_NODELAY, 1)
                      or do {
                      warn "setsockopt(TCP_NODELAY) failed for $peeraddr:$peerport: $!\n";
                      next;
                      };
              }
          }
  
          if ($conn->isa('IO::Socket::SSL')) {
              $conn->accept_SSL or do {
                  my @err = ();
                  push @err, $!                          if $!;
                  push @err, $IO::Socket::SSL::SSL_ERROR if $IO::Socket::SSL::SSL_ERROR;
                  warn "failed to ssl handshake with $peeraddr:$peerport: @{[join ': ', @err]}\n";
                  next;
              };
          }
  
          $self->{_is_deferred_accept} = $self->{_using_defer_accept};
          $conn->blocking(0)
              or do {
              warn "failed to set socket to nonblocking mode for $peeraddr:$peerport: $!\n";
              next;
              };
  
          my $req_count = 0;
          my $pipelined_buf = '';
          while (1) {
              ++$req_count;
              ++$proc_req_count;
              my $env = {
                  SERVER_PORT            => $self->{port} || 0,
                  SERVER_NAME            => $self->{host} || '*',
                  SCRIPT_NAME            => '',
                  REMOTE_ADDR            => $peeraddr,
                  REMOTE_PORT            => $peerport,
                  'psgi.version'         => [1, 1],
                  'psgi.errors'          => *STDERR,
                  'psgi.url_scheme'      => $self->{ssl} ? 'https' : 'http',
                  'psgi.run_once'        => Plack::Util::FALSE,
                  'psgi.multithread'     => $self->{is_multithread},
                  'psgi.multiprocess'    => $self->{is_multiprocess},
                  'psgi.streaming'       => Plack::Util::TRUE,
                  'psgi.nonblocking'     => Plack::Util::FALSE,
                  'psgix.input.buffered' => Plack::Util::TRUE,
                  'psgix.io'             => $conn,
                  'psgix.harakiri'       => Plack::Util::TRUE,
              };
  
              my $may_keepalive = $req_count < $self->{max_keepalive_reqs};
              if ($may_keepalive && $max_reqs_per_child && $proc_req_count >= $max_reqs_per_child) {
                  $may_keepalive = undef;
              }
              $may_keepalive = 1 if length $pipelined_buf;
              my $keepalive;
              ($keepalive, $pipelined_buf) = $self->handle_connection(
                  $env, $conn, $app,
                  $may_keepalive, $req_count != 1, $pipelined_buf
              );
  
              if ($env->{'psgix.harakiri.commit'}) {
                  $conn->close;
                  return;
              }
              last unless $keepalive;
  
  # TODO add special cases for clients with broken keep-alive support, as well as disabling keep-alive for HTTP/1.0 proxies
          }
          $conn->close;
      }
  }
  
  my $bad_response = [400, ['Content-Type' => 'text/plain', 'Connection' => 'close'], ['Bad Request']];
  
  sub handle_connection {
      my ($self, $env, $conn, $app, $use_keepalive, $is_keepalive, $prebuf) = @_;
  
      my $buf = '';
      my $pipelined_buf = '';
      my $res = $bad_response;
  
      local $self->{can_exit} = (defined $prebuf) ? 0 : 1;
      while (1) {
          my $rlen;
          if ($rlen = length $prebuf) {
              $buf = $prebuf;
              undef $prebuf;
          } else {
              $rlen = $self->read_timeout(
                  $conn, \$buf, MAX_REQUEST_SIZE - length($buf), length($buf),
                  $is_keepalive ? $self->{keepalive_timeout} : $self->{timeout},
              ) or return;
          }
          $self->{can_exit} = 0;
          my $reqlen = parse_http_request($buf, $env);
          if ($reqlen >= 0) {
  
              # handle request
              my $protocol = $env->{SERVER_PROTOCOL};
              if ($use_keepalive) {
                  if ($protocol eq 'HTTP/1.1') {
                      if (my $c = $env->{HTTP_CONNECTION}) {
                          $use_keepalive = undef
                              if $c =~ /^\s*close\s*/i;
                      }
                  } else {
                      if (my $c = $env->{HTTP_CONNECTION}) {
                          $use_keepalive = undef
                              unless $c =~ /^\s*keep-alive\s*/i;
                      } else {
                          $use_keepalive = undef;
                      }
                  }
              }
              $buf = substr $buf, $reqlen;
              my $chunked = do { no warnings 'all'; lc delete $env->{HTTP_TRANSFER_ENCODING} eq 'chunked' };
              if (my $cl = $env->{CONTENT_LENGTH}) {
                  my $buffer = Plack::TempBuffer->new($cl);
                  while ($cl > 0) {
                      my $chunk;
                      if (length $buf) {
                          $chunk = $buf;
                          $buf = '';
                      } else {
                          $self->read_timeout($conn, \$chunk, $cl, 0, $self->{timeout})
                              or return;
                      }
                      $buffer->print($chunk);
                      $cl -= length $chunk;
                  }
                  $env->{'psgi.input'} = $buffer->rewind;
              } elsif ($chunked) {
                  my $buffer = Plack::TempBuffer->new;
                  my $chunk_buffer = '';
                  my $length;
              DECHUNK: while (1) {
                      my $chunk;
                      if (length $buf) {
                          $chunk = $buf;
                          $buf = '';
                      } else {
                          $self->read_timeout($conn, \$chunk, CHUNKSIZE, 0, $self->{timeout})
                              or return;
                      }
  
                      $chunk_buffer .= $chunk;
                      while ($chunk_buffer =~ s/^(([0-9a-fA-F]+).*\015\012)//) {
                          my $trailer = $1;
                          my $chunk_len = hex $2;
                          if ($chunk_len == 0) {
                              last DECHUNK;
                          } elsif (length $chunk_buffer < $chunk_len + 2) {
                              $chunk_buffer = $trailer . $chunk_buffer;
                              last;
                          }
                          $buffer->print(substr $chunk_buffer, 0, $chunk_len, '');
                          $chunk_buffer =~ s/^\015\012//;
                          $length += $chunk_len;
                      }
                  }
                  $env->{CONTENT_LENGTH} = $length;
                  $env->{'psgi.input'} = $buffer->rewind;
              } else {
                  if ($buf =~ m!^(?:GET|HEAD)!) {    #pipeline
                      $pipelined_buf = $buf;
                      $use_keepalive = 1;            #force keepalive
                  }    # else clear buffer
                  $env->{'psgi.input'} = $null_io;
              }
  
              if ($env->{HTTP_EXPECT}) {
                  if ($env->{HTTP_EXPECT} eq '100-continue') {
                      $self->write_all($conn, "HTTP/1.1 100 Continue\015\012\015\012")
                          or return;
                  } else {
                      $res = [417, ['Content-Type' => 'text/plain', 'Connection' => 'close'], ['Expectation Failed']];
                      last;
                  }
              }
  
              $res = Plack::Util::run_app $app, $env;
              last;
          }
          if ($reqlen == -2) {
  
              # request is incomplete, do nothing
          } elsif ($reqlen == -1) {
  
              # error, close conn
              last;
          }
      }
  
      if (ref $res eq 'ARRAY') {
          $self->_handle_response($env->{SERVER_PROTOCOL}, $res, $conn, \$use_keepalive);
      } elsif (ref $res eq 'CODE') {
          $res->(
              sub {
                  $self->_handle_response($env->{SERVER_PROTOCOL}, $_[0], $conn, \$use_keepalive);
              }
          );
      } else {
          die "Bad response $res\n";
      }
      if ($self->{term_received}) {
          exit 0;
      }
  
      return ($use_keepalive, $pipelined_buf);
  }
  
  sub _handle_response {
      my ($self, $protocol, $res, $conn, $use_keepalive_r) = @_;
      my $status_code = $res->[0];
      my $headers = $res->[1];
      my $body = $res->[2];
  
      my @lines;
      my %send_headers;
      for (my $i = 0; $i < @$headers; $i += 2) {
          my $k = $headers->[$i];
          my $v = $headers->[$i + 1];
          $v = '' if not defined $v;
          my $lck = lc $k;
          if ($lck eq 'connection') {
              $$use_keepalive_r = undef
                  if $$use_keepalive_r && lc $v ne 'keep-alive';
          } else {
              push @lines, "$k: $v\015\012";
              $send_headers{$lck} = $v;
          }
      }
      if (!exists $send_headers{server}) {
          unshift @lines, "Server: $self->{server_software}\015\012";
      }
      if (!exists $send_headers{date}) {
          unshift @lines, "Date: @{[HTTP::Date::time2str()]}\015\012";
      }
  
      # try to set content-length when keepalive can be used, or disable it
      my $use_chunked;
      if (defined $protocol and $protocol eq 'HTTP/1.1') {
          if (   defined $send_headers{'content-length'}
              || defined $send_headers{'transfer-encoding'})
          {
              # ok
          } elsif (!Plack::Util::status_with_no_entity_body($status_code)) {
              push @lines, "Transfer-Encoding: chunked\015\012";
              $use_chunked = 1;
          }
          push @lines, "Connection: close\015\012" unless $$use_keepalive_r;
      } else {
  
          # HTTP/1.0
          if ($$use_keepalive_r) {
              if (   defined $send_headers{'content-length'}
                  || defined $send_headers{'transfer-encoding'})
              {
                  # ok
              } elsif (!Plack::Util::status_with_no_entity_body($status_code)
                  && defined(my $cl = Plack::Util::content_length($body)))
              {
                  push @lines, "Content-Length: $cl\015\012";
              } else {
                  $$use_keepalive_r = undef;
              }
          }
          push @lines, "Connection: keep-alive\015\012" if $$use_keepalive_r;
          push @lines, "Connection: close\015\012"      if !$$use_keepalive_r;    #fmm..
      }
  
      unshift @lines, "HTTP/1.1 $status_code @{[ HTTP::Status::status_message($status_code) || 'Unknown' ]}\015\012";
      push @lines, "\015\012";
  
      if (   defined $body
          && ref $body eq 'ARRAY'
          && @$body == 1
          && defined $body->[0]
          && length $body->[0] < 8192)
      {
          # combine response header and small request body
          my $buf = $body->[0];
          if ($use_chunked) {
              my $len = length $buf;
              $buf = sprintf("%x", $len) . "\015\012" . $buf . "\015\012" . '0' . "\015\012\015\012";
          }
          $self->write_all(
              $conn, join('', @lines, $buf), $self->{timeout},
          );
          return;
      }
      $self->write_all($conn, join('', @lines), $self->{timeout})
          or return;
  
      if (defined $body) {
          my $failed;
          my $completed;
          my $body_count = (ref $body eq 'ARRAY') ? $#{$body} + 1 : -1;
          Plack::Util::foreach(
              $body,
              sub {
                  unless ($failed) {
                      my $buf = $_[0];
                      --$body_count;
                      if ($use_chunked) {
                          my $len = length $buf;
                          return unless $len;
                          $buf = sprintf("%x", $len) . "\015\012" . $buf . "\015\012";
                          if ($body_count == 0) {
                              $buf .= '0' . "\015\012\015\012";
                              $completed = 1;
                          }
                      }
                      $self->write_all($conn, $buf, $self->{timeout})
                          or $failed = 1;
                  }
              },
          );
          $self->write_all($conn, '0' . "\015\012\015\012", $self->{timeout}) if $use_chunked && !$completed;
      } else {
          return Plack::Util::inline_object write => sub {
              my $buf = $_[0];
              if ($use_chunked) {
                  my $len = length $buf;
                  return unless $len;
                  $buf = sprintf("%x", $len) . "\015\012" . $buf . "\015\012";
              }
              $self->write_all($conn, $buf, $self->{timeout});
              },
              close => sub {
              $self->write_all($conn, '0' . "\015\012\015\012", $self->{timeout}) if $use_chunked;
              };
      }
  }
  
  # returns value returned by $cb, or undef on timeout or network error
  sub do_io {
      my ($self, $is_write, $sock, $buf, $len, $off, $timeout) = @_;
      my $ret;
      unless ($is_write || delete $self->{_is_deferred_accept}) {
          goto DO_SELECT;
      }
  DO_READWRITE:
  
      # try to do the IO
      if ($is_write) {
          $ret = syswrite $sock, $buf, $len, $off
              and return $ret;
      } else {
          $ret = sysread $sock, $$buf, $len, $off
              and return $ret;
      }
      if (defined($ret) || ($! != EINTR && $! != EAGAIN && $! != EWOULDBLOCK)) {
          return;
      }
  
      # wait for data
  DO_SELECT:
      while (1) {
          my ($rfd, $wfd);
          my $efd = '';
          vec($efd, fileno($sock), 1) = 1;
          if ($is_write) {
              ($rfd, $wfd) = ('', $efd);
          } else {
              ($rfd, $wfd) = ($efd, '');
          }
          my $start_at = time;
          my $nfound = select($rfd, $wfd, $efd, $timeout);
          $timeout -= (time - $start_at);
          last   if $nfound;
          return if $timeout <= 0;
      }
      goto DO_READWRITE;
  }
  
  # returns (positive) number of bytes read, or undef if the socket is to be closed
  sub read_timeout {
      my ($self, $sock, $buf, $len, $off, $timeout) = @_;
      $self->do_io(undef, $sock, $buf, $len, $off, $timeout);
  }
  
  # returns (positive) number of bytes written, or undef if the socket is to be closed
  sub write_timeout {
      my ($self, $sock, $buf, $len, $off, $timeout) = @_;
      $self->do_io(1, $sock, $buf, $len, $off, $timeout);
  }
  
  # writes all data in buf and returns number of bytes written or undef if failed
  sub write_all {
      my ($self, $sock, $buf, $timeout) = @_;
      my $off = 0;
      while (my $len = length($buf) - $off) {
          my $ret = $self->write_timeout($sock, $buf, $len, $off, $timeout)
              or return;
          $off += $ret;
      }
      return length $buf;
  }
  
  sub _add_to_unlink {
      my ($self, $filename) = @_;
      push @{ $self->{_unlink} }, File::Spec->rel2abs($filename);
  }
  
  sub _daemonize {
      my $self = shift;
  
      if ($^O eq 'MSWin32') {
          foreach my $arg (qw(daemonize pid)) {
              die "$arg parameter is not supported on this platform ($^O)\n" if $self->{$arg};
          }
      }
  
      my ($pidfh, $pidfile);
      if ($self->{pid}) {
          $pidfile = File::Spec->rel2abs($self->{pid});
          if (defined *Fcntl::O_EXCL{CODE}) {
              sysopen $pidfh, $pidfile, Fcntl::O_WRONLY | Fcntl::O_CREAT | Fcntl::O_EXCL
                  or die "Cannot open pid file: $self->{pid}: $!\n";
          } else {
              open $pidfh, '>', $pidfile or die "Cannot open pid file: $self->{pid}: $!\n";
          }
      }
  
      if (defined $self->{error_log}) {
          open STDERR, '>>', $self->{error_log} or die "Cannot open error log file: $self->{error_log}: $!\n";
      }
  
      if ($self->{daemonize}) {
  
          chdir File::Spec->rootdir or die "Cannot chdir to root directory: $!\n";
  
          open my $devnull, '+>', File::Spec->devnull or die "Cannot open null device: $!\n";
  
          open STDIN, '>&', $devnull  or die "Cannot dup null device: $!\n";
          open STDOUT, '>&', $devnull or die "Cannot dup null device: $!\n";
  
          defined(my $pid = fork) or die "Cannot fork: $!\n";
          if ($pid) {
              if ($self->{pid} and $pid) {
                  print $pidfh "$pid\n" or die "Cannot write pidfile $self->{pid}: $!\n";
                  close $pidfh;
                  open STDERR, '>&', $devnull or die "Cannot dup null device: $!\n";
              }
              exit;
          }
  
          close $pidfh if $pidfh;
  
          if ($Config::Config{d_setsid}) {
              POSIX::setsid() or die "Cannot setsid: $!\n";
          }
  
          if (not defined $self->{error_log}) {
              open STDERR, '>&', $devnull or die "Cannot dup null device: $!\n";
          }
      }
  
      if ($pidfile) {
          $self->_add_to_unlink($pidfile);
      }
  
      return;
  }
  
  sub _setup_privileges {
      my ($self) = @_;
  
      if (defined $self->{group}) {
          if (not $Config::Config{d_setegid}) {
              die "group parameter is not supported on this platform ($^O)\n";
          }
          if ($self->_get_gid($self->{group}) ne $EGID) {
              warn "*** setting group to \"$self->{group}\"" if DEBUG;
              $self->_set_gid($self->{group});
          }
      }
  
      if (defined $self->{user}) {
          if (not $Config::Config{d_seteuid}) {
              die "user parameter is not supported on this platform ($^O)\n";
          }
          if ($self->_get_uid($self->{user}) ne $EUID) {
              warn "*** setting user to \"$self->{user}\"" if DEBUG;
              $self->_set_uid($self->{user});
          }
      }
  
      if (defined $self->{umask}) {
          if (not $Config::Config{d_umask}) {
              die "umask parameter is not supported on this platform ($^O)\n";
          }
          warn "*** setting umask to \"$self->{umask}\"" if DEBUG;
          umask(oct($self->{umask}));
      }
  
      return;
  }
  
  # Taken from Net::Server::Daemonize
  sub _get_uid {
      my ($self, $user) = @_;
      my $uid = do {
          if ($user =~ /^(\d+)$/) {
              $1;
          } else {
              getpwnam($user);
          }
      };
  
      die "No such user \"$user\"\n" unless defined $uid;
      return $uid;
  }
  
  # Taken from Net::Server::Daemonize
  sub _get_gid {
      my ($self, @groups) = @_;
      my @gid;
  
      foreach my $group (split(/[, ]+/, join(" ", @groups))) {
          if ($group =~ /^\d+$/) {
              push @gid, $group;
          } else {
              my $id = getgrnam($group);
              die "No such group \"$group\"\n" unless defined $id;
              push @gid, $id;
          }
      }
  
      die "No group found in arguments.\n" unless @gid;
      return join(" ", $gid[0], @gid);
  }
  
  # Taken from Net::Server::Daemonize
  sub _set_uid {
      my ($self, $user) = @_;
      my $uid = $self->_get_uid($user);
  
      eval { POSIX::setuid($uid) } or 1;
      if ($UID != $uid || $EUID != $uid) {    # check $> also (rt #21262)
          $UID = $EUID = $uid;                # try again - needed by some 5.8.0 linux systems (rt #13450)
          if ($UID != $uid) {
              die "Couldn't become uid \"$uid\": $!\n";
          }
      }
  
      return 1;
  }
  
  # Taken from Net::Server::Daemonize
  sub _set_gid {
      my ($self, @groups) = @_;
      my $gids = $self->_get_gid(@groups);
      my $gid = (split /\s+/, $gids)[0];
      eval { $EGID = $gids } or 1;    # store all the gids - this is really sort of optional
  
      eval { POSIX::setgid($gid) } or 1;
      if (!grep { $gid == $_ } split /\s+/, $GID) {    # look for any valid id in the list
          die "Couldn't become gid \"$gid\": $!\n";
      }
  
      return 1;
  }
  
  sub _sleep {
      my ($self, $t) = @_;
      select undef, undef, undef, $t if $t;
  }
  
  sub _create_process {
      my ($self, $app) = @_;
      my $pid = fork;
      return warn "cannot fork: $!" unless defined $pid;
  
      if ($pid == 0) {
          warn "*** process $$ starting" if DEBUG;
          eval {
              $SIG{CHLD} = 'DEFAULT';
              $self->accept_loop($app, $self->_calc_reqs_per_child());
          } or 1;
          warn $@                      if $@;
          warn "*** process $$ ending" if DEBUG;
          exit 0;
      } else {
          $self->{processes}->{$pid} = 1;
      }
  }
  
  sub _calc_reqs_per_child {
      my $self = shift;
      my $max = $self->{max_reqs_per_child};
      if (my $min = $self->{min_reqs_per_child}) {
          srand((rand() * 2**30) ^ $$ ^ time);
          return $max - int(($max - $min + 1) * rand);
      } else {
          return $max;
      }
  }
  
  sub DESTROY {
      my ($self) = @_;
      while (my $f = shift @{ $self->{_unlink} }) {
          unlink $f;
      }
  }
  
  1;
  
  __END__
  
  =head1 SEE ALSO
  
  L<starlight>,
  L<Starlight>,
  L<Plack>,
  L<Plack::Runner>.
  
  =head1 LICENSE
  
  Copyright (c) 2013-2016, 2020, 2023 Piotr Roszatycki <dexter@cpan.org>.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as perl itself.
  
  See L<http://dev.perl.org/licenses/artistic.html>
STARLIGHT_SERVER

    $fatpacked{"Stream/Buffered.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'STREAM_BUFFERED';
  package Stream::Buffered;
  use strict;
  use warnings;
  
  use FileHandle; # for seek etc.
  use Stream::Buffered::Auto;
  use Stream::Buffered::File;
  use Stream::Buffered::PerlIO;
  
  our $VERSION = 0.03;
  
  our $MaxMemoryBufferSize = 1024 * 1024;
  
  sub new {
      my($class, $length) = @_;
  
      # $MaxMemoryBufferSize = 0  -> Always temp file
      # $MaxMemoryBufferSize = -1 -> Always PerlIO
      my $backend;
      if ($MaxMemoryBufferSize < 0) {
          $backend = "PerlIO";
      } elsif ($MaxMemoryBufferSize == 0) {
          $backend = "File";
      } elsif (!$length) {
          $backend = "Auto";
      } elsif ($length > $MaxMemoryBufferSize) {
          $backend = "File";
      } else {
          $backend = "PerlIO";
      }
  
      $class->create($backend, $length, $MaxMemoryBufferSize);
  }
  
  sub create {
      my($class, $backend, $length, $max) = @_;
      (__PACKAGE__ . "::$backend")->new($length, $max);
  }
  
  sub print;
  sub rewind;
  sub size;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Stream::Buffered - temporary buffer to save bytes
  
  =head1 SYNOPSIS
  
    my $buf = Stream::Buffered->new($length);
    $buf->print($bytes);
  
    my $size = $buf->size;
    my $fh   = $buf->rewind;
  
  =head1 DESCRIPTION
  
  Stream::Buffered is a buffer class to store arbitrary length of byte
  strings and then get a seekable filehandle once everything is
  buffered. It uses PerlIO and/or temporary file to save the buffer
  depending on the length of the size.
  
  =head1 SEE ALSO
  
  L<Plack::Request>
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  This module is part of L<Plack>, released as a separate distribution for easier
  reuse.
  
  =head1 COPYRIGHT
  
  The following copyright notice applies to all the files provided in
  this distribution, including binary files, unless explicitly noted
  otherwise.
  
  Copyright 2009-2011 Tatsuhiko Miyagawa
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
STREAM_BUFFERED

    $fatpacked{"Stream/Buffered/Auto.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'STREAM_BUFFERED_AUTO';
  package Stream::Buffered::Auto;
  use strict;
  use warnings;
  use base 'Stream::Buffered';
  
  sub new {
      my($class, undef, $max_memory_size) = @_;
      bless {
          _buffer => Stream::Buffered->create('PerlIO'),
          _max => $max_memory_size,
      }, $class;
  }
  
  sub print {
      my $self = shift;
      $self->{_buffer}->print(@_);
  
      if ($self->{_max} && $self->{_buffer}->size > $self->{_max}) {
          my $buf = $self->{_buffer}->{buffer};
          $self->{_buffer} = Stream::Buffered->create('File'),
          $self->{_buffer}->print($buf);
          delete $self->{_max};
      }
  }
  
  sub size {
      my $self = shift;
      $self->{_buffer}->size;
  }
  
  sub rewind {
      my $self = shift;
      $self->{_buffer}->rewind;
  }
  
  1;
STREAM_BUFFERED_AUTO

    $fatpacked{"Stream/Buffered/File.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'STREAM_BUFFERED_FILE';
  package Stream::Buffered::File;
  use strict;
  use warnings;
  use base 'Stream::Buffered';
  
  use IO::File;
  
  sub new {
      my $class = shift;
  
      my $fh = IO::File->new_tmpfile;
      $fh->binmode;
  
      bless { fh => $fh }, $class;
  }
  
  sub print {
      my $self = shift;
      $self->{fh}->print(@_);
  }
  
  sub size {
      my $self = shift;
      $self->{fh}->flush;
      -s $self->{fh};
  }
  
  sub rewind {
      my $self = shift;
      $self->{fh}->seek(0, 0);
      $self->{fh};
  }
  
  1;
STREAM_BUFFERED_FILE

    $fatpacked{"Stream/Buffered/PerlIO.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'STREAM_BUFFERED_PERLIO';
  package Stream::Buffered::PerlIO;
  use strict;
  use warnings;
  use base 'Stream::Buffered';
  
  sub new {
      my $class = shift;
      bless { buffer => '' }, $class;
  }
  
  sub print {
      my $self = shift;
      $self->{buffer} .= "@_";
  }
  
  sub size {
      my $self = shift;
      length $self->{buffer};
  }
  
  sub rewind {
      my $self = shift;
      my $buffer = $self->{buffer};
      open my $io, "<", \$buffer;
      bless $io, 'FileHandle'; # This makes $io work as FileHandle under 5.8, .10 and .11 :/
      return $io;
  }
  
  1;
STREAM_BUFFERED_PERLIO

    $fatpacked{"Thrall.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'THRALL';
  package Thrall;
  
  =head1 NAME
  
  Thrall - Simple PSGI/Plack HTTP server which uses threads
  
  =head1 SYNOPSIS
  
  =for markdown ```console
  
      $ plackup -s Thrall --port=80 [options] your-app.psgi
  
      $ plackup -s Thrall --port=443 --ssl=1 --ssl-key-file=file.key
                          --ssl-cert-file=file.crt [options] your-app.psgi
  
      $ plackup -s Thrall --port=80 --ipv6 [options] your-app.psgi
  
      $ plackup -s Thrall --socket=/tmp/thrall.sock [options] your-app.psgi
  
      $ thrall your-app.psgi
  
      $ thrall --help
  
  =for markdown ```
  
  =head1 DESCRIPTION
  
  Thrall is a standalone HTTP/1.1 server with keep-alive support. It uses
  threads instead pre-forking, so it works correctly on Windows. It is a
  pure-Perl implementation which doesn't require any XS package.
  
  See L<plackup> and L<thrall> (lower case) for available command line
  options.
  
  =for readme stop
  
  =cut
  
  use 5.008_001;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.0402';
  
  1;
  
  __END__
  
  =head1 SEE ALSO
  
  L<thrall>,
  L<Starlight>,
  L<Starlet>,
  L<Starman>
  
  =head1 AUTHORS
  
  Piotr Roszatycki <dexter@cpan.org>
  
  Based on Starlet by:
  
  Kazuho Oku
  
  miyagawa
  
  kazeburo
  
  Some code based on Plack:
  
  Tatsuhiko Miyagawa
  
  =head1 LICENSE
  
  Copyright (c) 2013-2017, 2023 Piotr Roszatycki <dexter@cpan.org>.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as perl itself.
  
  See L<http://dev.perl.org/licenses/artistic.html>
THRALL

    $fatpacked{"Thrall/Server.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'THRALL_SERVER';
  package Thrall::Server;
  
  =head1 NAME
  
  Thrall::Server - Core class for a Thrall server
  
  =head1 SYNOPSIS
  
  =for markdown ```perl
  
      use Thrall::Server;
  
      my $server = Thrall::Server->new(port  => $port);
      $server->run(sub { [200, ['Content-Type', 'text/plain'], ['PSGI app']] });
  
  =for markdown ```
  
  =head1 DESCRIPTION
  
  This is a core class for a Thrall server. It should be used by a
  L<Plack::Handler::Thrall> handler when started with `plackup` command.
  
  =cut
  
  use strict;
  use warnings;
  
  our $VERSION = '0.0402';
  
  use Config;
  
  use if !$Config{useithreads}, 'forks';
  use threads;
  
  use English '-no_match_vars';
  use Errno ();
  use File::Spec;
  use Plack;
  use Plack::HTTPParser qw( parse_http_request );
  use IO::Socket::INET;
  use HTTP::Date;
  use HTTP::Status;
  use List::Util qw(max sum);
  use Plack::Util;
  use Plack::TempBuffer;
  use Socket qw(IPPROTO_TCP TCP_NODELAY);
  
  use Try::Tiny;
  
  BEGIN {
      try { require Time::HiRes; Time::HiRes->import(qw(time)) }
  }
  
  use constant DEBUG            => $ENV{PERL_THRALL_DEBUG};
  use constant CHUNKSIZE        => 64 * 1024;
  use constant MAX_REQUEST_SIZE => 131072;
  
  use constant HAS_INET6        => eval { AF_INET6 && socket my $ipv6_socket, AF_INET6, SOCK_DGRAM, 0 };
  use constant HAS_IO_SOCKET_IP => eval { require IO::Socket::IP; 1 } && 1;
  
  use constant EINTR       => exists &Errno::EINTR       ? &Errno::EINTR       : -1;    ## no critic
  use constant EAGAIN      => exists &Errno::EAGAIN      ? &Errno::EAGAIN      : -1;    ## no critic
  use constant EWOULDBLOCK => exists &Errno::EWOULDBLOCK ? &Errno::EWOULDBLOCK : -1;    ## no critic
  
  my $null_io = do { open my $io, "<", \""; $io };
  
  sub new {
      my ($class, %args) = @_;
  
      my $self = bless {
          host               => $args{host},
          port               => $args{port},
          socket             => $args{socket},
          listen             => $args{listen},
          listen_sock        => $args{listen_sock},
          timeout            => $args{timeout}            || 300,
          keepalive_timeout  => $args{keepalive_timeout}  || 2,
          max_keepalive_reqs => $args{max_keepalive_reqs} || 1,
          server_software    => $args{server_software}    || "Thrall/$VERSION ($^O)",
          server_ready       => $args{server_ready}       || sub { },
          ssl                => $args{ssl},
          ipv6               => $args{ipv6} || HAS_IO_SOCKET_IP,
          ssl_key_file       => $args{ssl_key_file},
          ssl_cert_file      => $args{ssl_cert_file},
          ssl_ca_file        => $args{ssl_ca_file},
          ssl_client_ca_file => $args{ssl_client_ca_file},
          ssl_verify_mode    => $args{ssl_verify_mode},
          user               => $args{user},
          group              => $args{group},
          umask              => $args{umask},
          daemonize          => $args{daemonize},
          pid                => $args{pid},
          error_log          => $args{error_log},
          quiet              => $args{quiet} || $args{q} || $ENV{PLACK_QUIET},
          min_reqs_per_child => (
              defined $args{min_reqs_per_child} ? $args{min_reqs_per_child} : undef,
          ),
          max_reqs_per_child => (
              $args{max_reqs_per_child} || $args{max_requests} || 1000,
          ),
          spawn_interval       => $args{spawn_interval} || 0,
          err_respawn_interval => (
              defined $args{err_respawn_interval} ? $args{err_respawn_interval} : undef,
          ),
          main_thread_delay => $args{main_thread_delay} || 0.1,
          thread_stack_size => (
              defined $args{thread_stack_size} ? $args{thread_stack_size} : undef,
          ),
          is_multithread      => Plack::Util::FALSE,
          is_multiprocess     => Plack::Util::FALSE,
          _using_defer_accept => undef,
          _unlink             => [],
          _sigint             => 'INT',
      }, $class;
  
      # Windows 7 and previous have bad SIGINT handling
      if ($^O eq 'MSWin32') {
          require Win32;
          my @v = Win32::GetOSVersion();
          if ($v[1] * 1000 + $v[2] < 6_002) {
              $self->{_sigint} = 'TERM';
          }
      }
  
      if ($args{max_workers} && $args{max_workers} > 1) {
          die(
              "Threading in $class is deprecated. Falling back to the single thread mode. ",
              "If you need more workers, use Thrall instead and run like `plackup -s Thrall`",
          );
      }
  
      $self;
  }
  
  sub run {
      my ($self, $app) = @_;
      $self->setup_listener();
      $self->accept_loop($app);
  }
  
  sub prepare_socket_class {
      my ($self, $args) = @_;
  
      if ($self->{socket} and $self->{port}) {
          die "UNIX socket and ether IPv4 or IPv6 are not supported at the same time.\n";
      }
  
      if ($self->{socket} and $self->{ssl}) {
          die "UNIX socket and SSL are not supported at the same time.\n";
      }
  
      if ($self->{socket}) {
          try { require IO::Socket::UNIX; 1 }
              or die "UNIX socket suport requires IO::Socket::UNIX\n";
          $args->{Local} =~ s/^@/\0/;    # abstract socket address
          return "IO::Socket::UNIX";
      }
  
      if ($self->{ipv6}) {
          die "IPv6 support requires IO::Socket::IP\n" unless HAS_IO_SOCKET_IP;
      }
  
      if ($self->{ssl}) {
          try { require IO::Socket::SSL; 1 }
              or die "SSL suport requires IO::Socket::SSL\n";
          $args->{SSL_key_file} = $self->{ssl_key_file};
          $args->{SSL_cert_file} = $self->{ssl_cert_file};
          $args->{SSL_ca_file} = $self->{ssl_ca_file};
          $args->{SSL_client_ca_file} = $self->{ssl_client_ca_file};
          $args->{SSL_startHandshake} = 0;
      }
  
      return "IO::Socket::SSL" if $self->{ssl};
      return "IO::Socket::IP"  if $self->{ipv6};
      return "IO::Socket::INET";
  }
  
  sub setup_listener {
      my ($self) = @_;
  
      my %args = $self->{socket}
          ? (
          Listen => Socket::SOMAXCONN,
          Local  => $self->{socket},
          )
          : (
          Listen    => Socket::SOMAXCONN,
          LocalPort => $self->{port} || 5000,
          LocalAddr => $self->{host},
          Proto     => 'tcp',
          ReuseAddr => 1,
          );
  
      my $proto = $self->{ssl} ? 'https' : 'http';
      my $listening = $self->{socket} ? "socket $self->{socket}" : "port $self->{port}";
  
      my $class = $self->prepare_socket_class(\%args);
      $self->{listen_sock} ||= $class->new(%args)
          or die "failed to listen to $listening: $!\n";
  
      print STDERR "Starting $self->{server_software} $proto server listening at $listening\n"
          unless $self->{quiet};
  
      my $family = Socket::sockaddr_family(getsockname($self->{listen_sock}));
      $self->{_listen_sock_is_unix} = $family == AF_UNIX;
      $self->{_listen_sock_is_tcp} = $family != AF_UNIX;
  
      # set defer accept
      if ($^O eq 'linux' && $self->{_listen_sock_is_tcp}) {
          setsockopt($self->{listen_sock}, IPPROTO_TCP, 9, 1)
              and $self->{_using_defer_accept} = 1;
      }
  
      if ($self->{_listen_sock_is_unix} && not $args{Local} =~ /^\0/) {
          $self->_add_to_unlink(File::Spec->rel2abs($args{Local}));
      }
  
      $self->{server_ready}->({ %$self, proto => $proto });
  }
  
  sub accept_loop {
  
      # TODO handle $max_reqs_per_child
      my ($self, $app, $max_reqs_per_child) = @_;
      my $proc_req_count = 0;
  
      $self->{can_exit} = 1;
      my $is_keepalive = 0;
      my $sigint = $self->{_sigint};
      local $SIG{$sigint} = local $SIG{TERM} = sub {
          my ($sig) = @_;
          warn "*** SIG$sig received thread ", threads->tid if DEBUG;
          exit 0                                            if $self->{can_exit};
          $self->{term_received}++;
          exit 0
              if ($is_keepalive && $self->{can_exit}) || $self->{term_received} > 1;
  
          # warn "server termination delayed while handling current HTTP request";
      };
  
      # Threads don't like simple 'IGNORE'
      local $SIG{PIPE} = sub { 'IGNORE' };
  
      while (!defined $max_reqs_per_child || $proc_req_count < $max_reqs_per_child) {
          threads->yield;
          my ($conn, $peer) = $self->{listen_sock}->accept or do {
              warn "failed to accept: $!\n";
              next;
          };
  
          my ($peerport, $peerhost, $peeraddr) = (0, undef, undef);
          if ($self->{_listen_sock_is_tcp}) {
              if (HAS_INET6 && Socket::sockaddr_family(getsockname($conn)) == AF_INET6) {
                  ($peerport, $peerhost) = Socket::unpack_sockaddr_in6($peer);
                  $peeraddr = Socket::inet_ntop(AF_INET6, $peerhost);
              } else {
                  ($peerport, $peerhost) = Socket::unpack_sockaddr_in($peer);
                  $peeraddr = Socket::inet_ntoa($peerhost);
              }
              if (try { TCP_NODELAY }) {
                  $conn->setsockopt(IPPROTO_TCP, TCP_NODELAY, 1)
                      or do {
                      warn "setsockopt(TCP_NODELAY) failed for $peeraddr:$peerport: $!\n";
                      next;
                      };
              }
          }
  
          if ($conn->isa('IO::Socket::SSL')) {
              $conn->accept_SSL or do {
                  my @err = ();
                  push @err, $!                          if $!;
                  push @err, $IO::Socket::SSL::SSL_ERROR if $IO::Socket::SSL::SSL_ERROR;
                  warn "failed to ssl handshake with $peeraddr:$peerport: @{[join ': ', @err]}\n";
                  next;
              };
          }
  
          $self->{_is_deferred_accept} = $self->{_using_defer_accept};
          $conn->blocking(0)
              or do {
              warn "failed to set socket to nonblocking mode for $peeraddr:$peerport: $!\n";
              next;
              };
  
          my $req_count = 0;
          my $pipelined_buf = '';
          while (1) {
              ++$req_count;
              ++$proc_req_count;
              my $env = {
                  SERVER_PORT            => $self->{port} || 0,
                  SERVER_NAME            => $self->{host} || '*',
                  SCRIPT_NAME            => '',
                  REMOTE_ADDR            => $peeraddr,
                  REMOTE_PORT            => $peerport,
                  'psgi.version'         => [1, 1],
                  'psgi.errors'          => *STDERR,
                  'psgi.url_scheme'      => $self->{ssl} ? 'https' : 'http',
                  'psgi.run_once'        => Plack::Util::FALSE,
                  'psgi.multithread'     => $self->{is_multithread},
                  'psgi.multiprocess'    => $self->{is_multiprocess},
                  'psgi.streaming'       => Plack::Util::TRUE,
                  'psgi.nonblocking'     => Plack::Util::FALSE,
                  'psgix.input.buffered' => Plack::Util::TRUE,
                  'psgix.io'             => $conn,
                  'psgix.harakiri'       => Plack::Util::TRUE,
              };
  
              my $may_keepalive = $req_count < $self->{max_keepalive_reqs};
              if ($may_keepalive && $max_reqs_per_child && $proc_req_count >= $max_reqs_per_child) {
                  $may_keepalive = undef;
              }
              $may_keepalive = 1 if length $pipelined_buf;
              my $keepalive;
              ($keepalive, $pipelined_buf) = $self->handle_connection(
                  $env, $conn, $app,
                  $may_keepalive, $req_count != 1, $pipelined_buf
              );
  
              if ($env->{'psgix.harakiri.commit'}) {
                  $conn->close;
                  return;
              }
              last unless $keepalive;
  
  # TODO add special cases for clients with broken keep-alive support, as well as disabling keep-alive for HTTP/1.0 proxies
          }
          $conn->close;
      }
  }
  
  my $bad_response = [400, ['Content-Type' => 'text/plain', 'Connection' => 'close'], ['Bad Request']];
  
  sub handle_connection {
      my ($self, $env, $conn, $app, $use_keepalive, $is_keepalive, $prebuf) = @_;
  
      my $buf = '';
      my $pipelined_buf = '';
      my $res = $bad_response;
  
      local $self->{can_exit} = (defined $prebuf) ? 0 : 1;
      while (1) {
          my $rlen;
          if ($rlen = length $prebuf) {
              $buf = $prebuf;
              undef $prebuf;
          } else {
              $rlen = $self->read_timeout(
                  $conn, \$buf, MAX_REQUEST_SIZE - length($buf), length($buf),
                  $is_keepalive ? $self->{keepalive_timeout} : $self->{timeout},
              ) or return;
          }
          $self->{can_exit} = 0;
          my $reqlen = parse_http_request($buf, $env);
          if ($reqlen >= 0) {
  
              # handle request
              my $protocol = $env->{SERVER_PROTOCOL};
              if ($use_keepalive) {
                  if ($protocol eq 'HTTP/1.1') {
                      if (my $c = $env->{HTTP_CONNECTION}) {
                          $use_keepalive = undef
                              if $c =~ /^\s*close\s*/i;
                      }
                  } else {
                      if (my $c = $env->{HTTP_CONNECTION}) {
                          $use_keepalive = undef
                              unless $c =~ /^\s*keep-alive\s*/i;
                      } else {
                          $use_keepalive = undef;
                      }
                  }
              }
              $buf = substr $buf, $reqlen;
              my $chunked = do { no warnings; lc delete $env->{HTTP_TRANSFER_ENCODING} eq 'chunked' };
              if (my $cl = $env->{CONTENT_LENGTH}) {
                  my $buffer = Plack::TempBuffer->new($cl);
                  while ($cl > 0) {
                      my $chunk;
                      if (length $buf) {
                          $chunk = $buf;
                          $buf = '';
                      } else {
                          $self->read_timeout($conn, \$chunk, $cl, 0, $self->{timeout})
                              or return;
                      }
                      $buffer->print($chunk);
                      $cl -= length $chunk;
                  }
                  $env->{'psgi.input'} = $buffer->rewind;
              } elsif ($chunked) {
                  my $buffer = Plack::TempBuffer->new;
                  my $chunk_buffer = '';
                  my $length;
              DECHUNK: while (1) {
                      my $chunk;
                      if (length $buf) {
                          $chunk = $buf;
                          $buf = '';
                      } else {
                          $self->read_timeout($conn, \$chunk, CHUNKSIZE, 0, $self->{timeout})
                              or return;
                      }
  
                      $chunk_buffer .= $chunk;
                      while ($chunk_buffer =~ s/^(([0-9a-fA-F]+).*\015\012)//) {
                          my $trailer = $1;
                          my $chunk_len = hex $2;
                          if ($chunk_len == 0) {
                              last DECHUNK;
                          } elsif (length $chunk_buffer < $chunk_len + 2) {
                              $chunk_buffer = $trailer . $chunk_buffer;
                              last;
                          }
                          $buffer->print(substr $chunk_buffer, 0, $chunk_len, '');
                          $chunk_buffer =~ s/^\015\012//;
                          $length += $chunk_len;
                      }
                  }
                  $env->{CONTENT_LENGTH} = $length;
                  $env->{'psgi.input'} = $buffer->rewind;
              } else {
                  if ($buf =~ m!^(?:GET|HEAD)!) {    #pipeline
                      $pipelined_buf = $buf;
                      $use_keepalive = 1;            #force keepalive
                  }    # else clear buffer
                  $env->{'psgi.input'} = $null_io;
              }
  
              if ($env->{HTTP_EXPECT}) {
                  if ($env->{HTTP_EXPECT} eq '100-continue') {
                      $self->write_all($conn, "HTTP/1.1 100 Continue\015\012\015\012")
                          or return;
                  } else {
                      $res = [417, ['Content-Type' => 'text/plain', 'Connection' => 'close'], ['Expectation Failed']];
                      last;
                  }
              }
  
              $res = Plack::Util::run_app $app, $env;
              last;
          }
          if ($reqlen == -2) {
  
              # request is incomplete, do nothing
          } elsif ($reqlen == -1) {
  
              # error, close conn
              last;
          }
      }
  
      if (ref $res eq 'ARRAY') {
          $self->_handle_response($env->{SERVER_PROTOCOL}, $res, $conn, \$use_keepalive);
      } elsif (ref $res eq 'CODE') {
          $res->(
              sub {
                  $self->_handle_response($env->{SERVER_PROTOCOL}, $_[0], $conn, \$use_keepalive);
              }
          );
      } else {
          die "Bad response $res\n";
      }
      if ($self->{term_received}) {
          threads->exit;
      }
  
      return ($use_keepalive, $pipelined_buf);
  }
  
  sub _handle_response {
      my ($self, $protocol, $res, $conn, $use_keepalive_r) = @_;
      my $status_code = $res->[0];
      my $headers = $res->[1];
      my $body = $res->[2];
  
      my @lines;
      my %send_headers;
      for (my $i = 0; $i < @$headers; $i += 2) {
          my $k = $headers->[$i];
          my $v = $headers->[$i + 1];
          $v = '' if not defined $v;
          my $lck = lc $k;
          if ($lck eq 'connection') {
              $$use_keepalive_r = undef
                  if $$use_keepalive_r && lc $v ne 'keep-alive';
          } else {
              push @lines, "$k: $v\015\012";
              $send_headers{$lck} = $v;
          }
      }
      if (!exists $send_headers{server}) {
          unshift @lines, "Server: $self->{server_software}\015\012";
      }
      if (!exists $send_headers{date}) {
          unshift @lines, "Date: @{[HTTP::Date::time2str()]}\015\012";
      }
  
      # try to set content-length when keepalive can be used, or disable it
      my $use_chunked;
      if (defined $protocol and $protocol eq 'HTTP/1.1') {
          if (   defined $send_headers{'content-length'}
              || defined $send_headers{'transfer-encoding'})
          {
              # ok
          } elsif (!Plack::Util::status_with_no_entity_body($status_code)) {
              push @lines, "Transfer-Encoding: chunked\015\012";
              $use_chunked = 1;
          }
          push @lines, "Connection: close\015\012" unless $$use_keepalive_r;
      } else {
  
          # HTTP/1.0
          if ($$use_keepalive_r) {
              if (   defined $send_headers{'content-length'}
                  || defined $send_headers{'transfer-encoding'})
              {
                  # ok
              } elsif (!Plack::Util::status_with_no_entity_body($status_code)
                  && defined(my $cl = Plack::Util::content_length($body)))
              {
                  push @lines, "Content-Length: $cl\015\012";
              } else {
                  $$use_keepalive_r = undef;
              }
          }
          push @lines, "Connection: keep-alive\015\012" if $$use_keepalive_r;
          push @lines, "Connection: close\015\012"      if !$$use_keepalive_r;    #fmm..
      }
  
      unshift @lines, "HTTP/1.1 $status_code @{[ HTTP::Status::status_message($status_code) || 'Unknown' ]}\015\012";
      push @lines, "\015\012";
  
      if (   defined $body
          && ref $body eq 'ARRAY'
          && @$body == 1
          && defined $body->[0]
          && length $body->[0] < 8192)
      {
          # combine response header and small request body
          my $buf = $body->[0];
          if ($use_chunked) {
              my $len = length $buf;
              $buf = sprintf("%x", $len) . "\015\012" . $buf . "\015\012" . '0' . "\015\012\015\012";
          }
          $self->write_all(
              $conn, join('', @lines, $buf), $self->{timeout},
          );
          return;
      }
      $self->write_all($conn, join('', @lines), $self->{timeout})
          or return;
  
      if (defined $body) {
          my $failed;
          my $completed;
          my $body_count = (ref $body eq 'ARRAY') ? $#{$body} + 1 : -1;
          Plack::Util::foreach(
              $body,
              sub {
                  unless ($failed) {
                      my $buf = $_[0];
                      --$body_count;
                      if ($use_chunked) {
                          my $len = length $buf;
                          return unless $len;
                          $buf = sprintf("%x", $len) . "\015\012" . $buf . "\015\012";
                          if ($body_count == 0) {
                              $buf .= '0' . "\015\012\015\012";
                              $completed = 1;
                          }
                      }
                      $self->write_all($conn, $buf, $self->{timeout})
                          or $failed = 1;
                  }
              },
          );
          $self->write_all($conn, '0' . "\015\012\015\012", $self->{timeout}) if $use_chunked && !$completed;
      } else {
          return Plack::Util::inline_object write => sub {
              my $buf = $_[0];
              if ($use_chunked) {
                  my $len = length $buf;
                  return unless $len;
                  $buf = sprintf("%x", $len) . "\015\012" . $buf . "\015\012";
              }
              $self->write_all($conn, $buf, $self->{timeout});
              },
              close => sub {
              $self->write_all($conn, '0' . "\015\012\015\012", $self->{timeout}) if $use_chunked;
              };
      }
  }
  
  # returns value returned by $cb, or undef on timeout or network error
  sub do_io {
      my ($self, $is_write, $sock, $buf, $len, $off, $timeout) = @_;
      my $ret;
      unless ($is_write || delete $self->{_is_deferred_accept}) {
          goto DO_SELECT;
      }
  DO_READWRITE:
  
      # try to do the IO
      if ($is_write) {
          $ret = syswrite $sock, $buf, $len, $off
              and return $ret;
      } else {
          $ret = sysread $sock, $$buf, $len, $off
              and return $ret;
      }
      if (defined($ret) || ($! != EINTR && $! != EAGAIN && $! != EWOULDBLOCK)) {
          return;
      }
  
      # wait for data
  DO_SELECT:
      while (1) {
          my ($rfd, $wfd);
          my $efd = '';
          vec($efd, fileno($sock), 1) = 1;
          if ($is_write) {
              ($rfd, $wfd) = ('', $efd);
          } else {
              ($rfd, $wfd) = ($efd, '');
          }
          my $start_at = time;
          my $nfound = select($rfd, $wfd, $efd, $timeout);
          $timeout -= (time - $start_at);
          last   if $nfound;
          return if $timeout <= 0;
      }
      goto DO_READWRITE;
  }
  
  # returns (positive) number of bytes read, or undef if the socket is to be closed
  sub read_timeout {
      my ($self, $sock, $buf, $len, $off, $timeout) = @_;
      $self->do_io(undef, $sock, $buf, $len, $off, $timeout);
  }
  
  # returns (positive) number of bytes written, or undef if the socket is to be closed
  sub write_timeout {
      my ($self, $sock, $buf, $len, $off, $timeout) = @_;
      $self->do_io(1, $sock, $buf, $len, $off, $timeout);
  }
  
  # writes all data in buf and returns number of bytes written or undef if failed
  sub write_all {
      my ($self, $sock, $buf, $timeout) = @_;
      my $off = 0;
      while (my $len = length($buf) - $off) {
          my $ret = $self->write_timeout($sock, $buf, $len, $off, $timeout)
              or return;
          $off += $ret;
      }
      return length $buf;
  }
  
  sub _add_to_unlink {
      my ($self, $filename) = @_;
      push @{ $self->{_unlink} }, File::Spec->rel2abs($filename);
  }
  
  sub _daemonize {
      my $self = shift;
  
      if ($^O eq 'MSWin32') {
          foreach my $arg (qw(daemonize pid)) {
              die "$arg parameter is not supported on this platform ($^O)\n" if $self->{$arg};
          }
      }
  
      my ($pidfh, $pidfile);
      if ($self->{pid}) {
          $pidfile = File::Spec->rel2abs($self->{pid});
          if (defined *Fcntl::O_EXCL{CODE}) {
              sysopen $pidfh, $pidfile, Fcntl::O_WRONLY | Fcntl::O_CREAT | Fcntl::O_EXCL
                  or die "Cannot open pid file: $self->{pid}: $!\n";
          } else {
              open $pidfh, '>', $pidfile or die "Cannot open pid file: $self->{pid}: $!\n";
          }
      }
  
      if (defined $self->{error_log}) {
          open STDERR, '>>', $self->{error_log} or die "Cannot open error log file: $self->{error_log}: $!\n";
      }
  
      if ($self->{daemonize}) {
  
          chdir File::Spec->rootdir or die "Cannot chdir to root directory: $!\n";
  
          open my $devnull, '+>', File::Spec->devnull or die "Cannot open null device: $!\n";
  
          open STDIN, '>&', $devnull  or die "Cannot dup null device: $!\n";
          open STDOUT, '>&', $devnull or die "Cannot dup null device: $!\n";
  
          defined(my $pid = fork) or die "Cannot fork: $!\n";
          if ($pid) {
              if ($self->{pid} and $pid) {
                  print $pidfh "$pid\n" or die "Cannot write pidfile $self->{pid}: $!\n";
                  close $pidfh;
                  open STDERR, '>&', $devnull or die "Cannot dup null device: $!\n";
              }
              exit;
          }
  
          close $pidfh if $pidfh;
  
          if ($Config::Config{d_setsid}) {
              POSIX::setsid() or die "Cannot setsid: $!\n";
          }
  
          if (not defined $self->{error_log}) {
              open STDERR, '>&', $devnull or die "Cannot dup null device: $!\n";
          }
      }
  
      if ($pidfile) {
          $self->_add_to_unlink($pidfile);
      }
  
      return;
  }
  
  sub _setup_privileges {
      my ($self) = @_;
  
      if (defined $self->{group}) {
          if (not $Config::Config{d_setegid}) {
              die "group parameter is not supported on this platform ($^O)\n";
          }
          if ($self->_get_gid($self->{group}) ne $EGID) {
              warn "*** setting group to \"$self->{group}\"" if DEBUG;
              $self->_set_gid($self->{group});
          }
      }
  
      if (defined $self->{user}) {
          if (not $Config::Config{d_seteuid}) {
              die "user parameter is not supported on this platform ($^O)\n";
          }
          if ($self->_get_uid($self->{user}) ne $EUID) {
              warn "*** setting user to \"$self->{user}\"" if DEBUG;
              $self->_set_uid($self->{user});
          }
      }
  
      if (defined $self->{umask}) {
          if (not $Config::Config{d_umask}) {
              die "umask parameter is not supported on this platform ($^O)\n";
          }
          warn "*** setting umask to \"$self->{umask}\"" if DEBUG;
          umask(oct($self->{umask}));
      }
  
      return;
  }
  
  # Taken from Net::Server::Daemonize
  sub _get_uid {
      my ($self, $user) = @_;
      my $uid = ($user =~ /^(\d+)$/) ? $1 : getpwnam($user);
      die "No such user \"$user\"\n" unless defined $uid;
      return $uid;
  }
  
  # Taken from Net::Server::Daemonize
  sub _get_gid {
      my ($self, @groups) = @_;
      my @gid;
  
      foreach my $group (split(/[, ]+/, join(" ", @groups))) {
          if ($group =~ /^\d+$/) {
              push @gid, $group;
          } else {
              my $id = getgrnam($group);
              die "No such group \"$group\"\n" unless defined $id;
              push @gid, $id;
          }
      }
  
      die "No group found in arguments.\n" unless @gid;
      return join(" ", $gid[0], @gid);
  }
  
  # Taken from Net::Server::Daemonize
  sub _set_uid {
      my ($self, $user) = @_;
      my $uid = $self->_get_uid($user);
  
      eval { POSIX::setuid($uid) };
      if ($UID != $uid || $EUID != $uid) {    # check $> also (rt #21262)
          $UID = $EUID = $uid;                # try again - needed by some 5.8.0 linux systems (rt #13450)
          if ($UID != $uid) {
              die "Couldn't become uid \"$uid\": $!\n";
          }
      }
  
      return 1;
  }
  
  # Taken from Net::Server::Daemonize
  sub _set_gid {
      my ($self, @groups) = @_;
      my $gids = $self->_get_gid(@groups);
      my $gid = (split /\s+/, $gids)[0];
      eval { $) = $gids };    # store all the gids - this is really sort of optional
  
      eval { POSIX::setgid($gid) };
      if (!grep { $gid == $_ } split /\s+/, $GID) {    # look for any valid id in the list
          die "Couldn't become gid \"$gid\": $!\n";
      }
  
      return 1;
  }
  
  sub _sleep {
      my ($self, $t) = @_;
      select undef, undef, undef, $t if $t;
  }
  
  sub _create_thread {
      my ($self, $app) = @_;
      my $thr = threads->create(
          { context => 'void' },
          sub {
              my ($self, $app) = @_;
              warn "*** thread ", threads->tid, " starting" if DEBUG;
              eval { $self->accept_loop($app, $self->_calc_reqs_per_child()); };
              warn $@                                     if $@;
              warn "*** thread ", threads->tid, " ending" if DEBUG;
          },
          $self,
          $app
      );
  }
  
  sub _calc_reqs_per_child {
      my $self = shift;
      my $max = $self->{max_reqs_per_child};
      if (my $min = $self->{min_reqs_per_child}) {
          srand((rand() * 2**30) ^ $$ ^ time);
          return $max - int(($max - $min + 1) * rand);
      } else {
          return $max;
      }
  }
  
  sub DESTROY {
      my ($self) = @_;
      while (my $f = shift @{ $self->{_unlink} }) {
          unlink $f;
      }
  }
  
  1;
  
  __END__
  
  =head1 SEE ALSO
  
  L<thrall>,
  L<Thrall>,
  L<Plack>,
  L<Plack::Runner>.
  
  =head1 LICENSE
  
  Copyright (c) 2013-2016, 2023 Piotr Roszatycki <dexter@cpan.org>.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as perl itself.
  
  See L<http://dev.perl.org/licenses/artistic.html>
THRALL_SERVER

    $fatpacked{"Time/Local.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'TIME_LOCAL';
  package Time::Local;
  
  use strict;
  
  use Carp ();
  use Exporter;
  
  our $VERSION = '1.35';
  
  use parent 'Exporter';
  
  our @EXPORT    = qw( timegm timelocal );
  our @EXPORT_OK = qw(
      timegm_modern
      timelocal_modern
      timegm_nocheck
      timelocal_nocheck
      timegm_posix
      timelocal_posix
  );
  
  my @MonthDays = ( 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 );
  
  # Determine breakpoint for rolling century
  my $ThisYear    = ( localtime() )[5];
  my $Breakpoint  = ( $ThisYear + 50 ) % 100;
  my $NextCentury = $ThisYear - $ThisYear % 100;
  $NextCentury += 100 if $Breakpoint < 50;
  my $Century = $NextCentury - 100;
  my $SecOff  = 0;
  
  my ( %Options, %Cheat );
  
  use constant SECS_PER_MINUTE => 60;
  use constant SECS_PER_HOUR   => 3600;
  use constant SECS_PER_DAY    => 86400;
  
  my $MaxDay;
  if ( $] < 5.012000 ) {
      require Config;
      ## no critic (Variables::ProhibitPackageVars)
  
      my $MaxInt;
      if ( $^O eq 'MacOS' ) {
  
          # time_t is unsigned...
          $MaxInt = ( 1 << ( 8 * $Config::Config{ivsize} ) )
              - 1;    ## no critic qw(ProhibitPackageVars)
      }
      else {
          $MaxInt
              = ( ( 1 << ( 8 * $Config::Config{ivsize} - 2 ) ) - 1 ) * 2
              + 1;    ## no critic qw(ProhibitPackageVars)
      }
  
      $MaxDay = int( ( $MaxInt - ( SECS_PER_DAY / 2 ) ) / SECS_PER_DAY ) - 1;
  }
  else {
      # recent localtime()'s limit is the year 2**31
      $MaxDay = 365 * ( 2**31 );
  
      # On (some?) 32-bit platforms this overflows and we end up with a negative
      # $MaxDay, which totally breaks this module. This is the old calculation
      # we used from the days before Perl always had 64-bit time_t.
      if ( $MaxDay < 0 ) {
          require Config;
          ## no critic (Variables::ProhibitPackageVars)
          my $max_int
              = ( ( 1 << ( 8 * $Config::Config{intsize} - 2 ) ) - 1 ) * 2 + 1;
          $MaxDay
              = int( ( $max_int - ( SECS_PER_DAY / 2 ) ) / SECS_PER_DAY ) - 1;
      }
  }
  
  # Determine the EPOC day for this machine
  my $Epoc = 0;
  if ( $^O eq 'vos' ) {
  
      # work around posix-977 -- VOS doesn't handle dates in the range
      # 1970-1980.
      $Epoc = _daygm( 0, 0, 0, 1, 0, 70, 4, 0 );
  }
  elsif ( $^O eq 'MacOS' ) {
      $MaxDay *= 2;    # time_t unsigned ... quick hack?
                       # MacOS time() is seconds since 1 Jan 1904, localtime
                       # so we need to calculate an offset to apply later
      $Epoc   = 693901;
      $SecOff = timelocal( localtime(0) ) - timelocal( gmtime(0) );
      $Epoc += _daygm( gmtime(0) );
  }
  else {
      $Epoc = _daygm( gmtime(0) );
  }
  
  %Cheat = ();    # clear the cache as epoc has changed
  
  sub _daygm {
  
      # This is written in such a byzantine way in order to avoid
      # lexical variables and sub calls, for speed
      return $_[3] + (
          $Cheat{ pack( 'ss', @_[ 4, 5 ] ) } ||= do {
              my $month = ( $_[4] + 10 ) % 12;
              my $year  = $_[5] + 1900 - int( $month / 10 );
  
              ( ( 365 * $year )
                  + int( $year / 4 )
                      - int( $year / 100 )
                      + int( $year / 400 )
                      + int( ( ( $month * 306 ) + 5 ) / 10 ) )
                  - $Epoc;
          }
      );
  }
  
  sub _timegm {
      my $sec
          = $SecOff + $_[0]
          + ( SECS_PER_MINUTE * $_[1] )
          + ( SECS_PER_HOUR * $_[2] );
  
      return $sec + ( SECS_PER_DAY * &_daygm );
  }
  
  sub timegm {
      my ( $sec, $min, $hour, $mday, $month, $year ) = @_;
      my $subsec = $sec - int($sec);
      $sec = int($sec);
  
      if ( $Options{no_year_munging} ) {
          $year -= 1900;
      }
      elsif ( !$Options{posix_year} ) {
          if ( $year >= 1000 ) {
              $year -= 1900;
          }
          elsif ( $year < 100 and $year >= 0 ) {
              $year += ( $year > $Breakpoint ) ? $Century : $NextCentury;
          }
      }
  
      unless ( $Options{no_range_check} ) {
          Carp::croak("Month '$month' out of range 0..11")
              if $month > 11
              or $month < 0;
  
          my $md = $MonthDays[$month];
          ++$md
              if $month == 1 && _is_leap_year( $year + 1900 );
  
          Carp::croak("Day '$mday' out of range 1..$md")
              if $mday > $md or $mday < 1;
          Carp::croak("Hour '$hour' out of range 0..23")
              if $hour > 23 or $hour < 0;
          Carp::croak("Minute '$min' out of range 0..59")
              if $min > 59 or $min < 0;
          Carp::croak("Second '$sec' out of range 0..59")
              if $sec >= 60 or $sec < 0;
      }
  
      my $days = _daygm( undef, undef, undef, $mday, $month, $year );
  
      if ( abs($days) > $MaxDay && !$Options{no_range_check} ) {
          my $msg = "Day too big - abs($days) > $MaxDay\n";
  
          $year += 1900;
          $msg
              .= "Cannot handle date ($sec, $min, $hour, $mday, $month, $year)";
  
          Carp::croak($msg);
      }
  
      # Adding in the $subsec value last seems to prevent floating point errors
      # from creeping in.
      return (
          (
                    $sec + $SecOff
                  + ( SECS_PER_MINUTE * $min )
                  + ( SECS_PER_HOUR * $hour )
                  + ( SECS_PER_DAY * $days )
          ) + $subsec
      );
  }
  
  sub _is_leap_year {
      return 0 if $_[0] % 4;
      return 1 if $_[0] % 100;
      return 0 if $_[0] % 400;
  
      return 1;
  }
  
  sub timegm_nocheck {
      local $Options{no_range_check} = 1;
      return &timegm;
  }
  
  sub timegm_modern {
      local $Options{no_year_munging} = 1;
      return &timegm;
  }
  
  sub timegm_posix {
      local $Options{posix_year} = 1;
      return &timegm;
  }
  
  sub timelocal {
      my $sec    = shift;
      my $subsec = $sec - int($sec);
      $sec = int($sec);
      unshift @_, $sec;
  
      my $ref_t         = &timegm;
      my $loc_for_ref_t = _timegm( localtime($ref_t) );
  
      my $zone_off = $loc_for_ref_t - $ref_t
          or return $loc_for_ref_t + $subsec;
  
      # Adjust for timezone
      my $loc_t = $ref_t - $zone_off;
  
      # Are we close to a DST change or are we done
      my $dst_off = $ref_t - _timegm( localtime($loc_t) );
  
      # If this evaluates to true, it means that the value in $loc_t is
      # the _second_ hour after a DST change where the local time moves
      # backward.
      if (
          !$dst_off
          && ( ( $ref_t - SECS_PER_HOUR )
              - _timegm( localtime( $loc_t - SECS_PER_HOUR ) ) < 0 )
      ) {
          return ( $loc_t - SECS_PER_HOUR ) + $subsec;
      }
  
      # Adjust for DST change
      $loc_t += $dst_off;
  
      return $loc_t + $subsec if $dst_off > 0;
  
      # If the original date was a non-existent gap in a forward DST jump, we
      # should now have the wrong answer - undo the DST adjustment
      my ( $s, $m, $h ) = localtime($loc_t);
      $loc_t -= $dst_off if $s != $_[0] || $m != $_[1] || $h != $_[2];
  
      return $loc_t + $subsec;
  }
  
  sub timelocal_nocheck {
      local $Options{no_range_check} = 1;
      return &timelocal;
  }
  
  sub timelocal_modern {
      local $Options{no_year_munging} = 1;
      return &timelocal;
  }
  
  sub timelocal_posix {
      local $Options{posix_year} = 1;
      return &timelocal;
  }
  
  1;
  
  # ABSTRACT: Efficiently compute time from local and GMT time
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Time::Local - Efficiently compute time from local and GMT time
  
  =head1 VERSION
  
  version 1.35
  
  =head1 SYNOPSIS
  
      use Time::Local qw( timelocal_posix timegm_posix );
  
      my $time = timelocal_posix( $sec, $min, $hour, $mday, $mon, $year );
      my $time = timegm_posix( $sec, $min, $hour, $mday, $mon, $year );
  
  =head1 DESCRIPTION
  
  This module provides functions that are the inverse of built-in perl functions
  C<localtime()> and C<gmtime()>. They accept a date as a six-element array, and
  return the corresponding C<time(2)> value in seconds since the system epoch
  (Midnight, January 1, 1970 GMT on Unix, for example). This value can be
  positive or negative, though POSIX only requires support for positive values,
  so dates before the system's epoch may not work on all operating systems.
  
  It is worth drawing particular attention to the expected ranges for the values
  provided. The value for the day of the month is the actual day (i.e. 1..31),
  while the month is the number of months since January (0..11). This is
  consistent with the values returned from C<localtime()> and C<gmtime()>.
  
  =head1 FUNCTIONS
  
  =head2 C<timelocal_posix()> and C<timegm_posix()>
  
  I<Since version 1.30.>
  
  These functions are the exact inverse of Perl's built-in C<localtime> and
  C<gmtime> functions. That means that calling C<< timelocal_posix(
  localtime($value) ) >> will always give you the same C<$value> you started
  with. The same applies to C<< timegm_posix( gmtime($value) ) >>.
  
  The one exception is when the value returned from C<localtime()> represents an
  ambiguous local time because of a DST change. See the documentation below for
  more details.
  
  These functions expect the year value to be the number of years since 1900,
  which is what the C<localtime()> and C<gmtime()> built-ins returns.
  
  They perform range checking by default on the input C<$sec>, C<$min>, C<$hour>,
  C<$mday>, and C<$mon> values and will croak (using C<Carp::croak()>) if given a
  value outside the allowed ranges.
  
  While it would be nice to make this the default behavior, that would almost
  certainly break a lot of code, so you must explicitly import these functions
  and use them instead of the default C<timelocal()> and C<timegm()>.
  
  You are B<strongly> encouraged to use these functions in any new code which
  uses this module. It will almost certainly make your code's behavior less
  surprising.
  
  =head2 C<timelocal_modern()> and C<timegm_modern()>
  
  I<Since version 1.27.>
  
  When C<Time::Local> was first written, it was a common practice to represent
  years as a two-digit value like C<99> for C<1999> or C<1> for C<2001>. This
  caused all sorts of problems (google "Y2K problem" if you're very young) and
  developers eventually realized that this was a terrible idea.
  
  The default exports of C<timelocal()> and C<timegm()> do a complicated
  calculation when given a year value less than 1000. This leads to surprising
  results in many cases. See L</Year Value Interpretation> for details.
  
  The C<time*_modern()> functions do not do this year munging and simply take the
  year value as provided.
  
  They perform range checking by default on the input C<$sec>, C<$min>, C<$hour>,
  C<$mday>, and C<$mon> values and will croak (using C<Carp::croak()>) if given a
  value outside the allowed ranges.
  
  =head2 C<timelocal()> and C<timegm()>
  
  This module exports two functions by default, C<timelocal()> and C<timegm()>.
  
  They perform range checking by default on the input C<$sec>, C<$min>, C<$hour>,
  C<$mday>, and C<$mon> values and will croak (using C<Carp::croak()>) if given a
  value outside the allowed ranges.
  
  B<Warning: The year value interpretation that these functions and their nocheck
  variants use will almost certainly lead to bugs in your code, if not now, then
  in the future. You are strongly discouraged from using these in new code, and
  you should convert old code to using either the C<*_posix> or C<*_modern>
  functions if possible.>
  
  =head2 C<timelocal_nocheck()> and C<timegm_nocheck()>
  
  If you are working with data you know to be valid, you can use the "nocheck"
  variants, C<timelocal_nocheck()> and C<timegm_nocheck()>. These variants must
  be explicitly imported.
  
  If you supply data which is not valid (month 27, second 1,000) the results will
  be unpredictable (so don't do that).
  
  Note that my benchmarks show that this is just a 3% speed increase over the
  checked versions, so unless calling C<Time::Local> is the hottest spot in your
  application, using these nocheck variants is unlikely to have much impact on
  your application.
  
  =head2 Year Value Interpretation
  
  B<This does not apply to the C<*_posix> or C<*_modern> functions. Use those
  exports if you want to ensure consistent behavior as your code ages.>
  
  Strictly speaking, the year should be specified in a form consistent with
  C<localtime()>, i.e. the offset from 1900. In order to make the interpretation
  of the year easier for humans, however, who are more accustomed to seeing years
  as two-digit or four-digit values, the following conventions are followed:
  
  =over 4
  
  =item *
  
  Years greater than 999 are interpreted as being the actual year, rather than
  the offset from 1900. Thus, 1964 would indicate the year Martin Luther King won
  the Nobel prize, not the year 3864.
  
  =item *
  
  Years in the range 100..999 are interpreted as offset from 1900, so that 112
  indicates 2012. This rule also applies to years less than zero (but see note
  below regarding date range).
  
  =item *
  
  Years in the range 0..99 are interpreted as shorthand for years in the rolling
  "current century," defined as 50 years on either side of the current year.
  Thus, today, in 1999, 0 would refer to 2000, and 45 to 2045, but 55 would refer
  to 1955. Twenty years from now, 55 would instead refer to 2055. This is messy,
  but matches the way people currently think about two digit dates. Whenever
  possible, use an absolute four digit year instead.
  
  =back
  
  The scheme above allows interpretation of a wide range of dates, particularly
  if 4-digit years are used. But it also means that the behavior of your code
  changes as time passes, because the rolling "current century" changes each
  year.
  
  =head2 Limits of time_t
  
  On perl versions older than 5.12.0, the range of dates that can be actually be
  handled depends on the size of C<time_t> (usually a signed integer) on the
  given platform. Currently, this is 32 bits for most systems, yielding an
  approximate range from Dec 1901 to Jan 2038.
  
  Both C<timelocal()> and C<timegm()> croak if given dates outside the supported
  range.
  
  As of version 5.12.0, perl has stopped using the time implementation of the
  operating system it's running on. Instead, it has its own implementation of
  those routines with a safe range of at least +/- 2**52 (about 142 million
  years)
  
  =head2 Ambiguous Local Times (DST)
  
  Because of DST changes, there are many time zones where the same local time
  occurs for two different GMT times on the same day. For example, in the
  "Europe/Paris" time zone, the local time of 2001-10-28 02:30:00 can represent
  either 2001-10-28 00:30:00 GMT, B<or> 2001-10-28 01:30:00 GMT.
  
  When given an ambiguous local time, the timelocal() function will always return
  the epoch for the I<earlier> of the two possible GMT times.
  
  =head2 Non-Existent Local Times (DST)
  
  When a DST change causes a locale clock to skip one hour forward, there will be
  an hour's worth of local times that don't exist. Again, for the "Europe/Paris"
  time zone, the local clock jumped from 2001-03-25 01:59:59 to 2001-03-25
  03:00:00.
  
  If the C<timelocal()> function is given a non-existent local time, it will
  simply return an epoch value for the time one hour later.
  
  =head2 Negative Epoch Values
  
  On perl version 5.12.0 and newer, negative epoch values are fully supported.
  
  On older versions of perl, negative epoch (C<time_t>) values, which are not
  officially supported by the POSIX standards, are known not to work on some
  systems. These include MacOS (pre-OSX) and Win32.
  
  On systems which do support negative epoch values, this module should be able
  to cope with dates before the start of the epoch, down the minimum value of
  time_t for the system.
  
  =head1 IMPLEMENTATION
  
  These routines are quite efficient and yet are always guaranteed to agree with
  C<localtime()> and C<gmtime()>. We manage this by caching the start times of
  any months we've seen before. If we know the start time of the month, we can
  always calculate any time within the month.  The start times are calculated
  using a mathematical formula. Unlike other algorithms that do multiple calls to
  C<gmtime()>.
  
  The C<timelocal()> function is implemented using the same cache. We just assume
  that we're translating a GMT time, and then fudge it when we're done for the
  timezone and daylight savings arguments. Note that the timezone is evaluated
  for each date because countries occasionally change their official timezones.
  Assuming that C<localtime()> corrects for these changes, this routine will also
  be correct.
  
  =head1 AUTHORS EMERITUS
  
  This module is based on a Perl 4 library, timelocal.pl, that was included with
  Perl 4.036, and was most likely written by Tom Christiansen.
  
  The current version was written by Graham Barr.
  
  =head1 BUGS
  
  The whole scheme for interpreting two-digit years can be considered a bug.
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Time-Local/issues>.
  
  There is a mailing list available for users of this distribution,
  L<mailto:datetime@perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Time-Local can be found at L<https://github.com/houseabsolute/Time-Local>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Florian Ragwitz Gregory Oschwald J. Nick Koston Tom Wyant Unknown
  
  =over 4
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Gregory Oschwald <oschwald@gmail.com>
  
  =item *
  
  J. Nick Koston <nick@cpanel.net>
  
  =item *
  
  Tom Wyant <wyant@cpan.org>
  
  =item *
  
  Unknown <unknown@example.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1997 - 2023 by Graham Barr & Dave Rolsky.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
TIME_LOCAL

    $fatpacked{"Try/Tiny.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'TRY_TINY';
  package Try::Tiny; # git description: v0.30-11-g1b81d0a
  use 5.006;
  # ABSTRACT: Minimal try/catch with proper preservation of $@
  
  our $VERSION = '0.31';
  
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT = our @EXPORT_OK = qw(try catch finally);
  
  use Carp;
  $Carp::Internal{+__PACKAGE__}++;
  
  BEGIN {
    my $su = $INC{'Sub/Util.pm'} && defined &Sub::Util::set_subname;
    my $sn = $INC{'Sub/Name.pm'} && eval { Sub::Name->VERSION(0.08) };
    unless ($su || $sn) {
      $su = eval { require Sub::Util; } && defined &Sub::Util::set_subname;
      unless ($su) {
        $sn = eval { require Sub::Name; Sub::Name->VERSION(0.08) };
      }
    }
  
    *_subname = $su ? \&Sub::Util::set_subname
              : $sn ? \&Sub::Name::subname
              : sub { $_[1] };
    *_HAS_SUBNAME = ($su || $sn) ? sub(){1} : sub(){0};
  }
  
  my %_finally_guards;
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
    my ( $try, @code_refs ) = @_;
  
    # we need to save this here, the eval block will be in scalar context due
    # to $failed
    my $wantarray = wantarray;
  
    # work around perl bug by explicitly initializing these, due to the likelyhood
    # this will be used in global destruction (perl rt#119311)
    my ( $catch, @finally ) = ();
  
    # find labeled blocks in the argument list.
    # catch and finally tag the blocks by blessing a scalar reference to them.
    foreach my $code_ref (@code_refs) {
  
      if ( ref($code_ref) eq 'Try::Tiny::Catch' ) {
        croak 'A try() may not be followed by multiple catch() blocks'
          if $catch;
        $catch = ${$code_ref};
      } elsif ( ref($code_ref) eq 'Try::Tiny::Finally' ) {
        push @finally, ${$code_ref};
      } else {
        croak(
          'try() encountered an unexpected argument ('
        . ( defined $code_ref ? $code_ref : 'undef' )
        . ') - perhaps a missing semi-colon before or'
        );
      }
    }
  
    # FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
    # not perfect, but we could provide a list of additional errors for
    # $catch->();
  
    # name the blocks if we have Sub::Name installed
    _subname(caller().'::try {...} ' => $try)
      if _HAS_SUBNAME;
  
    # set up scope guards to invoke the finally blocks at the end.
    # this should really be a function scope lexical variable instead of
    # file scope + local but that causes issues with perls < 5.20 due to
    # perl rt#119311
    local $_finally_guards{guards} = [
      map Try::Tiny::ScopeGuard->_new($_),
      @finally
    ];
  
    # save the value of $@ so we can set $@ back to it in the beginning of the eval
    # and restore $@ after the eval finishes
    my $prev_error = $@;
  
    my ( @ret, $error );
  
    # failed will be true if the eval dies, because 1 will not be returned
    # from the eval body
    my $failed = not eval {
      $@ = $prev_error;
  
      # evaluate the try block in the correct context
      if ( $wantarray ) {
        @ret = $try->();
      } elsif ( defined $wantarray ) {
        $ret[0] = $try->();
      } else {
        $try->();
      };
  
      return 1; # properly set $failed to false
    };
  
    # preserve the current error and reset the original value of $@
    $error = $@;
    $@ = $prev_error;
  
    # at this point $failed contains a true value if the eval died, even if some
    # destructor overwrote $@ as the eval was unwinding.
    if ( $failed ) {
      # pass $error to the finally blocks
      push @$_, $error for @{$_finally_guards{guards}};
  
      # if we got an error, invoke the catch block.
      if ( $catch ) {
        # This works like given($error), but is backwards compatible and
        # sets $_ in the dynamic scope for the body of C<$catch>
        for ($error) {
          return $catch->($error);
        }
  
        # in case when() was used without an explicit return, the C<for>
        # loop will be aborted and there's no useful return value
      }
  
      return;
    } else {
      # no failure, $@ is back to what it was, everything is fine
      return $wantarray ? @ret : $ret[0];
    }
  }
  
  sub catch (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare catch()' unless wantarray;
  
    _subname(caller().'::catch {...} ' => $block)
      if _HAS_SUBNAME;
    return (
      bless(\$block, 'Try::Tiny::Catch'),
      @rest,
    );
  }
  
  sub finally (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare finally()' unless wantarray;
  
    _subname(caller().'::finally {...} ' => $block)
      if _HAS_SUBNAME;
    return (
      bless(\$block, 'Try::Tiny::Finally'),
      @rest,
    );
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    use constant UNSTABLE_DOLLARAT => ("$]" < '5.013002') ? 1 : 0;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my ($code, @args) = @{ $_[0] };
  
      local $@ if UNSTABLE_DOLLARAT;
      eval {
        $code->(@args);
        1;
      } or do {
        warn
          "Execution of finally() block $code resulted in an exception, which "
        . '*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. '
        . 'Your program will continue as if this event never took place. '
        . "Original exception text follows:\n\n"
        . (defined $@ ? $@ : '$@ left undefined...')
        . "\n"
        ;
      }
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Try::Tiny - Minimal try/catch with proper preservation of $@
  
  =head1 VERSION
  
  version 0.31
  
  =head1 SYNOPSIS
  
  You can use Try::Tiny's C<try> and C<catch> to expect and handle exceptional
  conditions, avoiding quirks in Perl and common mistakes:
  
    # handle errors with a catch handler
    try {
      die "foo";
    } catch {
      warn "caught error: $_"; # not $@
    };
  
  You can also use it like a standalone C<eval> to catch and ignore any error
  conditions.  Obviously, this is an extreme measure not to be undertaken
  lightly:
  
    # just silence errors
    try {
      die "foo";
    };
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the C<try> block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L</BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the C<try> block dies, it returns the value of the last statement executed in
  the C<catch> block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following examples all
  assign C<"bar"> to C<$x>:
  
    my $x = try { die "foo" } catch { "bar" };
    my $x = try { die "foo" } || "bar";
    my $x = (try { die "foo" }) // "bar";
  
    my $x = eval { die "foo" } || "bar";
  
  You can add C<finally> blocks, yielding the following:
  
    my $x;
    try { die 'foo' } finally { $x = 'bar' };
    try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  C<finally> blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many C<finally> blocks to a
  given C<try> block as you like.
  
  Note that adding a C<finally> block without a preceding C<catch> block
  suppresses any errors. This behaviour is consistent with using a standalone
  C<eval>, but it is not consistent with C<try>/C<finally> patterns found in
  other programming languages, such as Java, Python, Javascript or C#. If you
  learned the C<try>/C<finally> pattern from one of these languages, watch out for
  this.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory C<try> subroutine, an optional C<catch> subroutine and C<finally>
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the C<finally> block, if given, will execute.
  
  =item catch (&;@)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
    catch { ... }
  
  Inside the C<catch> block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
    local $@ = $_;
  
  =item finally (&;@)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. C<finally> blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the C<finally> block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  (Note that the C<finally> block does not
  localize C<$_> with the error, since unlike in a C<catch> block, there is no way
  to know if C<$_ == undef> implies that there were no errors.) In other words,
  the following code does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the C<finally> block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  Furthermore B<exceptions in C<finally> blocks are not trappable and are unable
  to influence the execution of your program>. This is due to limitation of
  C<DESTROY>-based scope guards, which C<finally> is implemented on top of. This
  may change in a future version of Try::Tiny.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an C<eval> block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically,
  L<before Perl version 5.14.0|perl5140delta/"Exception Handling">
  C<$@> was clobbered at the beginning of the C<eval>, which
  also made it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (the one
  available before entering the C<try> block) in the beginning of the C<eval>
  block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an C<eval> block, C<die> behaves sort of like:
  
    sub die {
      $@ = $_[0];
      return_undef_from_eval();
    }
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
    my $error = do {
      local $@;
      eval { ... };
      $@;
    };
  
    ...
    die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
    if ( $@ ) {
      ...
    }
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode (fixed in L<Perl 5.14.0|perl5140delta/"Exception Handling">) is:
  
    sub Object::DESTROY {
      eval { ... }
    }
  
    eval {
      my $obj = Object->new;
  
      die "foo";
    };
  
    if ( $@ ) {
  
    }
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the C<eval> was aborted due to an error:
  
    my $failed = not eval {
      ...
  
      return 1;
    };
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 ALTERNATE SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements"> (but please don't,
  because that syntax has since been deprecated because there was too much
  unexpected magical behaviour).
  
  =for stopwords topicalizer
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
    try {
      require Foo;
    } catch {
      when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
      default { die $_ }
    };
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  argument list. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
    sub foo {
      my ( $self, @args ) = @_;
      try { $self->bar(@args) }
    }
  
  or
  
    sub bar_in_place {
      my $self = shift;
      my $args = \@_;
      try { $_ = $self->bar($_) for @$args }
    }
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
    sub parent_sub {
      try {
        die;
      }
      catch {
        return;
      };
  
      say "this text WILL be displayed, even though an exception is thrown";
    }
  
  Instead, you should capture the return value:
  
    sub parent_sub {
      my $success = try {
        die;
        1;
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
    # OR
    sub parent_sub_with_catch {
      my $success = try {
        die;
        1;
      }
      catch {
        # do something with $_
        return undef; #see note
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
  
  Note that if you have a C<catch> block, it must return C<undef> for this to work,
  since if a C<catch> block exists, its return value is returned in place of C<undef>
  when an exception is thrown.
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =for stopwords unhygienically
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygienically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
    my $obj = try {
      MightFail->new;
    } catch {
      ...
  
      return; # avoid returning a true value;
    };
  
    return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
    given ($foo) {
      when (...) {
        try {
          ...
        } catch {
          warn $_; # will print $foo, not the error
          warn $_[0]; # instead, get the error like this
        }
      }
    }
  
  Note that this behavior was changed once again in
  L<Perl5 version 18|https://metacpan.org/module/perldelta#given-now-aliases-the-global-_>.
  However, since the entirety of lexical C<$_> is now L<considered experimental
  |https://metacpan.org/module/perldelta#Lexical-_-is-now-experimental>, it
  is unclear whether the new version 18 behavior is final.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<Syntax::Keyword::Try>
  
  Only available on perls >= 5.14, with a slightly different syntax (e.g. no trailing C<;> because
  it's actually a keyword, not a sub, but this means you can C<return> and C<next> within it). Use
  L<Feature::Compat::Try> to automatically switch to the native C<try> syntax in newer perls (when
  available). See also L<Try Catch Exception Handling|perlsyn/Try-Catch-Exception-Handling>.
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://web.archive.org/web/20100628040134/http://nothingmuch.woobling.org/talks/takahashi.xul>
  
  Or read the source:
  
  L<http://web.archive.org/web/20100305133605/http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=Try-Tiny>
  (or L<bug-Try-Tiny@rt.cpan.org|mailto:bug-Try-Tiny@rt.cpan.org>).
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
   ' (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Karen Etheridge Peter Rabbitson Ricardo Signes Mark Fowler Graham Knop Aristotle Pagaltzis Dagfinn Ilmari Mannsker Lukas Mai Alex anaxagoras Andrew Yates awalker chromatic cm-perl David Lowe Glenn Hans Dieter Pearcey Jens Berthold Jonathan Yu Marc Mims Stosberg Pali Paul Howarth Rudolf Leermakers
  
  =over 4
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =item *
  
  Mark Fowler <mark@twoshortplanks.com>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Aristotle Pagaltzis <pagaltzis@gmx.de>
  
  =item *
  
  Dagfinn Ilmari Mannsker <ilmari@ilmari.org>
  
  =item *
  
  Lukas Mai <l.mai@web.de>
  
  =item *
  
  Alex <alex@koban.(none)>
  
  =item *
  
  anaxagoras <walkeraj@gmail.com>
  
  =item *
  
  Andrew Yates <ayates@haddock.local>
  
  =item *
  
  awalker <awalker@sourcefire.com>
  
  =item *
  
  chromatic <chromatic@wgz.org>
  
  =item *
  
  cm-perl <cm-perl@users.noreply.github.com>
  
  =item *
  
  David Lowe <davidl@lokku.com>
  
  =item *
  
  Glenn Fowler <cebjyre@cpan.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Jens Berthold <jens@jebecs.de>
  
  =item *
  
  Jonathan Yu <JAWNSY@cpan.org>
  
  =item *
  
  Marc Mims <marc@questright.com>
  
  =item *
  
  Mark Stosberg <mark@stosberg.com>
  
  =item *
  
  Pali <pali@cpan.org>
  
  =item *
  
  Paul Howarth <paul@city-fan.org>
  
  =item *
  
  Rudolf Leermakers <rudolf@hatsuseno.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is Copyright (c) 2009 by  ' (Yuval Kogman).
  
  This is free software, licensed under:
  
    The MIT (X11) License
  
  =cut
TRY_TINY

    $fatpacked{"URI.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'URI';
  package URI;
  
  use strict;
  use warnings;
  
  our $VERSION = '5.19';
  
  # 1=version 5.10 and earlier; 0=version 5.11 and later
  use constant HAS_RESERVED_SQUARE_BRACKETS => $ENV{URI_HAS_RESERVED_SQUARE_BRACKETS} ? 1 : 0;
  
  our ($ABS_REMOTE_LEADING_DOTS, $ABS_ALLOW_RELATIVE_SCHEME, $DEFAULT_QUERY_FORM_DELIMITER);
  
  my %implements;  # mapping from scheme to implementor class
  
  # Some "official" character classes
  
  our $reserved   = HAS_RESERVED_SQUARE_BRACKETS ? q(;/?:@&=+$,[]) : q(;/?:@&=+$,);
  our $mark       = q(-_.!~*'());                                    #'; emacs
  our $unreserved = "A-Za-z0-9\Q$mark\E";
  our $uric       = quotemeta($reserved) . $unreserved . "%";
  our $uric4host  = $uric . ( HAS_RESERVED_SQUARE_BRACKETS ? '' : quotemeta( q([]) ) );
  our $uric4user  = quotemeta( q{!$'()*,;:._~%-+=%&} ) . "A-Za-z0-9" . ( HAS_RESERVED_SQUARE_BRACKETS ? quotemeta( q([]) ) : '' ); # RFC-3987: iuserinfo w/o UTF
  
  our $scheme_re  = '[a-zA-Z][a-zA-Z0-9.+\-]*';
  
  # These schemes don't have an IPv6+ address part.
  our $schemes_without_host_part_re = 'data|ldapi|urn|sqlite|sqlite3';
  
  # These schemes can have an IPv6+ authority part:
  #     file, ftp, gopher, http, https, ldap, ldaps, mms, news, nntp, nntps, pop, rlogin, rtsp, rtspu, rsync, sip, sips, snews,
  #     telnet, tn3270, ssh, sftp
  #     (all DB URIs, i.e. cassandra, couch, couchdb, etc.), except 'sqlite:', 'sqlite3:'. Others?
  #MAINT: URI has no test coverage for DB schemes
  #MAINT: decoupling - perhaps let each class decide itself by defining a member function 'scheme_has_authority_part()'?
  
  #MAINT: 'mailto:' needs special treatment for IPv* addresses / RFC 5321 (4.1.3). Until then: restore all '[', ']'
  # These schemes need fallback to previous (<= 5.10) encoding until a specific handler is available.
  our $fallback_schemes_re = 'mailto';
  
  use Carp ();
  use URI::Escape ();
  
  use overload ('""'     => sub { ${$_[0]} },
                '=='     => sub { _obj_eq(@_) },
                '!='     => sub { !_obj_eq(@_) },
                fallback => 1,
               );
  
  # Check if two objects are the same object
  sub _obj_eq {
      return overload::StrVal($_[0]) eq overload::StrVal($_[1]);
  }
  
  sub new
  {
      my($class, $uri, $scheme) = @_;
  
      $uri = defined ($uri) ? "$uri" : "";   # stringify
      # Get rid of potential wrapping
      $uri =~ s/^<(?:URL:)?(.*)>$/$1/;  #
      $uri =~ s/^"(.*)"$/$1/;
      $uri =~ s/^\s+//;
      $uri =~ s/\s+$//;
  
      my $impclass;
      if ($uri =~ m/^($scheme_re):/so) {
  	$scheme = $1;
      }
      else {
  	if (($impclass = ref($scheme))) {
  	    $scheme = $scheme->scheme;
  	}
  	elsif ($scheme && $scheme =~ m/^($scheme_re)(?::|$)/o) {
  	    $scheme = $1;
          }
      }
      $impclass ||= implementor($scheme) ||
  	do {
  	    require URI::_foreign;
  	    $impclass = 'URI::_foreign';
  	};
  
      return $impclass->_init($uri, $scheme);
  }
  
  
  sub new_abs
  {
      my($class, $uri, $base) = @_;
      $uri = $class->new($uri, $base);
      $uri->abs($base);
  }
  
  
  sub _init
  {
      my $class = shift;
      my($str, $scheme) = @_;
      # find all funny characters and encode the bytes.
      $str = $class->_uric_escape($str);
      $str = "$scheme:$str" unless $str =~ /^$scheme_re:/o ||
                                   $class->_no_scheme_ok;
      my $self = bless \$str, $class;
      $self;
  }
  
  
  #-- Version: 5.11+
  #   Since the complete URI will be percent-encoded including '[' and ']',
  #   we selectively unescape square brackets from the authority/host part of the URI.
  #   Derived modules that implement _uric_escape() should take this into account
  #   if they do not rely on URI::_uric_escape().
  #   No unescaping is performed for the userinfo@ part of the authority part.
  sub _fix_uric_escape_for_host_part {
    return if HAS_RESERVED_SQUARE_BRACKETS;
    return if $_[0] !~ /%/;
    return if $_[0] =~ m{^(?:$URI::schemes_without_host_part_re):}os;
  
    # until a scheme specific handler is available, fall back to previous behavior of v5.10 (i.e. 'mailto:')
    if ($_[0] =~ m{^(?:$URI::fallback_schemes_re):}os) {
      $_[0]    =~ s/\%5B/[/gi;
      $_[0]    =~ s/\%5D/]/gi;
      return;
    }
  
    if ($_[0] =~ m{^((?:$URI::scheme_re:)?)//([^/?\#]+)(.*)$}os) {
      my $orig          = $2;
      my ($user, $host) = $orig =~ /^(.*@)?([^@]*)$/;
      $user  ||= '';
      my $port = $host =~ s/(:\d+)$// ? $1 : '';
      #MAINT: die() here if scheme indicates TCP/UDP and port is out of range [0..65535] ?
      $host    =~ s/\%5B/[/gi;
      $host    =~ s/\%5D/]/gi;
      $_[0]    =~ s/\Q$orig\E/$user$host$port/;
    }
  }
  
  
  sub _uric_escape
  {
      my($class, $str) = @_;
      $str =~ s*([^$uric\#])* URI::Escape::escape_char($1) *ego;
      _fix_uric_escape_for_host_part( $str );
      utf8::downgrade($str);
      return $str;
  }
  
  my %require_attempted;
  
  sub implementor
  {
      my($scheme, $impclass) = @_;
      if (!$scheme || $scheme !~ /\A$scheme_re\z/o) {
  	require URI::_generic;
  	return "URI::_generic";
      }
  
      $scheme = lc($scheme);
  
      if ($impclass) {
  	# Set the implementor class for a given scheme
          my $old = $implements{$scheme};
          $impclass->_init_implementor($scheme);
          $implements{$scheme} = $impclass;
          return $old;
      }
  
      my $ic = $implements{$scheme};
      return $ic if $ic;
  
      # scheme not yet known, look for internal or
      # preloaded (with 'use') implementation
      $ic = "URI::$scheme";  # default location
  
      # turn scheme into a valid perl identifier by a simple transformation...
      $ic =~ s/\+/_P/g;
      $ic =~ s/\./_O/g;
      $ic =~ s/\-/_/g;
  
      no strict 'refs';
      # check we actually have one for the scheme:
      unless (@{"${ic}::ISA"}) {
          if (not exists $require_attempted{$ic}) {
              # Try to load it
              my $_old_error = $@;
              eval "require $ic";
              die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;
              $@ = $_old_error;
          }
          return undef unless @{"${ic}::ISA"};
      }
  
      $ic->_init_implementor($scheme);
      $implements{$scheme} = $ic;
      $ic;
  }
  
  
  sub _init_implementor
  {
      my($class, $scheme) = @_;
      # Remember that one implementor class may actually
      # serve to implement several URI schemes.
  }
  
  
  sub clone
  {
      my $self = shift;
      my $other = $$self;
      bless \$other, ref $self;
  }
  
  sub TO_JSON { ${$_[0]} }
  
  sub _no_scheme_ok { 0 }
  
  sub _scheme
  {
      my $self = shift;
  
      unless (@_) {
  	return undef unless $$self =~ /^($scheme_re):/o;
  	return $1;
      }
  
      my $old;
      my $new = shift;
      if (defined($new) && length($new)) {
  	Carp::croak("Bad scheme '$new'") unless $new =~ /^$scheme_re$/o;
  	$old = $1 if $$self =~ s/^($scheme_re)://o;
  	my $newself = URI->new("$new:$$self");
  	$$self = $$newself;
  	bless $self, ref($newself);
      }
      else {
  	if ($self->_no_scheme_ok) {
  	    $old = $1 if $$self =~ s/^($scheme_re)://o;
  	    Carp::carp("Oops, opaque part now look like scheme")
  		if $^W && $$self =~ m/^$scheme_re:/o
  	}
  	else {
  	    $old = $1 if $$self =~ m/^($scheme_re):/o;
  	}
      }
  
      return $old;
  }
  
  sub scheme
  {
      my $scheme = shift->_scheme(@_);
      return undef unless defined $scheme;
      lc($scheme);
  }
  
  sub has_recognized_scheme {
      my $self = shift;
      return ref($self) !~ /^URI::_(?:foreign|generic)\z/;
  }
  
  sub opaque
  {
      my $self = shift;
  
      unless (@_) {
  	$$self =~ /^(?:$scheme_re:)?([^\#]*)/o or die;
  	return $1;
      }
  
      $$self =~ /^($scheme_re:)?    # optional scheme
  	        ([^\#]*)          # opaque
                  (\#.*)?           # optional fragment
                $/sx or die;
  
      my $old_scheme = $1;
      my $old_opaque = $2;
      my $old_frag   = $3;
  
      my $new_opaque = shift;
      $new_opaque = "" unless defined $new_opaque;
      $new_opaque =~ s/([^$uric])/ URI::Escape::escape_char($1)/ego;
      utf8::downgrade($new_opaque);
  
      $$self = defined($old_scheme) ? $old_scheme : "";
      $$self .= $new_opaque;
      $$self .= $old_frag if defined $old_frag;
  
      $old_opaque;
  }
  
  sub path { goto &opaque }  # alias
  
  
  sub fragment
  {
      my $self = shift;
      unless (@_) {
  	return undef unless $$self =~ /\#(.*)/s;
  	return $1;
      }
  
      my $old;
      $old = $1 if $$self =~ s/\#(.*)//s;
  
      my $new_frag = shift;
      if (defined $new_frag) {
  	$new_frag =~ s/([^$uric])/ URI::Escape::escape_char($1) /ego;
  	utf8::downgrade($new_frag);
  	$$self .= "#$new_frag";
      }
      $old;
  }
  
  
  sub as_string
  {
      my $self = shift;
      $$self;
  }
  
  
  sub as_iri
  {
      my $self = shift;
      my $str = $$self;
      if ($str =~ s/%([89a-fA-F][0-9a-fA-F])/chr(hex($1))/eg) {
  	# All this crap because the more obvious:
  	#
  	#   Encode::decode("UTF-8", $str, sub { sprintf "%%%02X", shift })
  	#
  	# doesn't work before Encode 2.39.  Wait for a standard release
  	# to bundle that version.
  
  	require Encode;
  	my $enc = Encode::find_encoding("UTF-8");
  	my $u = "";
  	while (length $str) {
  	    $u .= $enc->decode($str, Encode::FB_QUIET());
  	    if (length $str) {
  		# escape next char
  		$u .= URI::Escape::escape_char(substr($str, 0, 1, ""));
  	    }
  	}
  	$str = $u;
      }
      return $str;
  }
  
  
  sub canonical
  {
      # Make sure scheme is lowercased, that we don't escape unreserved chars,
      # and that we use upcase escape sequences.
  
      my $self = shift;
      my $scheme = $self->_scheme || "";
      my $uc_scheme = $scheme =~ /[A-Z]/;
      my $esc = $$self =~ /%[a-fA-F0-9]{2}/;
      return $self unless $uc_scheme || $esc;
  
      my $other = $self->clone;
      if ($uc_scheme) {
  	$other->_scheme(lc $scheme);
      }
      if ($esc) {
  	$$other =~ s{%([0-9a-fA-F]{2})}
  	            { my $a = chr(hex($1));
                        $a =~ /^[$unreserved]\z/o ? $a : "%\U$1"
                      }ge;
      }
      return $other;
  }
  
  # Compare two URIs, subclasses will provide a more correct implementation
  sub eq {
      my($self, $other) = @_;
      $self  = URI->new($self, $other) unless ref $self;
      $other = URI->new($other, $self) unless ref $other;
      ref($self) eq ref($other) &&                # same class
  	$self->canonical->as_string eq $other->canonical->as_string;
  }
  
  # generic-URI transformation methods
  sub abs { $_[0]; }
  sub rel { $_[0]; }
  
  sub secure { 0 }
  
  # help out Storable
  sub STORABLE_freeze {
         my($self, $cloning) = @_;
         return $$self;
  }
  
  sub STORABLE_thaw {
         my($self, $cloning, $str) = @_;
         $$self = $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI - Uniform Resource Identifiers (absolute and relative)
  
  =head1 SYNOPSIS
  
   use URI ();
  
   $u1 = URI->new("http://www.example.com");
   $u2 = URI->new("foo", "http");
   $u3 = $u2->abs($u1);
   $u4 = $u3->clone;
   $u5 = URI->new("HTTP://WWW.example.com:80")->canonical;
  
   $str = $u->as_string;
   $str = "$u";
  
   $scheme = $u->scheme;
   $opaque = $u->opaque;
   $path   = $u->path;
   $frag   = $u->fragment;
  
   $u->scheme("ftp");
   $u->host("ftp.example.com");
   $u->path("cpan/");
  
  =head1 DESCRIPTION
  
  This module implements the C<URI> class.  Objects of this class
  represent "Uniform Resource Identifier references" as specified in RFC
  2396 (and updated by RFC 2732).
  
  A Uniform Resource Identifier is a compact string of characters that
  identifies an abstract or physical resource.  A Uniform Resource
  Identifier can be further classified as either a Uniform Resource Locator
  (URL) or a Uniform Resource Name (URN).  The distinction between URL
  and URN does not matter to the C<URI> class interface. A
  "URI-reference" is a URI that may have additional information attached
  in the form of a fragment identifier.
  
  An absolute URI reference consists of three parts:  a I<scheme>, a
  I<scheme-specific part> and a I<fragment> identifier.  A subset of URI
  references share a common syntax for hierarchical namespaces.  For
  these, the scheme-specific part is further broken down into
  I<authority>, I<path> and I<query> components.  These URIs can also
  take the form of relative URI references, where the scheme (and
  usually also the authority) component is missing, but implied by the
  context of the URI reference.  The three forms of URI reference
  syntax are summarized as follows:
  
    <scheme>:<scheme-specific-part>#<fragment>
    <scheme>://<authority><path>?<query>#<fragment>
    <path>?<query>#<fragment>
  
  The components into which a URI reference can be divided depend on the
  I<scheme>.  The C<URI> class provides methods to get and set the
  individual components.  The methods available for a specific
  C<URI> object depend on the scheme.
  
  =head1 CONSTRUCTORS
  
  The following methods construct new C<URI> objects:
  
  =over 4
  
  =item $uri = URI->new( $str )
  
  =item $uri = URI->new( $str, $scheme )
  
  Constructs a new URI object.  The string
  representation of a URI is given as argument, together with an optional
  scheme specification.  Common URI wrappers like "" and <>, as well as
  leading and trailing white space, are automatically removed from
  the $str argument before it is processed further.
  
  The constructor determines the scheme, maps this to an appropriate
  URI subclass, constructs a new object of that class and returns it.
  
  If the scheme isn't one of those that URI recognizes, you still get
  an URI object back that you can access the generic methods on.  The
  C<< $uri->has_recognized_scheme >> method can be used to test for
  this.
  
  The $scheme argument is only used when $str is a
  relative URI.  It can be either a simple string that
  denotes the scheme, a string containing an absolute URI reference, or
  an absolute C<URI> object.  If no $scheme is specified for a relative
  URI $str, then $str is simply treated as a generic URI (no scheme-specific
  methods available).
  
  The set of characters available for building URI references is
  restricted (see L<URI::Escape>).  Characters outside this set are
  automatically escaped by the URI constructor.
  
  =item $uri = URI->new_abs( $str, $base_uri )
  
  Constructs a new absolute URI object.  The $str argument can
  denote a relative or absolute URI.  If relative, then it is
  absolutized using $base_uri as base. The $base_uri must be an absolute
  URI.
  
  =item $uri = URI::file->new( $filename )
  
  =item $uri = URI::file->new( $filename, $os )
  
  Constructs a new I<file> URI from a file name.  See L<URI::file>.
  
  =item $uri = URI::file->new_abs( $filename )
  
  =item $uri = URI::file->new_abs( $filename, $os )
  
  Constructs a new absolute I<file> URI from a file name.  See
  L<URI::file>.
  
  =item $uri = URI::file->cwd
  
  Returns the current working directory as a I<file> URI.  See
  L<URI::file>.
  
  =item $uri->clone
  
  Returns a copy of the $uri.
  
  =back
  
  =head1 COMMON METHODS
  
  The methods described in this section are available for all C<URI>
  objects.
  
  Methods that give access to components of a URI always return the
  old value of the component.  The value returned is C<undef> if the
  component was not present.  There is generally a difference between a
  component that is empty (represented as C<"">) and a component that is
  missing (represented as C<undef>).  If an accessor method is given an
  argument, it updates the corresponding component in addition to
  returning the old value of the component.  Passing an undefined
  argument removes the component (if possible).  The description of
  each accessor method indicates whether the component is passed as
  an escaped (percent-encoded) or an unescaped string.  A component that can be further
  divided into sub-parts are usually passed escaped, as unescaping might
  change its semantics.
  
  The common methods available for all URI are:
  
  =over 4
  
  =item $uri->scheme
  
  =item $uri->scheme( $new_scheme )
  
  Sets and returns the scheme part of the $uri.  If the $uri is
  relative, then $uri->scheme returns C<undef>.  If called with an
  argument, it updates the scheme of $uri, possibly changing the
  class of $uri, and returns the old scheme value.  The method croaks
  if the new scheme name is illegal; a scheme name must begin with a
  letter and must consist of only US-ASCII letters, numbers, and a few
  special marks: ".", "+", "-".  This restriction effectively means
  that the scheme must be passed unescaped.  Passing an undefined
  argument to the scheme method makes the URI relative (if possible).
  
  Letter case does not matter for scheme names.  The string
  returned by $uri->scheme is always lowercase.  If you want the scheme
  just as it was written in the URI in its original case,
  you can use the $uri->_scheme method instead.
  
  =item $uri->has_recognized_scheme
  
  Returns TRUE if the URI scheme is one that URI recognizes.
  
  It will also be TRUE for relative URLs where a recognized
  scheme was provided to the constructor, even if C<< $uri->scheme >>
  returns C<undef> for these.
  
  =item $uri->opaque
  
  =item $uri->opaque( $new_opaque )
  
  Sets and returns the scheme-specific part of the $uri
  (everything between the scheme and the fragment)
  as an escaped string.
  
  =item $uri->path
  
  =item $uri->path( $new_path )
  
  Sets and returns the same value as $uri->opaque unless the URI
  supports the generic syntax for hierarchical namespaces.
  In that case the generic method is overridden to set and return
  the part of the URI between the I<host name> and the I<fragment>.
  
  =item $uri->fragment
  
  =item $uri->fragment( $new_frag )
  
  Returns the fragment identifier of a URI reference
  as an escaped string.
  
  =item $uri->as_string
  
  Returns a URI object to a plain ASCII string.  URI objects are
  also converted to plain strings automatically by overloading.  This
  means that $uri objects can be used as plain strings in most Perl
  constructs.
  
  =item $uri->as_iri
  
  Returns a Unicode string representing the URI.  Escaped UTF-8 sequences
  representing non-ASCII characters are turned into their corresponding Unicode
  code point.
  
  =item $uri->canonical
  
  Returns a normalized version of the URI.  The rules
  for normalization are scheme-dependent.  They usually involve
  lowercasing the scheme and Internet host name components,
  removing the explicit port specification if it matches the default port,
  uppercasing all escape sequences, and unescaping octets that can be
  better represented as plain characters.
  
  For efficiency reasons, if the $uri is already in normalized form,
  then a reference to it is returned instead of a copy.
  
  =item $uri->eq( $other_uri )
  
  =item URI::eq( $first_uri, $other_uri )
  
  Tests whether two URI references are equal.  URI references
  that normalize to the same string are considered equal.  The method
  can also be used as a plain function which can also test two string
  arguments.
  
  If you need to test whether two C<URI> object references denote the
  same object, use the '==' operator.
  
  =item $uri->abs( $base_uri )
  
  Returns an absolute URI reference.  If $uri is already
  absolute, then a reference to it is simply returned.  If the $uri
  is relative, then a new absolute URI is constructed by combining the
  $uri and the $base_uri, and returned.
  
  =item $uri->rel( $base_uri )
  
  Returns a relative URI reference if it is possible to
  make one that denotes the same resource relative to $base_uri.
  If not, then $uri is simply returned.
  
  =item $uri->secure
  
  Returns a TRUE value if the URI is considered to point to a resource on
  a secure channel, such as an SSL or TLS encrypted one.
  
  =back
  
  =head1 GENERIC METHODS
  
  The following methods are available to schemes that use the
  common/generic syntax for hierarchical namespaces.  The descriptions of
  schemes below indicate which these are.  Unrecognized schemes are
  assumed to support the generic syntax, and therefore the following
  methods:
  
  =over 4
  
  =item $uri->authority
  
  =item $uri->authority( $new_authority )
  
  Sets and returns the escaped authority component
  of the $uri.
  
  =item $uri->path
  
  =item $uri->path( $new_path )
  
  Sets and returns the escaped path component of
  the $uri (the part between the host name and the query or fragment).
  The path can never be undefined, but it can be the empty string.
  
  =item $uri->path_query
  
  =item $uri->path_query( $new_path_query )
  
  Sets and returns the escaped path and query
  components as a single entity.  The path and the query are
  separated by a "?" character, but the query can itself contain "?".
  
  =item $uri->path_segments
  
  =item $uri->path_segments( $segment, ... )
  
  Sets and returns the path.  In a scalar context, it returns
  the same value as $uri->path.  In a list context, it returns the
  unescaped path segments that make up the path.  Path segments that
  have parameters are returned as an anonymous array.  The first element
  is the unescaped path segment proper;  subsequent elements are escaped
  parameter strings.  Such an anonymous array uses overloading so it can
  be treated as a string too, but this string does not include the
  parameters.
  
  Note that absolute paths have the empty string as their first
  I<path_segment>, i.e. the I<path> C</foo/bar> have 3
  I<path_segments>; "", "foo" and "bar".
  
  =item $uri->query
  
  =item $uri->query( $new_query )
  
  Sets and returns the escaped query component of
  the $uri.
  
  =item $uri->query_form
  
  =item $uri->query_form( $key1 => $val1, $key2 => $val2, ... )
  
  =item $uri->query_form( $key1 => $val1, $key2 => $val2, ..., $delim )
  
  =item $uri->query_form( \@key_value_pairs )
  
  =item $uri->query_form( \@key_value_pairs, $delim )
  
  =item $uri->query_form( \%hash )
  
  =item $uri->query_form( \%hash, $delim )
  
  Sets and returns query components that use the
  I<application/x-www-form-urlencoded> format.  Key/value pairs are
  separated by "&", and the key is separated from the value by a "="
  character.
  
  The form can be set either by passing separate key/value pairs, or via
  an array or hash reference.  Passing an empty array or an empty hash
  removes the query component, whereas passing no arguments at all leaves
  the component unchanged.  The order of keys is undefined if a hash
  reference is passed.  The old value is always returned as a list of
  separate key/value pairs.  Assigning this list to a hash is unwise as
  the keys returned might repeat.
  
  The values passed when setting the form can be plain strings or
  references to arrays of strings.  Passing an array of values has the
  same effect as passing the key repeatedly with one value at a time.
  All the following statements have the same effect:
  
      $uri->query_form(foo => 1, foo => 2);
      $uri->query_form(foo => [1, 2]);
      $uri->query_form([ foo => 1, foo => 2 ]);
      $uri->query_form([ foo => [1, 2] ]);
      $uri->query_form({ foo => [1, 2] });
  
  The $delim parameter can be passed as ";" to force the key/value pairs
  to be delimited by ";" instead of "&" in the query string.  This
  practice is often recommended for URLs embedded in HTML or XML
  documents as this avoids the trouble of escaping the "&" character.
  You might also set the $URI::DEFAULT_QUERY_FORM_DELIMITER variable to
  ";" for the same global effect.
  
  =item @keys = $u->query_param
  
  =item @values = $u->query_param( $key )
  
  =item $first_value = $u->query_param( $key )
  
  =item $u->query_param( $key, $value,... )
  
  If $u->query_param is called with no arguments, it returns all the
  distinct parameter keys of the URI.  In a scalar context it returns the
  number of distinct keys.
  
  When a $key argument is given, the method returns the parameter values with the
  given key.  In a scalar context, only the first parameter value is
  returned.
  
  If additional arguments are given, they are used to update successive
  parameters with the given key.  If any of the values provided are
  array references, then the array is dereferenced to get the actual
  values.
  
  Please note that you can supply multiple values to this method, but you cannot
  supply multiple keys.
  
  Do this:
  
      $uri->query_param( widget_id => 1, 5, 9 );
  
  Do NOT do this:
  
      $uri->query_param( widget_id => 1, frobnicator_id => 99 );
  
  =item $u->query_param_append($key, $value,...)
  
  Adds new parameters with the given
  key without touching any old parameters with the same key.  It
  can be explained as a more efficient version of:
  
     $u->query_param($key,
                     $u->query_param($key),
                     $value,...);
  
  One difference is that this expression would return the old values
  of $key, whereas the query_param_append() method does not.
  
  =item @values = $u->query_param_delete($key)
  
  =item $first_value = $u->query_param_delete($key)
  
  Deletes all key/value pairs with the given key.
  The old values are returned.  In a scalar context, only the first value
  is returned.
  
  Using the query_param_delete() method is slightly more efficient than
  the equivalent:
  
     $u->query_param($key, []);
  
  =item $hashref = $u->query_form_hash
  
  =item $u->query_form_hash( \%new_form )
  
  Returns a reference to a hash that represents the
  query form's key/value pairs.  If a key occurs multiple times, then the hash
  value becomes an array reference.
  
  Note that sequence information is lost.  This means that:
  
     $u->query_form_hash($u->query_form_hash);
  
  is not necessarily a no-op, as it may reorder the key/value pairs.
  The values returned by the query_param() method should stay the same
  though.
  
  =item $uri->query_keywords
  
  =item $uri->query_keywords( $keywords, ... )
  
  =item $uri->query_keywords( \@keywords )
  
  Sets and returns query components that use the
  keywords separated by "+" format.
  
  The keywords can be set either by passing separate keywords directly
  or by passing a reference to an array of keywords.  Passing an empty
  array removes the query component, whereas passing no arguments at
  all leaves the component unchanged.  The old value is always returned
  as a list of separate words.
  
  =back
  
  =head1 SERVER METHODS
  
  For schemes where the I<authority> component denotes an Internet host,
  the following methods are available in addition to the generic
  methods.
  
  =over 4
  
  =item $uri->userinfo
  
  =item $uri->userinfo( $new_userinfo )
  
  Sets and returns the escaped userinfo part of the
  authority component.
  
  For some schemes this is a user name and a password separated by
  a colon.  This practice is not recommended. Embedding passwords in
  clear text (such as URI) has proven to be a security risk in almost
  every case where it has been used.
  
  =item $uri->host
  
  =item $uri->host( $new_host )
  
  Sets and returns the unescaped hostname.
  
  If the C<$new_host> string ends with a colon and a number, then this
  number also sets the port.
  
  For IPv6 addresses the brackets around the raw address is removed in the return
  value from $uri->host.  When setting the host attribute to an IPv6 address you
  can use a raw address or one enclosed in brackets.  The address needs to be
  enclosed in brackets if you want to pass in a new port value as well.
  
    my $uri = URI->new("http://www.\xC3\xBCri-sample/foo/bar.html");
    print $u->host; # www.xn--ri-sample-fra0f
  
  
  =item $uri->ihost
  
  Returns the host in Unicode form. Any IDNA A-labels (encoded unicode chars with
  I<xn--> prefix) are turned into U-labels (unicode chars).
  
    my $uri = URI->new("http://www.\xC3\xBCri-sample/foo/bar.html");
    print $u->ihost; # www.\xC3\xBCri-sample
  
  =item $uri->port
  
  =item $uri->port( $new_port )
  
  Sets and returns the port.  The port is a simple integer
  that should be greater than 0.
  
  If a port is not specified explicitly in the URI, then the URI scheme's default port
  is returned. If you don't want the default port
  substituted, then you can use the $uri->_port method instead.
  
  =item $uri->host_port
  
  =item $uri->host_port( $new_host_port )
  
  Sets and returns the host and port as a single
  unit.  The returned value includes a port, even if it matches the
  default port.  The host part and the port part are separated by a
  colon: ":".
  
  For IPv6 addresses the bracketing is preserved; thus
  URI->new("http://[::1]/")->host_port returns "[::1]:80".  Contrast this with
  $uri->host which will remove the brackets.
  
  =item $uri->default_port
  
  Returns the default port of the URI scheme to which $uri
  belongs.  For I<http> this is the number 80, for I<ftp> this
  is the number 21, etc.  The default port for a scheme can not be
  changed.
  
  =back
  
  =head1 SCHEME-SPECIFIC SUPPORT
  
  Scheme-specific support is provided for the following URI schemes.  For C<URI>
  objects that do not belong to one of these, you can only use the common and
  generic methods.
  
  =over 4
  
  =item B<data>:
  
  The I<data> URI scheme is specified in RFC 2397.  It allows inclusion
  of small data items as "immediate" data, as if it had been included
  externally.
  
  C<URI> objects belonging to the data scheme support the common methods
  and two new methods to access their scheme-specific components:
  $uri->media_type and $uri->data.  See L<URI::data> for details.
  
  =item B<file>:
  
  An old specification of the I<file> URI scheme is found in RFC 1738.
  A new RFC 2396 based specification in not available yet, but file URI
  references are in common use.
  
  C<URI> objects belonging to the file scheme support the common and
  generic methods.  In addition, they provide two methods for mapping file URIs
  back to local file names; $uri->file and $uri->dir.  See L<URI::file>
  for details.
  
  =item B<ftp>:
  
  An old specification of the I<ftp> URI scheme is found in RFC 1738.  A
  new RFC 2396 based specification in not available yet, but ftp URI
  references are in common use.
  
  C<URI> objects belonging to the ftp scheme support the common,
  generic and server methods.  In addition, they provide two methods for
  accessing the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<gopher>:
  
  The I<gopher> URI scheme is specified in
  <draft-murali-url-gopher-1996-12-04> and will hopefully be available
  as a RFC 2396 based specification.
  
  C<URI> objects belonging to the gopher scheme support the common,
  generic and server methods. In addition, they support some methods for
  accessing gopher-specific path components: $uri->gopher_type,
  $uri->selector, $uri->search, $uri->string.
  
  =item B<http>:
  
  The I<http> URI scheme is specified in RFC 2616.
  The scheme is used to reference resources hosted by HTTP servers.
  
  C<URI> objects belonging to the http scheme support the common,
  generic and server methods.
  
  =item B<https>:
  
  The I<https> URI scheme is a Netscape invention which is commonly
  implemented.  The scheme is used to reference HTTP servers through SSL
  connections.  Its syntax is the same as http, but the default
  port is different.
  
  =item B<ldap>:
  
  The I<ldap> URI scheme is specified in RFC 2255.  LDAP is the
  Lightweight Directory Access Protocol.  An ldap URI describes an LDAP
  search operation to perform to retrieve information from an LDAP
  directory.
  
  C<URI> objects belonging to the ldap scheme support the common,
  generic and server methods as well as ldap-specific methods: $uri->dn,
  $uri->attributes, $uri->scope, $uri->filter, $uri->extensions.  See
  L<URI::ldap> for details.
  
  =item B<ldapi>:
  
  Like the I<ldap> URI scheme, but uses a UNIX domain socket.  The
  server methods are not supported, and the local socket path is
  available as $uri->un_path.  The I<ldapi> scheme is used by the
  OpenLDAP package.  There is no real specification for it, but it is
  mentioned in various OpenLDAP manual pages.
  
  =item B<ldaps>:
  
  Like the I<ldap> URI scheme, but uses an SSL connection.  This
  scheme is deprecated, as the preferred way is to use the I<start_tls>
  mechanism.
  
  =item B<mailto>:
  
  The I<mailto> URI scheme is specified in RFC 2368.  The scheme was
  originally used to designate the Internet mailing address of an
  individual or service.  It has (in RFC 2368) been extended to allow
  setting of other mail header fields and the message body.
  
  C<URI> objects belonging to the mailto scheme support the common
  methods and the generic query methods.  In addition, they support the
  following mailto-specific methods: $uri->to, $uri->headers.
  
  Note that the "foo@example.com" part of a mailto is I<not> the
  C<userinfo> and C<host> but instead the C<path>.  This allows a
  mailto URI to contain multiple comma separated email addresses.
  
  =item B<mms>:
  
  The I<mms> URL specification can be found at L<http://sdp.ppona.com/>.
  C<URI> objects belonging to the mms scheme support the common,
  generic, and server methods, with the exception of userinfo and
  query-related sub-components.
  
  =item B<news>:
  
  The I<news>, I<nntp> and I<snews> URI schemes are specified in
  <draft-gilman-news-url-01> and will hopefully be available as an RFC
  2396 based specification soon. (Update: as of April 2010, they are in
  L<RFC 5538|https://tools.ietf.org/html/rfc5538>.
  
  C<URI> objects belonging to the news scheme support the common,
  generic and server methods.  In addition, they provide some methods to
  access the path: $uri->group and $uri->message.
  
  =item B<nntp>:
  
  See I<news> scheme.
  
  =item B<nntps>:
  
  See I<news> scheme and L<RFC 5538|https://tools.ietf.org/html/rfc5538>.
  
  =item B<pop>:
  
  The I<pop> URI scheme is specified in RFC 2384. The scheme is used to
  reference a POP3 mailbox.
  
  C<URI> objects belonging to the pop scheme support the common, generic
  and server methods.  In addition, they provide two methods to access the
  userinfo components: $uri->user and $uri->auth
  
  =item B<rlogin>:
  
  An old specification of the I<rlogin> URI scheme is found in RFC
  1738. C<URI> objects belonging to the rlogin scheme support the
  common, generic and server methods.
  
  =item B<rtsp>:
  
  The I<rtsp> URL specification can be found in section 3.2 of RFC 2326.
  C<URI> objects belonging to the rtsp scheme support the common,
  generic, and server methods, with the exception of userinfo and
  query-related sub-components.
  
  =item B<rtspu>:
  
  The I<rtspu> URI scheme is used to talk to RTSP servers over UDP
  instead of TCP.  The syntax is the same as rtsp.
  
  =item B<rsync>:
  
  Information about rsync is available from L<http://rsync.samba.org/>.
  C<URI> objects belonging to the rsync scheme support the common,
  generic and server methods.  In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<sip>:
  
  The I<sip> URI specification is described in sections 19.1 and 25
  of RFC 3261.  C<URI> objects belonging to the sip scheme support the
  common, generic, and server methods with the exception of path related
  sub-components.  In addition, they provide two methods to get and set
  I<sip> parameters: $uri->params_form and $uri->params.
  
  =item B<sips>:
  
  See I<sip> scheme.  Its syntax is the same as sip, but the default
  port is different.
  
  =item B<snews>:
  
  See I<news> scheme.  Its syntax is the same as news, but the default
  port is different.
  
  =item B<telnet>:
  
  An old specification of the I<telnet> URI scheme is found in RFC
  1738. C<URI> objects belonging to the telnet scheme support the
  common, generic and server methods.
  
  =item B<tn3270>:
  
  These URIs are used like I<telnet> URIs but for connections to IBM
  mainframes.  C<URI> objects belonging to the tn3270 scheme support the
  common, generic and server methods.
  
  =item B<ssh>:
  
  Information about ssh is available at L<http://www.openssh.com/>.
  C<URI> objects belonging to the ssh scheme support the common,
  generic and server methods. In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<sftp>:
  
  C<URI> objects belonging to the sftp scheme support the common,
  generic and server methods. In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<urn>:
  
  The syntax of Uniform Resource Names is specified in RFC 2141.  C<URI>
  objects belonging to the urn scheme provide the common methods, and also the
  methods $uri->nid and $uri->nss, which return the Namespace Identifier
  and the Namespace-Specific String respectively.
  
  The Namespace Identifier basically works like the Scheme identifier of
  URIs, and further divides the URN namespace.  Namespace Identifier
  assignments are maintained at
  L<http://www.iana.org/assignments/urn-namespaces>.
  
  Letter case is not significant for the Namespace Identifier.  It is
  always returned in lower case by the $uri->nid method.  The $uri->_nid
  method can be used if you want it in its original case.
  
  =item B<urn>:B<isbn>:
  
  The C<urn:isbn:> namespace contains International Standard Book
  Numbers (ISBNs) and is described in RFC 3187.  A C<URI> object belonging
  to this namespace has the following extra methods (if the
  Business::ISBN module is available): $uri->isbn,
  $uri->isbn_publisher_code, $uri->isbn_group_code (formerly isbn_country_code,
  which is still supported by issues a deprecation warning), $uri->isbn_as_ean.
  
  =item B<urn>:B<oid>:
  
  The C<urn:oid:> namespace contains Object Identifiers (OIDs) and is
  described in RFC 3061.  An object identifier consists of sequences of digits
  separated by dots.  A C<URI> object belonging to this namespace has an
  additional method called $uri->oid that can be used to get/set the oid
  value.  In a list context, oid numbers are returned as separate elements.
  
  =back
  
  =head1 CONFIGURATION VARIABLES
  
  The following configuration variables influence how the class and its
  methods behave:
  
  =over 4
  
  =item $URI::ABS_ALLOW_RELATIVE_SCHEME
  
  Some older parsers used to allow the scheme name to be present in the
  relative URL if it was the same as the base URL scheme.  RFC 2396 says
  that this should be avoided, but you can enable this old behaviour by
  setting the $URI::ABS_ALLOW_RELATIVE_SCHEME variable to a TRUE value.
  The difference is demonstrated by the following examples:
  
    URI->new("http:foo")->abs("http://host/a/b")
        ==>  "http:foo"
  
    local $URI::ABS_ALLOW_RELATIVE_SCHEME = 1;
    URI->new("http:foo")->abs("http://host/a/b")
        ==>  "http:/host/a/foo"
  
  
  =item $URI::ABS_REMOTE_LEADING_DOTS
  
  You can also have the abs() method ignore excess ".."
  segments in the relative URI by setting $URI::ABS_REMOTE_LEADING_DOTS
  to a TRUE value.  The difference is demonstrated by the following
  examples:
  
    URI->new("../../../foo")->abs("http://host/a/b")
        ==> "http://host/../../foo"
  
    local $URI::ABS_REMOTE_LEADING_DOTS = 1;
    URI->new("../../../foo")->abs("http://host/a/b")
        ==> "http://host/foo"
  
  =item $URI::DEFAULT_QUERY_FORM_DELIMITER
  
  This value can be set to ";" to have the query form C<key=value> pairs
  delimited by ";" instead of "&" which is the default.
  
  =back
  
  =head1 ENVIRONMENT VARIABLES
  
  =over 4
  
  =item URI_HAS_RESERVED_SQUARE_BRACKETS
  
  Before version 5.11, URI treated square brackets as reserved characters
  throughout the whole URI string. However, these brackets are reserved
  only within the authority/host part of the URI and nowhere else (RFC 3986).
  
  Starting with version 5.11, URI takes this distinction into account.
  Setting the environment variable C<URI_HAS_RESERVED_SQUARE_BRACKETS>
  (programmatically or via the shell), restores the old behavior.
  
    #-- restore 5.10 behavior programmatically
    BEGIN {
      $ENV{URI_HAS_RESERVED_SQUARE_BRACKETS} = 1;
    }
    use URI ();
  
  I<Note>: This environment variable is just used during initialization and has to be set
        I<before> module URI is used/required. Changing it at run time has no effect.
  
  Its value can be checked programmatically by accessing the constant
  C<URI::HAS_RESERVED_SQUARE_BRACKETS>.
  
  =back
  
  =head1 BUGS
  
  There are some things that are not quite right:
  
  =over
  
  =item *
  
  Using regexp variables like $1 directly as arguments to the URI accessor methods
  does not work too well with current perl implementations.  I would argue
  that this is actually a bug in perl.  The workaround is to quote
  them. Example:
  
     /(...)/ || die;
     $u->query("$1");
  
  
  =item *
  
  The escaping (percent encoding) of chars in the 128 .. 255 range passed to the
  URI constructor or when setting URI parts using the accessor methods depend on
  the state of the internal UTF8 flag (see utf8::is_utf8) of the string passed.
  If the UTF8 flag is set the UTF-8 encoded version of the character is percent
  encoded.  If the UTF8 flag isn't set the Latin-1 version (byte) of the
  character is percent encoded.  This basically exposes the internal encoding of
  Perl strings.
  
  =back
  
  =head1 PARSING URIs WITH REGEXP
  
  As an alternative to this module, the following (official) regular
  expression can be used to decode a URI:
  
    my($scheme, $authority, $path, $query, $fragment) =
    $uri =~ m|(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?|;
  
  The C<URI::Split> module provides the function uri_split() as a
  readable alternative.
  
  =head1 SEE ALSO
  
  L<URI::file>, L<URI::WithBase>, L<URI::Escape>,
  L<URI::Split>, L<URI::Heuristic>
  
  RFC 2396: "Uniform Resource Identifiers (URI): Generic Syntax",
  Berners-Lee, Fielding, Masinter, August 1998.
  
  L<http://www.iana.org/assignments/uri-schemes>
  
  L<http://www.iana.org/assignments/urn-namespaces>
  
  L<http://www.w3.org/Addressing/>
  
  =head1 COPYRIGHT
  
  Copyright 1995-2009 Gisle Aas.
  
  Copyright 1995 Martijn Koster.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHORS / ACKNOWLEDGMENTS
  
  This module is based on the C<URI::URL> module, which in turn was
  (distantly) based on the C<wwwurl.pl> code in the libwww-perl for
  perl4 developed by Roy Fielding, as part of the Arcadia project at the
  University of California, Irvine, with contributions from Brooks
  Cutter.
  
  C<URI::URL> was developed by Gisle Aas, Tim Bunce, Roy Fielding and
  Martijn Koster with input from other people on the libwww-perl mailing
  list.
  
  C<URI> and related subclasses was developed by Gisle Aas.
  
  =cut
URI

    $fatpacked{"URI/Escape.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'URI_ESCAPE';
  package URI::Escape;
  
  use strict;
  use warnings;
  
  =head1 NAME
  
  URI::Escape - Percent-encode and percent-decode unsafe characters
  
  =head1 SYNOPSIS
  
   use URI::Escape;
   $safe = uri_escape("10% is enough\n");
   $verysafe = uri_escape("foo", "\0-\377");
   $str  = uri_unescape($safe);
  
  =head1 DESCRIPTION
  
  This module provides functions to percent-encode and percent-decode URI strings as
  defined by RFC 3986. Percent-encoding URI's is informally called "URI escaping".
  This is the terminology used by this module, which predates the formalization of the
  terms by the RFC by several years.
  
  A URI consists of a restricted set of characters.  The restricted set
  of characters consists of digits, letters, and a few graphic symbols
  chosen from those common to most of the character encodings and input
  facilities available to Internet users.  They are made up of the
  "unreserved" and "reserved" character sets as defined in RFC 3986.
  
     unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
     reserved      = ":" / "/" / "?" / "#" / "[" / "]" / "@"
                     "!" / "$" / "&" / "'" / "(" / ")"
                   / "*" / "+" / "," / ";" / "="
  
  In addition, any byte (octet) can be represented in a URI by an escape
  sequence: a triplet consisting of the character "%" followed by two
  hexadecimal digits.  A byte can also be represented directly by a
  character, using the US-ASCII character for that octet.
  
  Some of the characters are I<reserved> for use as delimiters or as
  part of certain URI components.  These must be escaped if they are to
  be treated as ordinary data.  Read RFC 3986 for further details.
  
  The functions provided (and exported by default) from this module are:
  
  =over 4
  
  =item uri_escape( $string )
  
  =item uri_escape( $string, $unsafe )
  
  Replaces each unsafe character in the $string with the corresponding
  escape sequence and returns the result.  The $string argument should
  be a string of bytes.  The uri_escape() function will croak if given a
  characters with code above 255.  Use uri_escape_utf8() if you know you
  have such chars or/and want chars in the 128 .. 255 range treated as
  UTF-8.
  
  The uri_escape() function takes an optional second argument that
  overrides the set of characters that are to be escaped.  The set is
  specified as a string that can be used in a regular expression
  character class (between [ ]).  E.g.:
  
    "\x00-\x1f\x7f-\xff"          # all control and hi-bit characters
    "a-z"                         # all lower case characters
    "^A-Za-z"                     # everything not a letter
  
  The default set of characters to be escaped is all those which are
  I<not> part of the C<unreserved> character class shown above as well
  as the reserved characters.  I.e. the default is:
  
      "^A-Za-z0-9\-\._~"
  
  The second argument can also be specified as a regular expression object:
  
    qr/[^A-Za-z]/
  
  Any strings matched by this regular expression will have all of their
  characters escaped.
  
  =item uri_escape_utf8( $string )
  
  =item uri_escape_utf8( $string, $unsafe )
  
  Works like uri_escape(), but will encode chars as UTF-8 before
  escaping them.  This makes this function able to deal with characters
  with code above 255 in $string.  Note that chars in the 128 .. 255
  range will be escaped differently by this function compared to what
  uri_escape() would.  For chars in the 0 .. 127 range there is no
  difference.
  
  Equivalent to:
  
      utf8::encode($string);
      my $uri = uri_escape($string);
  
  Note: JavaScript has a function called escape() that produces the
  sequence "%uXXXX" for chars in the 256 .. 65535 range.  This function
  has really nothing to do with URI escaping but some folks got confused
  since it "does the right thing" in the 0 .. 255 range.  Because of
  this you sometimes see "URIs" with these kind of escapes.  The
  JavaScript encodeURIComponent() function is similar to uri_escape_utf8().
  
  =item uri_unescape($string,...)
  
  Returns a string with each %XX sequence replaced with the actual byte
  (octet).
  
  This does the same as:
  
     $string =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
  
  but does not modify the string in-place as this RE would.  Using the
  uri_unescape() function instead of the RE might make the code look
  cleaner and is a few characters less to type.
  
  In a simple benchmark test I did,
  calling the function (instead of the inline RE above) if a few chars
  were unescaped was something like 40% slower, and something like 700% slower if none were.  If
  you are going to unescape a lot of times it might be a good idea to
  inline the RE.
  
  If the uri_unescape() function is passed multiple strings, then each
  one is returned unescaped.
  
  =back
  
  The module can also export the C<%escapes> hash, which contains the
  mapping from all 256 bytes to the corresponding escape codes.  Lookup
  in this hash is faster than evaluating C<sprintf("%%%02X", ord($byte))>
  each time.
  
  =head1 SEE ALSO
  
  L<URI>
  
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  use Exporter 5.57 'import';
  our %escapes;
  our @EXPORT = qw(uri_escape uri_unescape uri_escape_utf8);
  our @EXPORT_OK = qw(%escapes);
  our $VERSION = '5.19';
  
  use Carp ();
  
  # Build a char->hex map
  for (0..255) {
      $escapes{chr($_)} = sprintf("%%%02X", $_);
  }
  
  my %subst;  # compiled patterns
  
  my %Unsafe = (
      RFC2732 => qr/[^A-Za-z0-9\-_.!~*'()]/,
      RFC3986 => qr/[^A-Za-z0-9\-\._~]/,
  );
  
  sub uri_escape {
      my($text, $patn) = @_;
      return undef unless defined $text;
      my $re;
      if (defined $patn){
          if (ref $patn eq 'Regexp') {
              $text =~ s{($patn)}{
                  join('', map +($escapes{$_} || _fail_hi($_)), split //, "$1")
              }ge;
              return $text;
          }
          $re = $subst{$patn};
          if (!defined $re) {
              $re = $patn;
              # we need to escape the [] characters, except for those used in
              # posix classes. if they are prefixed by a backslash, allow them
              # through unmodified.
              $re =~ s{(\[:\w+:\])|(\\)?([\[\]]|\\\z)}{
                  defined $1 ? $1 : defined $2 ? "$2$3" : "\\$3"
              }ge;
              eval {
                  # disable the warnings here, since they will trigger later
                  # when used, and we only want them to appear once per call,
                  # but every time the same pattern is used.
                  no warnings 'regexp';
                  $re = $subst{$patn} = qr{[$re]};
                  1;
              } or Carp::croak("uri_escape: $@");
          }
      }
      else {
          $re = $Unsafe{RFC3986};
      }
      $text =~ s/($re)/$escapes{$1} || _fail_hi($1)/ge;
      $text;
  }
  
  sub _fail_hi {
      my $chr = shift;
      Carp::croak(sprintf "Can't escape \\x{%04X}, try uri_escape_utf8() instead", ord($chr));
  }
  
  sub uri_escape_utf8 {
      my $text = shift;
      return undef unless defined $text;
      utf8::encode($text);
      return uri_escape($text, @_);
  }
  
  sub uri_unescape {
      # Note from RFC1630:  "Sequences which start with a percent sign
      # but are not followed by two hexadecimal characters are reserved
      # for future extension"
      my $str = shift;
      if (@_ && wantarray) {
          # not executed for the common case of a single argument
          my @str = ($str, @_);  # need to copy
          for (@str) {
              s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
          }
          return @str;
      }
      $str =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg if defined $str;
      $str;
  }
  
  # XXX FIXME escape_char is buggy as it assigns meaning to the string's storage format.
  sub escape_char {
      # Old versions of utf8::is_utf8() didn't properly handle magical vars (e.g. $1).
      # The following forces a fetch to occur beforehand.
      my $dummy = substr($_[0], 0, 0);
  
      if (utf8::is_utf8($_[0])) {
          my $s = shift;
          utf8::encode($s);
          unshift(@_, $s);
      }
  
      return join '', @URI::Escape::escapes{split //, $_[0]};
  }
  
  1;
URI_ESCAPE

    $fatpacked{"WWW/Form/UrlEncoded.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'WWW_FORM_URLENCODED';
  package WWW::Form::UrlEncoded;
  
  use 5.008001;
  use strict;
  use warnings;
  
  BEGIN {
      our $VERSION = "0.26";
      our @EXPORT_OK = qw/parse_urlencoded parse_urlencoded_arrayref build_urlencoded build_urlencoded_utf8/;
  
      my $use_pp = $ENV{WWW_FORM_URLENCODED_PP};
  
      if (!$use_pp) {
          eval {
              require WWW::Form::UrlEncoded::XS;
              if ( $WWW::Form::UrlEncoded::XS::VERSION < $VERSION ) {
                  warn "WWW::Form::UrlEncoded::XS $VERSION is require. fallback to PP version";
                  die;
              }
          };
          $use_pp = !!$@;
      }
  
      if ($use_pp) {
          require WWW::Form::UrlEncoded::PP;
          WWW::Form::UrlEncoded::PP->import(@EXPORT_OK);
      }
      else {
          WWW::Form::UrlEncoded::XS->import(@EXPORT_OK);
      }
  
      require Exporter;
      *import = \&Exporter::import;
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  WWW::Form::UrlEncoded - parser and builder for application/x-www-form-urlencoded
  
  =head1 SYNOPSIS
  
      use WWW::Form::UrlEncoded qw/parse_urlencoded build_urlencoded/;
      
      my $query_string = "foo=bar&baz=param";
      my @params = parse_urlencoded($query_string);
      # ('foo','bar','baz','param')
      
      my $query_string = build_urlencoded('foo','bar','baz','param');
      # "foo=bar&baz=param";
  
  =head1 DESCRIPTION
  
  WWW::Form::UrlEncoded provides application/x-www-form-urlencoded parser and builder.
  This module aims to have compatibility with other CPAN modules like 
  HTTP::Body's urlencoded parser.
  
  This module try to use L<WWW::Form::UrlEncoded::XS> by default and fail to it, 
  use WWW::Form::UrlEncoded::PP instead
  
  =head2 Parser rules
  
  WWW::Form::UrlEncoded parsed string in this rule.
  
  =over 4
  
  =item 1. Split application/x-www-form-urlencoded payload by C<&> (U+0026) or C<;> (U+003B)
  
  =item 2. Ready empty array to store C<name> and C<value>
  
  =item 3. For each divided string, apply next steps.
  
  =over 4
  
  =item 1. If first character of string is C<' '> (U+0020 SPACE), remove it.
  
  =item 2. If string has C<=>, let B<name> be substring from start to first C<=>, but excluding first C<=>, and remains to be B<value>. If there is no strings after first C<=>, B<value> to be empty string C<"">. If first C<=> is first character of the string, let B<key> be empty string C<"">. If string does not have any C<=>, all of the string to be B<key> and B<value> to be empty string C<"">.
  
  =item 3. replace all C<+> (U+002B) with C<' '> (U+0020 SPACE).
  
  =item 4. unescape B<name> and B<value>. push them to the array.
  
  =back
  
  =item 4. return the array.
  
  =back
  
  =head2 Test data
  
    'a=b&c=d'     => ["a","b","c","d"]
    'a=b;c=d'     => ["a","b","c","d"]
    'a=1&b=2;c=3' => ["a","1","b","2","c","3"]
    'a==b&c==d'   => ["a","=b","c","=d"]
    'a=b& c=d'    => ["a","b","c","d"]
    'a=b; c=d'    => ["a","b","c","d"]
    'a=b; c =d'   => ["a","b","c ","d"]
    'a=b;c= d '   => ["a","b","c"," d "]
    'a=b&+c=d'    => ["a","b"," c","d"]
    'a=b&+c+=d'   => ["a","b"," c ","d"]
    'a=b&c=+d+'   => ["a","b","c"," d "]
    'a=b&%20c=d'  => ["a","b"," c","d"]
    'a=b&%20c%20=d' => ["a","b"," c ","d"]
    'a=b&c=%20d%20' => ["a","b","c"," d "]
    'a&c=d'       => ["a","","c","d"]
    'a=b&=d'      => ["a","b","","d"]
    'a=b&='       => ["a","b","",""]
    '&'           => ["","","",""]
    '='           => ["",""]
    ''            => []
  
  =head1 FUNCTION
  
  =over 4
  
  =item @param = parse_urlencoded($str:String)
  
  parse C<$str> and return Array that contains key-value pairs.
  
  =item $param:ArrayRef = parse_urlencoded_arrayref($str:String)
  
  parse C<$str> and return ArrayRef that contains key-value pairs.
  
  =item $string = build_urlencoded(@param)
  
  =item $string = build_urlencoded(@param, $delim)
  
  =item $string = build_urlencoded(\@param)
  
  =item $string = build_urlencoded(\@param, $delim)
  
  =item $string = build_urlencoded(\%param)
  
  =item $string = build_urlencoded(\%param, $delim)
  
  build urlencoded string from B<param>. build_urlencoded accepts arrayref and hashref values.
  
    build_urlencoded( foo => 1, foo => 2);
    build_urlencoded( foo => [1,2] );
    build_urlencoded( [ foo => 1, foo => 2 ] );
    build_urlencoded( [foo => [1,2]] );
    build_urlencoded( {foo => [1,2]} );
  
  If C<$delim> parameter is passed, this function use it instead of using C<&>.
  
  =item $string = build_urlencoded_utf8(...)
  
  This function is almost same as C<build_urlencoded>. build_urlencoded_utf8 call C<utf8::encode> for all parameters.
  
  =back
  
  =head1 ENVIRONMENT VALUE
  
  =over 4
  
  =item * WWW_FORM_URLENCODED_PP
  
  If true, WWW::Form::UrlEncoded force to load WWW::Form::UrlEncoded::PP.
  
  =back
  
  =head1 SEE ALSO
  
  CPAN already has some application/x-www-form-urlencoded parser modules like these.
  
  =over 4
  
  =item L<URL::Encode>
  
  =item L<URL::Encode::XS>
  
  =item L<Text::QueryString>
  
  =back
  
  They does not fully compatible with WWW::Form::UrlEncoded. Handling of empty key-value
  and supporting separator characters are different.
  
  =head1 LICENSE
  
  Copyright (C) Masahiro Nagano.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Masahiro Nagano E<lt>kazeburo@gmail.comE<gt>
  
  =cut
  
WWW_FORM_URLENCODED

    $fatpacked{"WWW/Form/UrlEncoded/PP.pm"}
        = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'WWW_FORM_URLENCODED_PP';
  package WWW::Form::UrlEncoded::PP;
  
  use strict;
  use warnings;
  use base qw/Exporter/;
  
  our @EXPORT_OK = qw/parse_urlencoded parse_urlencoded_arrayref build_urlencoded build_urlencoded_utf8/;
  
  our $DECODE = qr/%([0-9a-fA-F]{2})/;
  our %DecodeMap;
  our %EncodeMap;
  for my $num ( 0 .. 255 ) {
      my $h = sprintf "%02X", $num;
      my $chr = chr $num;
      $DecodeMap{ lc $h } = $chr; #%aa
      $DecodeMap{ uc $h } = $chr; #%AA
      $DecodeMap{ ucfirst lc $h } = $chr; #%Aa
      $DecodeMap{ lcfirst uc $h } = $chr; #%aA
      $EncodeMap{$chr} = '%'. uc $h;
  }
  $EncodeMap{" "} = '+';
  
  sub parse_urlencoded {
      my @params;
      return @params unless defined $_[0];
      for my $pair ( split( /[&;] ?/, $_[0], -1 ) ) {
          $pair =~ y/\+/\x20/;
          my ($key, $val) = split /=/, $pair, 2;
          for ($key, $val) {
              if ( ! defined $_ ) { 
                  push @params, '';
                  next;
              }
              s/$DECODE/$DecodeMap{$1}/gs;
              push @params, $_;
          }
      }
  
      return @params;
  }
  
  sub parse_urlencoded_arrayref {
      [parse_urlencoded(@_)];
  }
  
  our $NEED_UPGRADE = 0;
  sub build_urlencoded {
      return "" unless @_;
      my $uri = '';
      my $delim = '&';
      if ( ref $_[0] && ref $_[0] eq 'ARRAY') {
          my @args = @{$_[0]};
          $delim = $_[1] if defined $_[1];
          utf8::encode($delim) if $NEED_UPGRADE;
          while ( @args ) {
              my $k = shift @args;
              my $v = shift @args;
              if ( ref $v && ref $v eq 'ARRAY') {
                  $uri .= url_encode($k) . '='. url_encode($_) . $delim for @$v;
              }
              else {
                  $uri .= url_encode($k) . '='. url_encode($v) . $delim
              }
          }
      }
      elsif ( ref $_[0] && ref $_[0] eq 'HASH') {
          $delim = $_[1] if defined $_[1];
          utf8::encode($delim) if $NEED_UPGRADE;
          while ( my ($k,$v) = each %{$_[0]} ) {
              if ( ref $v && ref $v eq 'ARRAY') {
                  $uri .= url_encode($k) . '='. url_encode($_) . $delim for @$v;
              }
              else {
                  $uri .= url_encode($k) . '='. url_encode($v) . $delim
              }
          }
      }
      else {
          if ( @_ > 2 && @_ % 2 ) {
              $delim = pop @_;
              utf8::encode($delim) if $NEED_UPGRADE;
          }
          while ( @_ ) {
              my $k = shift @_;
              my $v = shift @_;
              if ( ref $v && ref $v eq 'ARRAY') {
                  $uri .= url_encode($k) . '='. url_encode($_) . $delim for @$v;
              }
              else {
                  $uri .= url_encode($k) . '='. url_encode($v) . $delim
              }
          }
      }
      substr($uri,-1*length($delim),length($delim),"");
      $uri;
  }
  
  sub build_urlencoded_utf8 {
      local $NEED_UPGRADE = 1;
      my $uri = build_urlencoded(@_);
      $uri;
  }
  
  sub url_encode {
      return '' unless defined $_[0];
      my $t = shift;
      utf8::encode($t) if $NEED_UPGRADE;
      {
          use bytes;
          $t =~ s!([^A-Za-z0-9\-\._~])!
              join '',@EncodeMap{exists $EncodeMap{$1} ? ($1) : (split //,$1)}
          !gsxe;
      }
      return $t;
  }
  
  1;
  
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  WWW::Form::UrlEncoded::PP - pure-perl parser and builder for application/x-www-form-urlencoded
  
  =head1 SYNOPSIS
  
      use WWW::Form::UrlEncoded::PP qw/parse_urlencoded build_urlencoded/;
      
      my $query_string = "foo=bar&baz=param";
      my @params = parse_urlencoded($query_string);
      # ('foo','bar','baz','param')
      
      my $query_string = build_urlencoded('foo','bar','baz','param');
      # "foo=bar&baz=param";
  
  =head1 DESCRIPTION
  
  WWW::Form::UrlEncoded::PP provides pure-perl application/x-www-form-urlencoded parser and builder.
  see L<WWW::Form::UrlEncoded>'s document.
  
  =head1 LICENSE
  
  Copyright (C) Masahiro Nagano.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Masahiro Nagano E<lt>kazeburo@gmail.comE<gt>
  
  =cut
  
WWW_FORM_URLENCODED_PP

    $fatpacked{"if.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'IF';
  package if;
  
  $VERSION = '0.0608';
  
  sub work {
    my $method = shift() ? 'import' : 'unimport';
    unless (@_ >= 2) {
      my $type = ($method eq 'import') ? 'use' : 'no';
      die "Too few arguments to '$type if' (some code returning an empty list in list context?)"
    }
    return unless shift;		# CONDITION
  
    my $p = $_[0];		# PACKAGE
    (my $file = "$p.pm") =~ s!::!/!g;
    require $file;		# Works even if $_[0] is a keyword (like open)
    my $m = $p->can($method);
    goto &$m if $m;
  }
  
  sub import   { shift; unshift @_, 1; goto &work }
  sub unimport { shift; unshift @_, 0; goto &work }
  
  1;
  __END__
  
  =head1 NAME
  
  if - C<use> a Perl module if a condition holds
  
  =head1 SYNOPSIS
  
      use if CONDITION, "MODULE", ARGUMENTS;
      no  if CONDITION, "MODULE", ARGUMENTS;
  
  =head1 DESCRIPTION
  
  =head2 C<use if>
  
  The C<if> module is used to conditionally load another module.  The construct:
  
      use if CONDITION, "MODULE", ARGUMENTS;
  
  ... will load C<MODULE> only if C<CONDITION> evaluates to true; it has no
  effect if C<CONDITION> evaluates to false.  (The module name, assuming it
  contains at least one C<::>, must be quoted when C<'use strict "subs";'> is in
  effect.)  If the CONDITION does evaluate to true, then the above line has the
  same effect as:
  
      use MODULE ARGUMENTS;
  
  For example, the F<Unicode::UCD> module's F<charinfo> function will use two functions from F<Unicode::Normalize> only if a certain condition is met:
  
      use if defined &DynaLoader::boot_DynaLoader,
          "Unicode::Normalize" => qw(getCombinClass NFD);
  
  Suppose you wanted C<ARGUMENTS> to be an empty list, I<i.e.>, to have the
  effect of:
  
      use MODULE ();
  
  You can't do this with the C<if> pragma; however, you can achieve
  exactly this effect, at compile time, with:
  
      BEGIN { require MODULE if CONDITION }
  
  =head2 C<no if>
  
  The C<no if> construct is mainly used to deactivate categories of warnings
  when those categories would produce superfluous output under specified
  versions of F<perl>.
  
  For example, the C<redundant> category of warnings was introduced in
  Perl-5.22.  This warning flags certain instances of superfluous arguments to
  C<printf> and C<sprintf>.  But if your code was running warnings-free on
  earlier versions of F<perl> and you don't care about C<redundant> warnings in
  more recent versions, you can call:
  
      use warnings;
      no if $] >= 5.022, q|warnings|, qw(redundant);
  
      my $test    = { fmt  => "%s", args => [ qw( x y ) ] };
      my $result  = sprintf $test->{fmt}, @{$test->{args}};
  
  The C<no if> construct assumes that a module or pragma has correctly
  implemented an C<unimport()> method -- but most modules and pragmata have not.
  That explains why the C<no if> construct is of limited applicability.
  
  =head1 BUGS
  
  The current implementation does not allow specification of the required
  version of the module.
  
  =head1 SEE ALSO
  
  L<Module::Requires> can be used to conditionally load one or modules,
  with constraints based on the version of the module.
  Unlike C<if> though, L<Module::Requires> is not a core module.
  
  L<Module::Load::Conditional> provides a number of functions you can use to
  query what modules are available, and then load one or more of them at runtime.
  
  The L<provide> module from CPAN can be used to select one of several possible
  modules to load based on the version of Perl that is running.
  
  =head1 AUTHOR
  
  Ilya Zakharevich L<mailto:ilyaz@cpan.org>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2002 by Ilya Zakharevich.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
IF

    $fatpacked{"parent.pm"} = '#line ' . (1 + __LINE__) . ' "' . __FILE__ . "\"\n" . <<'PARENT';
  package parent;
  use strict;
  
  our $VERSION = '0.241';
  
  sub import {
      my $class = shift;
  
      my $inheritor = caller(0);
  
      if ( @_ and $_[0] eq '-norequire' ) {
          shift @_;
      } else {
          for ( my @filename = @_ ) {
              s{::|'}{/}g;
              require "$_.pm"; # dies if the file is not found
          }
      }
  
      {
          no strict 'refs';
          push @{"$inheritor\::ISA"}, @_; # dies if a loop is detected
      };
  };
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  parent - Establish an ISA relationship with base classes at compile time
  
  =head1 SYNOPSIS
  
      package Baz;
      use parent qw(Foo Bar);
  
  =head1 DESCRIPTION
  
  Allows you to both load one or more modules, while setting up inheritance from
  those modules at the same time.  Mostly similar in effect to
  
      package Baz;
      BEGIN {
          require Foo;
          require Bar;
          push @ISA, qw(Foo Bar);
      }
  
  By default, every base class needs to live in a file of its own.
  If you want to have a subclass and its parent class in the same file, you
  can tell C<parent> not to load any modules by using the C<-norequire> switch:
  
    package Foo;
    sub exclaim { "I CAN HAS PERL" }
  
    package DoesNotLoadFooBar;
    use parent -norequire, 'Foo', 'Bar';
    # will not go looking for Foo.pm or Bar.pm
  
  This is equivalent to the following code:
  
    package Foo;
    sub exclaim { "I CAN HAS PERL" }
  
    package DoesNotLoadFooBar;
    push @DoesNotLoadFooBar::ISA, 'Foo', 'Bar';
  
  This is also helpful for the case where a package lives within
  a differently named file:
  
    package MyHash;
    use Tie::Hash;
    use parent -norequire, 'Tie::StdHash';
  
  This is equivalent to the following code:
  
    package MyHash;
    require Tie::Hash;
    push @ISA, 'Tie::StdHash';
  
  If you want to load a subclass from a file that C<require> would
  not consider an eligible filename (that is, it does not end in
  either C<.pm> or C<.pmc>), use the following code:
  
    package MySecondPlugin;
    require './plugins/custom.plugin'; # contains Plugin::Custom
    use parent -norequire, 'Plugin::Custom';
  
  =head1 HISTORY
  
  This module was forked from L<base> to remove the cruft
  that had accumulated in it.
  
  =head1 CAVEATS
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<base>
  
  =item L<parent::versioned>
  
  A fork of L<parent> that provides version checking in parent class modules.
  
  =back
  
  =head1 AUTHORS AND CONTRIBUTORS
  
  Rafal Garcia-Suarez, Bart Lateur, Max Maischein, Anno Siegel, Michael Schwern
  
  =head1 MAINTAINER
  
  Max Maischein C< corion@cpan.org >
  
  Copyright (c) 2007-2017 Max Maischein C<< <corion@cpan.org> >>
  Based on the idea of C<base.pm>, which was introduced with Perl 5.004_04.
  
  =head1 LICENSE
  
  This module is released under the same terms as Perl itself.
  
  =cut
PARENT

    s/^  //mg for values %fatpacked;

    my $class = 'FatPacked::' . (0 + \%fatpacked);
    no strict 'refs';
    *{"${class}::files"} = sub { keys %{ $_[0] } };

    if ($] < 5.008) {
        *{"${class}::INC"} = sub {
            if (my $fat = $_[0]{ $_[1] }) {
                my $pos = 0;
                my $last = length $fat;
                return (
                    sub {
                        return 0 if $pos == $last;
                        my $next = (1 + index $fat, "\n", $pos) || $last;
                        $_ .= substr $fat, $pos, $next - $pos;
                        $pos = $next;
                        return 1;
                    }
                );
            }
        };

    } else {
        *{"${class}::INC"} = sub {
            if (my $fat = $_[0]{ $_[1] }) {
                open my $fh, '<', \$fat
                    or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
                return $fh;
            }
            return;
        };
    }

    unshift @INC, bless \%fatpacked, $class;
}    # END OF FATPACK CODE

=head1 NAME

pureproxy - Pure Perl HTTP proxy server

=cut

use strict;
use warnings;

no warnings;

our $VERSION = '0.0200';

BEGIN {
    if ($INC[0] =~ /^FatPacked::/) {
        require Clone::PP;
        $INC{'Clone.pm'} = $INC{'Clone/PP.pm'};
    }
}

INIT {
    if ($^O eq 'darwin' && $ENV{OBJC_DISABLE_INITIALIZE_FORK_SAFETY} ne 'YES') {
        $ENV{OBJC_DISABLE_INITIALIZE_FORK_SAFETY} = 'YES';
        exec $0, @ARGV;
    }
}

BEGIN {
    *warnings::import = sub { };
}

use Config;

use constant SERVER => $ENV{PUREPROXY_SERVER}
    || $Config{useithreads} ? 'Thrall' : 'Starlight';

BEGIN {
    delete $ENV{http_proxy};
    delete $ENV{https_proxy};
}

use Plack::Builder;
use Plack::App::Proxy;

my $app = builder {
    enable 'Proxy::Connect::IO';
    enable 'Proxy::Requests';
    Plack::App::Proxy->new(backend => 'HTTP::Tiny')->to_app;
};

use Plack;
use Plack::Runner;

my $runner = Plack::Runner->new(server => SERVER, env => 'proxy', loader => 'Plack::Loader', version_cb => \&version,);

sub _version () {
    my $server = $runner->{server};
    my $server_version
        = eval  { Plack::Util::load_class($server);                   $server->VERSION }
        || eval { Plack::Util::load_class("Plack::Handler::$server"); "Plack::Handler::$server"->VERSION }
        || 0;
    return "PureProxy/$VERSION $server/$server_version Plack/" . Plack->VERSION . " Perl/$] ($^O)";
}

sub version {
    my ($class) = @_;
    print _version(), "\n";
}

$runner->parse_options('--max-workers=50', @ARGV);

if ($runner->{help}) {
    require Pod::Usage;
    Pod::Usage::pod2usage(-verbose => 1, -input => \*DATA);
}

my %options = @{ $runner->{options} };

if ($options{traffic_log}) {
    my $body_eol = $options{traffic_log_body_eol};
    if ($options{traffic_log} ne '1') {
        open my $logfh, ">>", $options{traffic_log} or die "open($options{traffic_log}): $!";
        $logfh->autoflush(1);
        $app = builder {
            enable 'TrafficLog',
                logger    => sub { $logfh->print(@_) },
                body_eol  => $body_eol,
                with_body => !!$body_eol;
            $app;
        };
    } else {
        $app = builder { enable 'TrafficLog', body_eol => $body_eol, with_body => !!$body_eol; $app; };
    }
}

if (not defined $runner->{access_log} or $runner->{access_log} eq '1') {
    $runner->{access_log} = undef;
    $app = builder { enable 'AccessLog'; $app; };
}

push @{ $runner->{options} }, 'server_software', _version();

$runner->run($app);

__DATA__

=head1 SYNOPSIS

=for markdown ```sh

    pureproxy --host=0.0.0.0 --port=5000 --workers=10 --server Starlight

    pureproxy --traffic-log=traffic.log --traffic-log-body-eol='|'

    pureproxy --access-log=access.log

    pureproxy --other-plackup-options

    pureproxy -v

    http_proxy=http://localhost:5000/ lwp-request -m get http://www.perl.org/

    https_proxy=http://localhost:5000/ lwp-request -m get https://metacpan.org/

=for markdown ```

=head1 DESCRIPTION

This is pure-Perl HTTP proxy server which can be run on almost every Perl
installation.

It supports SSL and TLS if L<IO::Socket::SSL> is installed and IPv6 if
L<IO::Socket::IP> is installed.

It can be fat-packed and then run with any system with standard Perl
interpreter without installing other packages. See F<examples> directory
for fat-packed version of PureProxy script.

=cut

__END__

=head1 ENVIRONMENT

=head2 PUREPROXY_SERVER

Changes the default PSGI server. This is L<Thrall> if Perl supports threads
and L<Starlight> otherwise.

=head1 INSTALLATION

=head2 With cpanm(1)

=for markdown ```sh

    cpanm App::PureProxy

=for markdown ```

=head2 Directly

=for markdown ```sh

    lwp-request -m get https://raw.githubusercontent.com/dex4er/PureProxy/master/fatpack/install.sh | sh

=for markdown ```

or

=for markdown ```sh

    curl -qsSL https://raw.githubusercontent.com/dex4er/PureProxy/master/fatpack/install.sh | sh

=for markdown ```

or

=for markdown ```sh

    wget --quiet -O- https://raw.githubusercontent.com/dex4er/PureProxy/master/fatpack/install.sh | sh

=for markdown ```

=head1 SEE ALSO

L<http://github.com/dex4er/PureProxy>.

=head1 BUGS

This tool has unstable features and can change in future.

=head1 AUTHOR

Piotr Roszatycki <dexter@cpan.org>

=head1 LICENSE

Copyright (c) 2014-2015, 2023 Piotr Roszatycki <dexter@cpan.org>.

This is free software; you can redistribute it and/or modify it under
the same terms as perl itself.

See L<http://dev.perl.org/licenses/artistic.html>
